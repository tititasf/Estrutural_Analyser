
# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit"))))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo"))))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo"))))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key"))))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id"))))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils"))))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://"))))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com"))))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script"))))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

import re
import math
import logging
from typing import Dict, List, Any, Tuple, Optional

class ContextEngine:
    """
    Motor de Busca Contextual (Refatorado).
    Responsável por encontrar entidades (Textos, Linhas) próximos a um item (Pilar/Viga/Laje)
    usando Geometria, Regex e Memória Vetorial.
    """
    
    def __init__(self, dxf_data: Dict, spatial_index, memory=None):
        self.dxf_data = dxf_data
        self.spatial_index = spatial_index
        self.memory = memory

    def perform_search(self, item_context: Dict, search_config: Dict, side: str = None) -> Dict:
        """
        Executa a busca por um slot específico (ex: 'dim', 'level') ao redor do item.
        integrando Inteligência Geométrica e Memória (Active Learning).
        """
        field_id = search_config.get('field_id', 'unknown')
        slot_id = search_config.get('slot_id', 'unknown')
        prompt = search_config.get('prompt', '')
        
        # Parâmetros Base
        base_radius = search_config.get('radius', 800.0)
        
        # 1. Preparar Contexto do Item
        points = item_context['points']
        center_p = item_context.get('pos')
        if not center_p:
            center_p = (sum(p[0] for p in points)/len(points), sum(p[1] for p in points)/len(points))
            
        pilar_type = item_context.get('type', 'UNKNOWN')
        
        # 2. Consultar Memória (Active Learning)
        # Verifica se já aprendemos um offset ou padrão para este tipo de situação
        current_dna = self._generate_dna(item_context)
        training_ctx = None
        
        if self.memory:
            role = f"{field_id}_{slot_id}"
            training_ctx = self.memory.retrieve_relevant_context(
                role=role, 
                item_type=pilar_type, 
                dna_vector=current_dna
            )
            
        # Ajustar Centro de Busca baseado na memória (Offset Aprendido)
        search_center = center_p
        search_radius = base_radius
        confidence = 0.5
        used_memory = False
        debug_info = ""
        
        if training_ctx and training_ctx.get('samples', 0) > 0:
             offset_x, offset_y = training_ctx['avg_rel_pos']
             used_memory = True
             sim = training_ctx.get('similarity', 0.5)
             debug_info = f"IA: Padrão aprendido (Conf: {sim*100:.0f}%, n={training_ctx['samples']})"
             search_center = (center_p[0] + offset_x, center_p[1] + offset_y)
             # Mantemos raio original para permitir tolerância
        
        blocklist = training_ctx.get('blocklist', []) if training_ctx else []
        
        # 3. Executar Busca
        found_ent = None
        new_links = []
        
        # Caso especial: Vazio (X)
        if slot_id == 'void_x':
             side_code = side or (field_id.split('_')[1][1:] if '_' in field_id else None)
             v_lines = self._find_vazio_x_lines([search_center], search_radius, side=side_code)
             if v_lines:
                 for vl in v_lines[:2]:
                     new_links.append({'type': 'line', 'points': [vl['start'], vl['end']], 'text': 'Vazio (X)', 'role': 'Vazio (X)'})
                 found_ent = {'text': 'SEM LAJE'}
                 confidence += 0.2
        else:
            # Busca Textual (Regex/Prefixo)
            # Parse do Prompt (ex: "Buscar texto ('P')")
            prefix_match = re.search(r'["\']([PLV])["\']', prompt)
            regex_match = re.search(r'regex\s*[:=]\s*(.+)', prompt, re.I)
            
            # Estratégia Principal
            if regex_match:
                pattern = regex_match.group(1).strip()
                found_ent = self._find_nearest_text_pattern([search_center], pattern, search_radius, side, ref_origin=item_context.get('pos'), blocklist=blocklist)
            elif prefix_match:
                prefix = prefix_match.group(1)
                found_ent = self._find_nearest_text_prefix([search_center], prefix, search_radius, side, ref_origin=item_context.get('pos'), blocklist=blocklist)
            else:
                # Heurística baseada no nome do campo se prompt for vago
                prefix = None
                if 'name' in field_id or '_v_' in field_id or '_l1_n' in field_id:
                     prefix = 'V' if 'viga' in slot_id or '_v_' in field_id else ('L' if '_l1_' in field_id else 'P')
                found_ent = self._find_nearest_text_prefix([search_center], prefix, search_radius, side, ref_origin=item_context.get('pos'), blocklist=blocklist)

            # Fallback: Se Memória falhou em achar (offset errado?), tenta no original
            if not found_ent and used_memory:
                 # Tenta sem offset
                 if regex_match:
                    found_ent = self._find_nearest_text_pattern([center_p], regex_match.group(1).strip(), base_radius*1.5, side, ref_origin=center_p, blocklist=blocklist)
                 elif prefix_match:
                    found_ent = self._find_nearest_text_prefix([center_p], prefix_match.group(1), base_radius*1.5, side, ref_origin=center_p, blocklist=blocklist)
                 if found_ent:
                     debug_info += " (Recuperado via Fallback sem offset)"

            if found_ent:
                new_links.append({'text': found_ent['text'], 'type': 'text', 'pos': found_ent['pos'], 'role': slot_id})
                confidence += 0.2
            else:
                confidence = 0.0

        return {
            'found_ent': found_ent,
            'links': new_links,
            'confidence': min(1.0, confidence),
            'used_training': used_memory,
            'debug': debug_info if used_memory else f"C:{confidence:.2f} | R:{search_radius:.0f}"
        }

    # --- Métodos Auxiliares de Busca ---

    def find_nearest_text(self, points: List[Tuple[float, float]], prefix: str, radius: float = 800.0) -> Optional[Dict]:
        """Versão pública para busca rápida de textos próximos (ex: 'P', 'V')."""
        return self._find_nearest_text_prefix(points, prefix, radius)

    def _find_nearest_text_prefix(self, points, prefix, radius, side=None, ref_origin=None, blocklist=None):
        if not points or not self.dxf_data: return None
        blocklist = blocklist or []
        cx, cy = points[0] # Simplificação: usa primeiro ponto como centro de busca
        
        texts = self.dxf_data.get('texts', [])
        best_dist = radius
        best_ent = None
        
        for txt in texts:
            if not self._check_side_filter(txt['pos'], (cx, cy), side): continue
            
            content = str(txt.get('text', '')).upper().strip()
            
            # Filtro Blocklist (Exato ou Cleaning)
            if content in blocklist: continue
            
            if prefix:
                if not content.startswith(prefix): continue
                # Verifica digito após prefixo
                if len(content) > len(prefix) and not content[len(prefix)].isdigit(): continue
            
            tx, ty = txt['pos']
            dist = math.hypot(cx - tx, cy - ty)
            if dist < best_dist:
                best_dist = dist
                best_ent = txt
        return best_ent

    def _find_nearest_text_pattern(self, points, pattern, radius, side=None, ref_origin=None, blocklist=None):
        if not points or not self.dxf_data: return None
        blocklist = blocklist or []
        cx, cy = points[0]
        
        texts = self.dxf_data.get('texts', [])
        best_dist = radius
        best_ent = None
        
        for txt in texts:
            if not self._check_side_filter(txt['pos'], (cx, cy), side): continue
            
            content = str(txt.get('text', '')).upper().strip()
            if content in blocklist: continue
            
            if re.search(pattern, content):
                tx, ty = txt['pos']
                dist = math.hypot(cx - tx, cy - ty)
                if dist < best_dist:
                    best_dist = dist
                    best_ent = txt
        return best_ent

    def _find_vazio_x_lines(self, points, radius, side=None):
        if not points: return []
        cx, cy = points[0]
        bbox = (cx - radius, cy - radius, cx + radius, cy + radius)
        nearby = self.spatial_index.query_bbox(bbox)
        
        found = []
        for item in nearby:
            if 'start' in item and 'end' in item: # Linha
                # Verificar se está no setor
                mid_x = (item['start'][0] + item['end'][0])/2
                mid_y = (item['start'][1] + item['end'][1])/2
                if self._check_side_filter((mid_x, mid_y), (cx, cy), side):
                    found.append(item)
        return found
        
    def _check_side_filter(self, target_pos, center_pos, side):
        """Retorna True se target_pos estiver no setor 'side' relativo a center_pos."""
        if not side: return True
        tx, ty = target_pos
        cx, cy = center_pos
        angle = math.degrees(math.atan2(ty - cy, tx - cx))
        
        if side == "A": return (45 <= angle <= 135) # Cima/Direita (TopRight no CAD?) - Revisar mapeamento
        # Assumindo mapeamento padrão do projeto:
        # A: 90 graus (Norte/Cima)? Não, código original usava: A (45..135), B (-45..45), C (-135..-45), D (>135 ou <-135)
        # Isso mapeia: A=Norte, B=Leste, C=Sul, D=Oeste (aprox)
        if side == "A": return (45 <= angle <= 135)
        if side == "B": return (-45 <= angle <= 45)
        if side == "C": return (-135 <= angle <= -45)
        if side == "D": return (angle > 135 or angle < -135)
        if side == "Superior": return (ty > cy)
        if side == "Inferior": return (ty <= cy)
        return True

    def find_neighbors(self, item_context: Dict, radius: float = 1000.0) -> List[Dict]:
        """
        Encontra itens estruturais vizinhos (Pilar, Viga, Laje) usando o Spatial Index.
        """
        points = item_context.get('points')
        if not points: return []
        
        cx = sum(p[0] for p in points) / len(points)
        cy = sum(p[1] for p in points) / len(points)
        
        bbox = (cx - radius, cy - radius, cx + radius, cy + radius)
        candidates = self.spatial_index.query_bbox(bbox)
        
        neighbors = []
        item_id = item_context.get('id')
        
        for item in candidates:
            # Ignorar o próprio item
            if item.get('id') == item_id:
                continue
                
            # Identificar tipos estruturais
            item_type = item.get('type')
            if not item_type:
                if 'points' in item: item_type = 'pillar' if len(item['points']) > 2 else 'polyline'
                elif 'start' in item: item_type = 'beam' # Simplificado
                else: continue
            
            if item_type in ['pillar', 'beam', 'slab', 'polyline']:
                if 'points' in item:
                    pts = item['points']
                    tx = sum(p[0] for p in pts) / len(pts)
                    ty = sum(p[1] for p in pts) / len(pts)
                elif 'start' in item:
                    tx = (item['start'][0] + item['end'][0]) / 2
                    ty = (item['start'][1] + item['end'][1]) / 2
                else: continue
                
                dist = math.hypot(cx - tx, cy - ty)
                neighbors.append({
                    'type': item_type,
                    'name': item.get('name', 'UNKNOWN'),
                    'distance': dist,
                    'pos': (tx, ty)
                })
        
        neighbors.sort(key=lambda x: x['distance'])
        return neighbors[:5]

    def _generate_dna(self, item_context):
        """Gera vetor DNA para o item (Area, Vizinhos, Complexidade, Perimetro)."""
        area = item_context.get('area_val', 1.0)
        points = item_context.get('points', [])
        
        # Perimetro
        perim = 0
        for i in range(len(points)):
            p1, p2 = points[i], points[(i+1)%len(points)]
            perim += math.hypot(p1[0]-p2[0], p1[1]-p2[1])
            
        complexity = perim / (area**0.5) if area > 0 else 0
        
        # Vizinhos: Se não estiver no context, busca agora
        neighbors = item_context.get('neighbors')
        if neighbors is None:
            neighbors = self.find_neighbors(item_context)
            item_context['neighbors'] = neighbors # Cache no item
            
        num_neighbors = len(neighbors)
        avg_dist = sum(n['distance'] for n in neighbors)/num_neighbors if num_neighbors > 0 else 1000.0
             
        # DNA: [Area, NumVizinhos, Complexidade, AvgDistNeighbors]
        return [float(area), float(num_neighbors), float(complexity), float(avg_dist)]

    def extract_float(self, text):
        if not text: return None
        clean_text = text.replace(' ', '').replace(',', '.')
        match = re.search(r"[+-]?\d+\.?\d*", clean_text)
        if match:
            try: return float(match.group())
            except: pass
        return None
