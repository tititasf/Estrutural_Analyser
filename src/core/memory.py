
# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit"))))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo"))))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo"))))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key"))))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id"))))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils"))))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://"))))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com"))))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script"))))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

import json
import logging
import uuid
import os
import traceback
from typing import Dict, List, Any, Optional

try:
    import chromadb
    CHROMA_AVAILABLE = True
except ImportError:
    CHROMA_AVAILABLE = False
    logging.warning("ChromaDB nao encontrado. Active Learning sera limitado.")

class HierarchicalMemory:
    """
    Sistema de Mem√≥ria de Aprendizado com 3 N√≠veis Hier√°rquicos.
    Integra SQLite (Logs) e ChromaDB (Busca Ativa).
    """
    
    def __init__(self, db_manager, vector_db_path="./vector_memory", global_vector_db_path="./data/global_memory"):
        self.db = db_manager
        self.chroma_client = None
        self.local_collection = None
        self.global_collection = None
        
        if CHROMA_AVAILABLE:
            try:
                # 1. Local Collection (Read/Write)
                self.chroma_client = chromadb.PersistentClient(path=vector_db_path)
                self.local_collection = self.chroma_client.get_or_create_collection(
                    name="adaptive_learning",
                    metadata={"hnsw:space": "cosine"}
                )
                
                # 2. Global Collection (Read Only - if exists)
                if os.path.exists(global_vector_db_path):
                    self.global_chroma = chromadb.PersistentClient(path=global_vector_db_path)
                    self.global_collection = self.global_chroma.get_or_create_collection(
                        name="global_intelligence",
                        metadata={"hnsw:space": "cosine"}
                    )
            except Exception as e:
                logging.error(f"Erro ao iniciar ChromaDB: {e}")

    def save_training_event(self, 
                          project_context: Dict, 
                          item_context: Dict, 
                          field_context: Dict, 
                          label: Any, 
                          event_type: str = 'user_correction'):
        """
        Salva evento no SQLite (Log) e ChromaDB (√çndice Sem√¢ntico).
        """
        # 1. Estrutura JSON (Log Completo)
        memory_packet = {
            'level_1_project': project_context,
            'level_2_item': item_context,
            'level_3_field': field_context,
            'target_label': label
        }
        dna_json = json.dumps(memory_packet, default=str)
        
        project_id = project_context.get('id')
        role = f"{item_context.get('type')}_{field_context.get('field_name')}"
        
        # 2. Persistir no SQLite
        self.db.log_training_event(
            project_id=project_id,
            event_type=event_type,
            role=role,
            dna_json=dna_json,
            target_val=str(label),
            status='valid'
        )
        
        # 3. Indexar no ChromaDB (Active Learning) - Apenas Local
        if self.local_collection:
            try:
                # Extrair vetores e metadados para busca sem√¢ntica
                dna_vector = item_context.get('dna_vector')
                if not dna_vector:
                     # Fallback placeholder se nao houver DNA
                     dna_vector = [0.1, 0.2, 0.3, 0.4]

                # Preparar metadados para filtros
                metadata = {
                    "role": str(role),
                    "item_type": str(item_context.get('type', 'UNKNOWN')),
                    "field_id": str(field_context.get('field_name', 'unknown')),
                    "link_type": str(field_context.get('link_type', 'unknown')),
                    "status": str(event_type),
                    "project_id": str(project_id)
                }

                self.local_collection.add(
                    ids=[str(uuid.uuid4())],
                    embeddings=[dna_vector],
                    metadatas=[metadata],
                    documents=[json.dumps(field_context, default=str)]
                )
            except Exception as e:
                logging.error(f"Erro ao indexar no Chroma: {e}")

    def remove_training_event(self, project_id: str, role: str, item_type: str):
        """
        Remove vetores associados do ChromaDB (Undo).
        """
        if not self.local_collection: return
        
        try:
            # Removemos todos que batem com o contexto (Undo Hier√°rquico)
            self.local_collection.delete(
                where={
                    "$and": [
                        {"project_id": {"$eq": project_id}},
                        {"role": {"$eq": role}},
                        {"item_type": {"$eq": item_type}}
                    ]
                }
            )
            logging.info(f"üóëÔ∏è Vetores removidos da mem√≥ria: {role} para projeto {project_id}")
        except Exception as e:
            logging.error(f"Erro ao remover vetores da mem√≥ria: {e}")
            print(traceback.format_exc())

    def retrieve_relevant_context(self, role: str, item_type: str, dna_vector: List[float]) -> Dict:
        """
        Recupera intelig√™ncia acumulada (Local + Global) similar ao contexto atual.
        Prioriza local se a confian√ßa for alta.
        """
        results_local = self._query_collection(self.local_collection, role, item_type, dna_vector)
        results_global = self._query_collection(self.global_collection, role, item_type, dna_vector)
        
        # Merge de resultados: Preferencia local se similaridade > 0.9
        if results_local and results_local['similarity'] > 0.9:
            return results_local
            
        # Caso contr√°rio, mistura ou usa global se local sumir
        if not results_local: return results_global
        if not results_global: return results_local
        
        # Harmoniza√ß√£o (Soma ponderada ou m√©dia)
        # Para simplificar agora: M√©dia dos offsets
        avg_pos = (
            (results_local['avg_rel_pos'][0] + results_global['avg_rel_pos'][0]) / 2,
            (results_local['avg_rel_pos'][1] + results_global['avg_rel_pos'][1]) / 2
        )
        
        # Merge status: Prioridade Local, senao Global
        merged_status = results_local.get('predicted_status', 'valid')
        
        return {
            'avg_rel_pos': avg_pos,
            'samples': results_local['samples'] + results_global['samples'],
            'similarity': max(results_local['similarity'], results_global['similarity']),
            'blocklist': list(set(results_local.get('blocklist', []) + results_global.get('blocklist', []))),
            'predicted_status': merged_status
        }

    def _query_collection(self, collection, role, item_type, dna_vector) -> Optional[Dict]:
        if not collection: return None
        try:
            results = collection.query(
                query_embeddings=[dna_vector],
                n_results=5,
                where={"$and": [{"role": {"$eq": role}}, {"item_type": {"$eq": item_type}}]}
            )
            if not results['ids'] or not results['ids'][0]: return None
            
            metas = results['metadatas'][0]
            dists = results['distances'][0]
            
            # Filtrar por dist√¢ncia razo√°vel
            valid_samples_all = [(m, d) for m, d in zip(metas, dists) if d < 0.2]
            if not valid_samples_all: return None
            
            # Contagem de status para decidir se √© N/A
            na_count = sum(1 for m, _ in valid_samples_all if m.get('status') == 'user_na')
            total_count = len(valid_samples_all)
            
            predicted_status = 'valid'
            if na_count > (total_count / 2):
                predicted_status = 'na'
                
            # Calcular m√©dia apenas dos registros v√°lidos (se houver)
            valid_pos_samples = [m for m, _ in valid_samples_all if m.get('status') != 'user_na']
            
            avg_dx = 0
            avg_dy = 0
            
            if valid_pos_samples:
                avg_dx = sum(m.get('learned_dx', 0) for m in valid_pos_samples) / len(valid_pos_samples)
                avg_dy = sum(m.get('learned_dy', 0) for m in valid_pos_samples) / len(valid_pos_samples)
            
            return {
                'avg_rel_pos': (avg_dx, avg_dy),
                'samples': total_count,
                'similarity': 1.0 - (sum(dists[:total_count])/total_count),
                'blocklist': [],
                'predicted_status': predicted_status
            }
        except Exception:
            return None

    def _hash_geometry(self, geometry):
        """Simplifica√ß√£o de hash geom√©trico para comparison r√°pida."""
        if not geometry: return "empty"
        return str(hash(str(geometry)))

    def save_sample(self, sample_data: Dict):
        """
        Salva uma amostra diretamente no Vector DB (usado para Sync/Restore de logs).
        """
        if not self.collection: return
        
        try:
            # 1. Parse DNA
            dna_input = sample_data.get('dna')
            if isinstance(dna_input, str):
                dna_dict = json.loads(dna_input)
            else:
                dna_dict = dna_input or {}
                
            # 2. Extract Context
            item_ctx = dna_dict.get('level_2_item', {})
            field_ctx = dna_dict.get('level_3_field', {})
            
            # 3. Vector (Mock or Real)
            # Idealmente, aqui usariamos um encoder real. 
            # Por enquanto, tentamos pegar do JSON ou usamos placeholder.
            dna_vector = item_ctx.get('dna_vector', [0.1, 0.2, 0.3, 0.4]) 
            
            # 4. Metadata
            rel_pos = sample_data.get('rel_pos')
            dx, dy = (0.0, 0.0)
            if rel_pos and isinstance(rel_pos, (list, tuple)) and len(rel_pos) >= 2:
                dx, dy = float(rel_pos[0]), float(rel_pos[1])

            metadata = {
                "role": str(sample_data.get('role', 'unknown')),
                "item_type": str(item_ctx.get('type', 'UNKNOWN')),
                "field_id": str(field_ctx.get('field_name', 'unknown')),
                "link_type": str(field_ctx.get('link_type', 'unknown')),
                "learned_dx": dx,
                "learned_dy": dy,
                "status": str(sample_data.get('status', 'valid')),
                "source": "sync_log"
            }

            # 5. Add to Chroma
            import uuid
            self.collection.add(
                ids=[str(uuid.uuid4())],
                embeddings=[dna_vector],
                metadatas=[metadata],
                documents=[str(sample_data.get('content', ''))]
            )
        except Exception as e:
            logging.error(f"Erro no save_sample Chroma: {e}")
