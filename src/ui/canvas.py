
# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit"))))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo"))))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo"))))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key"))))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id"))))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils"))))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://"))))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com"))))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script"))))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

from PySide6.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsItem, QGraphicsSimpleTextItem, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QInputDialog, QLineEdit, QGraphicsLineItem, QGraphicsPathItem, QStyle, QStyleOptionGraphicsItem, QApplication
from PySide6.QtCore import Qt, Signal, QMarginsF, QRectF, QPointF, QLineF
from PySide6.QtGui import QPainter, QWheelEvent, QTransform, QPen, QColor, QBrush, QPainterPath, QFont, QCursor
from src.ui.overlays import PillarGraphicsItem, SlabGraphicsItem
from src.ui.overlays_beams import BeamGraphicsItem
import math

class DXFLineItem(QGraphicsLineItem):
    """Custom Line Item that disables default selection dashed line"""
    def paint(self, painter, option, widget=None):
        # Disable default selection look (dashed box)
        option.state &= ~QStyle.State_Selected
        if self.isSelected():
            # For√ßar pen de destaque se selecionado (backup do setPen)
            painter.setPen(self.pen()) 
        super().paint(painter, option, widget)

class DXFPathItem(QGraphicsPathItem):
    """Custom Path Item that disables default selection dashed line"""
    def paint(self, painter, option, widget=None):
        # Disable default selection look (dashed box)
        option.state &= ~QStyle.State_Selected
        super().paint(painter, option, widget)

class CADCanvas(QGraphicsView):
    pillar_selected = Signal(int)
    pick_completed = Signal(dict) # Retorna dados estruturados do v√≠nculo


    def __init__(self, parent=None):
        super().__init__(parent)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        
        # Configs de Visualiza√ß√£o
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)
        
        # Cores (Dark Mode cad-like)
        self.setBackgroundBrush(QColor(40, 40, 40)) # Dark Gray (n√£o preto absoluto)

        # Corrigir sistema de coordenadas (DXF Y+ √© para CIMA, Qt Y+ √© para BAIXO)
        self.scale(1, -1)
        
        # Estado
        self.interactive_items = {} # Map ID -> GraphicItem (Generic)
        self.current_yellow_item_id = None
        self.item_groups = { # Store lists for bulk visibility toggling
            'pillar': [],
            'slab': [],
            'beam': [],
            'link': [] # Visual links (texts/lines)
        }
        self.beam_visuals = []
        self.persistent_links = {} # Map item_id -> [link_items] para atualiza√ß√£o real-time
        
        # Modo de Capta√ß√£o e Edi√ß√£o
        self.picking_mode = None    # 'text' | 'line'
        self.edit_mode = None       # 'select', 'line', 'text', 'circle', 'dim', 'move'
        self.pick_start = None
        self.dxf_entities = []
        self.snap_points = []       # Snap points ativos (Base + Din√¢micos)
        self.snap_segments = []     # Snap segments ativos (Base + Din√¢micos)
        self.base_snap_points = []  # Snaps do DXF (Fixos)
        self.base_snap_segments = []# Segments do DXF (Fixos)
        self.osnap_modes = ['endpoint', 'midpoint', 'center', 'intersection', 'nearest', 'perpendicular', 'extension', 'node']
        self.overlay_items = []     # Itens persistentes de v√≠nculo
        self.temp_line = None
        self.temp_text = None
        self.temp_item = None
        self.snap_markers = {}      # Dicion√°rio para marcadores {type: item}
        self.instruction_label = None # Mensagem de UX no topo
        
        # Edit State
        self.selected_items = []
        self.keyboard_buffer = ""
        self.input_label = None
        self.is_moving = False
        self._last_mouse_pos = QPointF()
        self.ortho_mode = False     # Restringe a 0, 90, 180, 270 graus
        self.selection_box = None   # Item visual do box de sele√ß√£o
        self.box_start = None       # Ponto inicial do box (cena)
        self.deselect_box_start = None # Right click deselect box start (scene)
        self.deselect_box = None    # Right click visual box

        # Op√ß√µes de Intera√ß√£o
        self.setMouseTracking(True)
        self._is_panning = False
        self._last_pan_pos = None

        # Polyline Picking State
        self.pick_poly_points = []
        self.poly_visual = None  # QGraphicsPathItem
        self.active_isolation = None # Current isolated item ID

        self._init_osnap_markers()
        self._init_instruction_overlay()
        self._init_cad_toolbar()
        self._init_input_overlay()
        
    def reset_for_new_project(self):
        """Prepara o canvas para um novo projeto, isolando o estado anterior."""
        # 1. Nova Cena (SEM PARENT para evitar auto-delete pelo View)
        self.scene = QGraphicsScene() 
        self.scene.setBackgroundBrush(QColor(40, 40, 40))
        self.setScene(self.scene)
        
        # 2. Resetar Estado Interno
        self.interactive_items = {}
        self.item_groups = {
            'pillar': [],
            'slab': [],
            'beam': [],
            'link': []
        }
        self.beam_visuals = []
        self.persistent_links = {}
        self.dxf_entities = []
        self.snap_points = []
        self.snap_segments = []
        self.overlay_items = []
        self.snap_markers = {}
        
        # 3. Reconectar Sinais da Cena
        try:
            self.scene.selectionChanged.connect(self._on_selection_changed)
        except: pass
        
        # 4. Reinicializar Elementos Visuais Fixos
        self._init_osnap_markers()
        self._init_instruction_overlay()
        
        # 5. Resetar Zoom/Pan (Transform)
        self.resetTransform()
        self.scale(1, -1) # Restaurar sistema de coordenadas correto (Qt vs DXF)
        
    def save_state(self):
        """Captura o estado atual da cena e dados auxiliares para cache."""
        s_rect = self.scene.itemsBoundingRect()
        # Salvar o ponto central vis√≠vel para garantir restaura√ß√£o exata da posi√ß√£o
        center_point = self.mapToScene(self.viewport().rect().center())
        
        return {
            'scene': self.scene,
            'scene_rect': self.scene.sceneRect(), 
            'transform': self.transform(),
            'view_center': center_point, # Ponto central da vis√£o (mais robusto que scrollbars)
            'interactive_items': self.interactive_items,
            'item_groups': self.item_groups,
            'dxf_entities': self.dxf_entities,
            'snap_points': self.snap_points,
            'snap_segments': self.snap_segments,
            'persistent_links': self.persistent_links
        }

    def restore_state(self, state):
        """Restaura o estado do canvas a partir do cache."""
        if not state: return
        
        # Restaurar Scene
        self.scene = state['scene']
        self.setScene(self.scene)
        
        # Disable Anchors to prevent auto-centering during state restore
        old_drag = self.dragMode()
        self.setDragMode(QGraphicsView.NoDrag)
        old_anchor = self.transformationAnchor()
        self.setTransformationAnchor(QGraphicsView.NoAnchor)
        self.setResizeAnchor(QGraphicsView.NoAnchor)

        # 1. Definir SceneRect "Inteligente"
        items_rect = self.scene.itemsBoundingRect()
        
        if 'view_center' in state:
            target_center = state['view_center']
            # Cria um rect fict√≠cio da view ao redor do centro alvo (aprox 2000x2000 para garantir)
            view_target_rect = QRectF(target_center.x() - 1000, target_center.y() - 1000, 2000, 2000)
            final_rect = items_rect.united(view_target_rect)
            # Margem de seguran√ßa operacional
            margin = 5000.0 
            final_rect = final_rect.adjusted(-margin, -margin, margin, margin)
        else:
            final_rect = items_rect.adjusted(-1000, -1000, 1000, 1000)
            
        # CRITICAL FIX: Ensure View doesn't have a stale sceneRect override
        self.setSceneRect(QRectF()) 
        self.scene.setSceneRect(final_rect)
        
        QApplication.processEvents() 

        # Restaurar Transform (Zoom) - PRIMEIRO
        if 'transform' in state:
            self.setTransform(state['transform'])
        
        # Restaurar Posi√ß√£o (Pan) - DEPOIS (Deferred)
        if 'view_center' in state:
            target_center = state['view_center']
            
            def do_center():
                # FORCE update scene rect again just to be absolutely sure
                self.scene.setSceneRect(final_rect)
                self.setSceneRect(QRectF()) # Clear override again
                
                # Force view to acknowledge new scene size
                self.updateGeometry()
                self.viewport().updateGeometry()
                
                self.centerOn(target_center)
                
                # Restaurar comportamento normal
                self.setTransformationAnchor(old_anchor)
                self.setResizeAnchor(old_anchor)
                self.setDragMode(old_drag)
                
                # Check Displacement
                current_center = self.mapToScene(self.viewport().rect().center())
                dist = (current_center - target_center).manhattanLength()
                
                if dist > 10:
                    # Force the view's sceneRect to match the desired area temporarily to force scrolling
                    self.setSceneRect(final_rect)
                    self.centerOn(target_center)
                    self.setSceneRect(QRectF()) # Reset to follows-scene

            # Agenda para o pr√≥ximo ciclo do loop de eventos - AUMENTADO PARA 50ms
            from PySide6.QtCore import QTimer
            QTimer.singleShot(50, do_center)
            
        elif 'h_scroll' in state: # Fallback legado
            self.horizontalScrollBar().setValue(state['h_scroll'])
            if 'v_scroll' in state: self.verticalScrollBar().setValue(state['v_scroll'])
            # Restore immediate se n√£o for centerOn
            self.setTransformationAnchor(old_anchor)
            self.setResizeAnchor(old_anchor)
            self.setDragMode(old_drag)
            
        # Restaurar Dados
        self.interactive_items = state['interactive_items']
        self.item_groups = state['item_groups']
        self.dxf_entities = state['dxf_entities']
        self.snap_points = state['snap_points']
        self.snap_segments = state['snap_segments']
        self.persistent_links = state['persistent_links']
        
        self.viewport().update()
        
        # Conectar sinal de mudanca de selecao para realce visual
        try:
            self.scene.selectionChanged.disconnect(self._on_selection_changed)
        except: pass
        self.scene.selectionChanged.connect(self._on_selection_changed)
    
    def reset_state(self):
        """Limpa a cena e reseta refer√™ncias a objetos C++ para evitar crashes."""
        # --- CRITICAL FIX: SWAP SCENE INSTEAD OF CLEARING ---
        # Se usarmos .clear(), destru√≠mos a cena que pode estar cacheada em outra aba.
        # Ao criar uma NOVA cena, deixamos a antiga intacta (preservada no cache)
        # e preparamos o canvas para um novo projeto limpo.
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.scene.selectionChanged.connect(self._on_selection_changed)
        
        # Resetar refer√™ncias a itens que estavam na cena
        self.selection_box = None
        self.box_start = None
        self.deselect_box = None
        self.deselect_box_start = None
        self.poly_visual = None
        self.snap_markers = {}
        self.temp_line = None
        self.temp_text = None
        self.temp_item = None
        self.interactive_items = {}
        self.current_yellow_item_id = None
        
        # Resetar listas
        self.item_groups = {
            'pillar': [],
            'slab': [],
            'beam': [],
            'link': []
        }
        self.dxf_entities = []
        self.snap_points = []
        self.snap_segments = []
        self.persistent_links = {}
        
        # Re-inicializar overlays necess√°rios
        self._init_osnap_markers()
        self._init_instruction_overlay()
        self._init_input_overlay()
    
    # Restoring imports and helper methods that might have been lost or displaced
    def _on_selection_changed(self):
        selected = self.scene.selectedItems()
        print(f"DEBUG: selectionChanged! Total selected in scene: {len(selected)}")
        
        # 1. Resetar itens que n√£o est√£o mais selecionados (baseado na nossa tag _orig_pen)
        # Iteramos apenas os itens que temos certeza que alteramos no passado ou que est√£o na cena
        # Para ser robusto, limpamos o que n√£o estiver no 'selected'
        for item in self.scene.items():
            if hasattr(item, '_orig_pen') and not item.isSelected():
                item.setPen(item._orig_pen)
                item.setZValue(item._orig_z)
                del item._orig_pen
                del item._orig_z
                item.update()

        # 2. Aplicar destaque nos selecionados
        for item in selected:
            # Ignorar itens complexos (pilares/lajes) que j√° tem seu pr√≥prio visual
            if hasattr(item, 'pillar_id') or isinstance(item, (PillarGraphicsItem, SlabGraphicsItem, BeamGraphicsItem)):
                continue
            
            if hasattr(item, 'setPen'):
                if not hasattr(item, '_orig_pen'):
                    item._orig_pen = item.pen()
                    item._orig_z = item.zValue()
                
                # Highlight VERMELHO MUITO GROSSO (10px) e COSM√âTICO (n√£o muda com zoom)
                high_pen = QPen(QColor(255, 0, 0), 10, Qt.SolidLine)
                high_pen.setCosmetic(True)
                item.setPen(high_pen)
                item.setPen(high_pen)
                item.setZValue(1999) # Quase no topo (abaixo apenas da toolbar/overlays de UI)
                item.update()

    def _register_new_geometry(self, item, ent_data):
        """Registra uma nova entidade (criada pelo usu√°rio) nos sistemas de Snap e Metadados"""
        if not item or not ent_data: return
        
        # 1. Adicionar aos metadados para picking de texto/geometria
        self.dxf_entities.append(ent_data)
        
        # 2. Registrar Snaps dependendo do tipo
        g_type = ent_data.get('type')
        if g_type == 'line':
            s, e = ent_data['points']
            self.snap_segments.append((s, e))
            # Midpoint
            mid = ((s[0]+e[0])/2, (s[1]+e[1])/2)
            self._add_snap_point(mid, 'midpoint')
            self._add_snap_point(s, 'endpoint')
            self._add_snap_point(e, 'endpoint')
        elif g_type == 'circle' or g_type == 'arc':
            center = ent_data.get('pos', ent_data.get('center'))
            r = ent_data.get('radius', 0)
            if center:
                self._add_snap_point(center, 'center')
                if r > 0:
                    self._add_snap_point((center[0]+r, center[1]), 'quadrant')
                    self._add_snap_point((center[0]-r, center[1]), 'quadrant')
                    self._add_snap_point((center[0], center[1]+r), 'quadrant')
                    self._add_snap_point((center[0], center[1]-r), 'quadrant')

    def _init_input_overlay(self):
        self.input_label = QLabel(self)
        self.input_label.setStyleSheet("""
            background: rgba(20, 20, 20, 220); 
            color: #00ff00; 
            border: 1px solid #00ff00;
            padding: 8px; border-radius: 4px; 
            font-size: 14px;
            font-weight: bold; font-family: 'Consolas', monospace;
        """)
        self.input_label.hide()
        self.input_label.move(10, self.height() - 50)

    def _init_cad_toolbar(self):
        """Cria barra de ferramentas superior (Header) horizontal"""
        self.toolbar = QWidget(self)
        self.toolbar.setObjectName("CADToolbar")
        # Estilo Header: Glassmorphism horizontal no topo
        self.toolbar.setStyleSheet("""
            QWidget#CADToolbar {
                background: rgba(35, 35, 35, 240);
                border-bottom: 2px solid rgba(160, 112, 255, 100);
                border-radius: 0px;
            }
            QPushButton {
                background: rgba(60, 60, 60, 180);
                border: 1px solid #444;
                border-radius: 4px;
                color: #ddd;
                font-family: 'Segoe UI', Arial;
                font-size: 10px;
                text-align: center;
                padding: 2px;
            }
            QPushButton:hover {
                background: rgba(100, 100, 100, 255);
                border: 1px solid #777;
                color: white;
            }
            QPushButton[active="true"] {
                background: rgba(100, 50, 200, 220);
                border: 1px solid #a070ff;
                color: white;
                font-weight: bold;
            }
        """)
        
        layout = QHBoxLayout(self.toolbar)
        layout.setContentsMargins(15, 4, 15, 4)
        layout.setSpacing(10)

        self.tool_buttons = {}
        tools = [
            ("üñ±Ô∏è SELECT", "select", "Selecionar (ESC)"),
            ("üìè LINHA", "line", "Linha (L)"),
            ("‚≠ï CIRC", "circle", "C√≠rculo (C)"),
            ("üìù TEXTO", "text", "Texto (T)"),
            ("üìê COTA", "dim", "Cota (D)"),
            ("‚ÜîÔ∏è MOVER", "move", "Mover (M)"),
            ("üóëÔ∏è EXCLUIR", "delete", "Excluir (DEL)"),
            ("‚öì ORTHO", "ortho", "Alternar Ortho (F8)")
        ]

        for label, mode, tooltip in tools:
            btn = QPushButton(label)
            btn.setFixedSize(85, 32)
            btn.setToolTip(tooltip)
            btn.setCursor(Qt.PointingHandCursor)
            
            if mode == "delete":
                btn.clicked.connect(self._delete_selection)
                btn.setStyleSheet("QPushButton:hover { background: rgba(220, 50, 50, 255); border: 1px solid #ff4444; }")
            elif mode == "ortho":
                btn.clicked.connect(self.toggle_ortho)
                self.tool_buttons[mode] = btn
            else:
                btn.clicked.connect(lambda checked=False, m=mode: self.set_edit_mode(m))
                self.tool_buttons[mode] = btn
                
            layout.addWidget(btn)
        
        # Modo inicial
        self.set_edit_mode('select')

        # Ajuste inicial de posi√ß√£o e tamanho
        self.toolbar.setGeometry(0, 0, self.width(), 42)

    def toggle_ortho(self):
        """Liga/Desliga modo ortogonal"""
        self.ortho_mode = not self.ortho_mode
        if "ortho" in self.tool_buttons:
            btn = self.tool_buttons["ortho"]
            btn.setProperty("active", self.ortho_mode)
            btn.style().unpolish(btn)
            btn.style().polish(btn)
        self.log(f"Ortho Mode: {'ON' if self.ortho_mode else 'OFF'}")

    def set_edit_mode(self, mode):
        """Define o modo de edi√ß√£o atual"""
        # Se clicar no bot√£o que j√° est√° ativo, volta para select (exceto no delete/ortho que s√£o a√ß√µes)
        if mode == self.edit_mode and mode != 'select':
            mode = 'select'

        self.edit_mode = mode
        self.set_picking_mode(None) 
        
        # Reset de estados de clique
        self.pick_start = None
        self.box_start = None
        self.is_moving = False
        if self.selection_box:
            self.scene.removeItem(self.selection_box)
            self.selection_box = None

        # Atualiza o estado visual dos bot√µes
        for m, btn in self.tool_buttons.items():
            is_active = (m == mode) or (m == "ortho" and self.ortho_mode)
            btn.setProperty("active", is_active)
            btn.style().unpolish(btn)
            btn.style().polish(btn)
        
        if mode and mode != 'select':
            self.setDragMode(QGraphicsView.NoDrag)
            self.setCursor(Qt.CrossCursor)
            self.instruction_label.setText(f"<b>Ferramenta Ativa: {mode.upper()}</b>")
            self.instruction_label.show()
        else:
            # Select mode (default)
            self.edit_mode = 'select'
            self.setDragMode(QGraphicsView.ScrollHandDrag)
            self.setCursor(Qt.ArrowCursor)
            self.instruction_label.hide()
            if self.temp_item: 
                try: self.scene.removeItem(self.temp_item)
                except: pass
                self.temp_item = None

    def _delete_selection(self):
        """Remove itens selecionados"""
        for item in self.selected_items:
            try:
                self.scene.removeItem(item)
                if item in self.overlay_items: self.overlay_items.remove(item)
                # Tamb√©m remover de beam_visuals se for o caso
                if item in self.beam_visuals: self.beam_visuals.remove(item)
            except: pass
        self.selected_items.clear()
        self.log("üóëÔ∏è Itens exclu√≠dos.")
        self.update() # For√ßar repaint

    def log(self, msg):
        # Acessar MainWindow log se poss√≠vel via parent
        curr = self.parent()
        while curr:
            if hasattr(curr, 'log'):
                curr.log(msg)
                return
            curr = curr.parent()
        print(f"Canvas: {msg}")

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'toolbar'):
            self.toolbar.setGeometry(0, 0, self.width(), 42)
        if hasattr(self, 'input_label'):
            self.input_label.move(10, self.height() - 50)

    def set_category_visibility(self, category_to_show, show_links=True):
        """Alterna visibilidade: 'pillar', 'slab', 'beam', 'all'"""
        self.active_isolation = None
        
        # Helper to toggle list
        def toggle_list(key, visible):
            stale_items = []
            for item in self.item_groups.get(key, []):
                try:
                    if visible: item.show()
                    else: item.hide()
                except RuntimeError:
                    # Objeto C++ j√° deletado
                    stale_items.append(item)
            
            # Limpar refer√™ncias mortas
            for si in stale_items:
                if si in self.item_groups.get(key, []):
                    self.item_groups[key].remove(si)
                
        cats = ['pillar', 'slab', 'beam']
        for c in cats:
            should_show = (category_to_show == 'all') or (category_to_show == c)
            toggle_list(c, should_show)
            
        # Links cleaning/redraw logic could go here or be handled by main
        # For now we assume links are child items or part of the visuals handled above?
        # Actually links usually are drawn on demand. 
        # But if we have persistent link visuals, we should group them.
        self.clear_beams() # Limpa destaques tempor√°rios

    def isolate_item(self, item_id, category, apply_zoom=True):
        """Oculta tudo, mostra apenas o item espec√≠fico e seus v√≠nculos"""
        self.active_isolation = item_id
        
        # Hide all first
        self.set_category_visibility('none')
        
        # Show specific item (Label ou Shape interativo)
        if item_id in self.interactive_items:
            item = self.interactive_items[item_id]
            item.show()
            
            # [NOVO] Tamb√©m exibir os v√≠nculos persistentes deste item especificamente
            if item_id in self.persistent_links:
                for link_item in self.persistent_links[item_id]:
                    try: link_item.show()
                    except: pass

            # Zoom to it with consistent margin (400px agrad√°vel)
            if apply_zoom:
                rect = item.sceneBoundingRect()
                margin = 400
                self.fitInView(rect.adjusted(-margin, -margin, margin, margin), Qt.KeepAspectRatio)
                self.centerOn(rect.center())
            
    def clear_interactive(self):
        """Limpa apenas os itens de overlay interativo, mantendo o background DXF"""
        # Se estivermos usando cenas separadas por projeto, o scene.clear() j√° limpou tudo.
        # Mas mantemos aqui para compatibilidade com fluxos manuais.
        for item in self.interactive_items.values():
            try:
                if self.scene and item:
                    self.scene.removeItem(item)
            except (RuntimeError, Exception):
                pass 
        
        self.interactive_items.clear()
        for k in self.item_groups: self.item_groups[k] = []
        self.clear_beams()
        self.clear_overlay()

    def swap_project_state(self, project_data):
        """
        Troca instantaneamente o estado visual do canvas para um novo projeto.
        Garante isolamento total de cenas, cole√ß√µes e auxiliares (Snap/Overlay).
        """
        # 1. Se o projeto n√£o tem cena PR√ìPRIA, criamos uma NOVA.
        if 'scene' not in project_data or project_data['scene'] is None:
             project_data['scene'] = QGraphicsScene(self)
             project_data['scene'].setBackgroundBrush(QColor(40, 40, 40))
             
             # Resetar cole√ß√µes vinculadas a esta nova cena
             project_data['canvas_interactive_items'] = {}
             project_data['canvas_item_groups'] = {k: [] for k in ['pillar', 'slab', 'beam', 'link']}
             project_data['canvas_snap_points'] = []
             project_data['canvas_beam_visuals'] = []
             project_data['snap_markers'] = {}
             project_data['instruction_text'] = None
             project_data['scene_rendered'] = False 
        
        # 2. Trocar a cena no View
        self.scene = project_data['scene']
        self.setScene(self.scene)
        
        # RECONECTAR SINAL DE SELE√á√ÉO (Essencial!)
        try:
            self.scene.selectionChanged.disconnect(self._on_selection_changed)
        except (TypeError, RuntimeError):
            pass
        self.scene.selectionChanged.connect(self._on_selection_changed)
        
        # 3. Restaurar ponteiros de cole√ß√µes e auxiliares para o projeto ativo
        self.interactive_items = project_data['canvas_interactive_items']
        self.item_groups = project_data['canvas_item_groups']
        self.snap_points = project_data['canvas_snap_points']
        self.beam_visuals = project_data['canvas_beam_visuals']
        self.snap_markers = project_data['snap_markers']
        self.instruction_text = project_data.get('instruction_text') # Pode ser None
        
        # Se a cena j√° foi renderizada mas faltam auxiliares, regeneramos no contexto correto
        if not self.snap_markers and project_data.get('scene_rendered'):
             self._init_osnap_markers()
        if not self.instruction_text and project_data.get('scene_rendered'):
             self._init_instruction_overlay()
             project_data['instruction_text'] = self.instruction_text
        
        # For√ßar refresh visual
        self.viewport().update()

    def get_project_state_dict(self):
        """Retorna o estado visual atual para ser guardado no cache do projeto."""
        return {
            'scene': self.scene,
            'canvas_interactive_items': self.interactive_items,
            'canvas_item_groups': self.item_groups,
            'canvas_snap_points': self.snap_points,
            'canvas_beam_visuals': self.beam_visuals,
            'snap_markers': self.snap_markers,
            'instruction_text': self.instruction_text
        }

    def clear_beams(self):
        """Limpa os fios de viga (conflitos)"""
        for item in self.beam_visuals:
            try:
                if self.scene and item:
                    self.scene.removeItem(item)
            except:
                pass
        self.beam_visuals.clear()

    def clear_overlay(self):
        """Limpa itens persistentes de v√≠nculo (linhas/ret√¢ngulos de picking)"""
        for item in self.overlay_items:
            try:
                if self.scene and item:
                    self.scene.removeItem(item)
            except:
                pass
        self.overlay_items.clear()
        
    def _add_snap_point(self, pt, type='endpoint'):
        # Evitar duplicatas exatas
        for s in self.snap_points:
            if abs(s['pos'][0] - pt[0]) < 0.001 and abs(s['pos'][1] - pt[1]) < 0.001:
                # Se j√° existe, atualiza prioridade se for Intersection
                if type == 'intersection': s['type'] = 'intersection'
                return
        self.snap_points.append({'pos': pt, 'type': type})

    def _calculate_intersections(self, lines):
        """Calcula intersec√ß√µes entre todas as linhas (N^2 simplificado)."""
        # Formato lines: [{'start': (x,y), 'end': (x,y)}, ...]
        
    def _line_intersection(self, p1, p2, p3, p4, segment_only=True):
        x1, y1 = p1
        x2, y2 = p2
        x3, y3 = p3
        x4, y4 = p4
        
        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
        if denom == 0: return None  # Paralelas
        
        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom
        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom
        
        if segment_only:
            if 0 <= ua <= 1 and 0 <= ub <= 1:
                return (x1 + ua * (x2 - x1), y1 + ua * (y2 - y1))
        else:
            return (x1 + ua * (x2 - x1), y1 + ua * (y2 - y1))
        return None

        for i in range(len(lines)):
            for j in range(i + 1, len(lines)):
                l1 = lines[i]
                l2 = lines[j]
                
                # Bounding box check r√°pido
                minx1, maxx1 = min(l1['start'][0], l1['end'][0]), max(l1['start'][0], l1['end'][0])
                minx2, maxx2 = min(l2['start'][0], l2['end'][0]), max(l2['start'][0], l2['end'][0])
                if maxx1 < minx2 or maxx2 < minx1: continue
                
                pt = self._line_intersection(l1['start'], l1['end'], l2['start'], l2['end'])
                if pt:
                    self._add_snap_point(pt, 'intersection')

    def add_dxf_entities(self, entities, progress_callback=None):
        """Renderiza geometria base (linhas, textos, etc) do DXF"""
        self.scene.clear()
        
        # Explicitly clear dictionaries to release Python references to C++ items
        self.snap_markers.clear() 
        self.interactive_items.clear()
        
        self.snap_markers = {} # Reset markers
        self.interactive_items = {}
        for k in self.item_groups: self.item_groups[k] = [] # Reset groups
        self.beam_visuals = []
        self.contour_visuals = []
        self.snap_points = []
        self.snap_points = []
        self.snap_segments = []
        
        # Consolidar todas as entidades para busca/picking
        self.dxf_entities = entities.get('texts', []).copy()
        for l in entities.get('lines', []):
            ent = l.copy()
            ent['points'] = [l['start'], l['end']] # Compatibilidade com busca de poly
            self.dxf_entities.append(ent)
        self.dxf_entities.extend(entities.get('polylines', []))
        self.dxf_entities.extend(entities.get('circles', []))
        
        total_steps = len(entities.get('lines', [])) + len(entities.get('polylines', [])) + \
                      len(entities.get('texts', [])) + len(entities.get('circles', []))
        current_step = 0

        def update_prog():
            nonlocal current_step
            current_step += 1
            if progress_callback and current_step % 50 == 0:
                progress_callback(int((current_step / total_steps) * 100))
        
        # Helper para criar Pen a partir de cor DXF
        def get_pen(color_tuple, width=1):
            pen = QPen(QColor(*color_tuple), width)
            pen.setCosmetic(True)
            return pen

        # Armazena linhas para c√°lculo de interse√ß√£o
        calc_lines = []

        # Draw Circles and Arcs
        for circ in entities.get('circles', []):
            center = circ.get('center', circ.get('pos', (0,0)))
            cx, cy = center
            r = circ['radius']
            self._add_snap_point((cx, cy), 'center')
            self._add_snap_point((cx+r, cy), 'quadrant')
            self._add_snap_point((cx-r, cy), 'quadrant')
            self._add_snap_point((cx, cy+r), 'quadrant')
            self._add_snap_point((cx, cy-r), 'quadrant')

            if 'start_angle' in circ: # ARC
                path = QPainterPath()
                path.arcMoveTo(cx - r, cy - r, r * 2, r * 2, circ['start_angle'])
                path.arcTo(cx - r, cy - r, r * 2, r * 2, circ['start_angle'], circ['end_angle'] - circ['start_angle'])
                item = DXFPathItem(path)
                item.setPen(get_pen(circ['color']))
                self.scene.addItem(item)
            else: # CIRCLE
                from PySide6.QtWidgets import QGraphicsEllipseItem
                item = self.scene.addEllipse(cx - r, cy - r, r * 2, r * 2, get_pen(circ['color']))
                # Circle default selection style is box, user complained about lines/polylines. 
                # If circles also need custom highlight, we need DXFEllipseItem. 
                # For now applying to lines/polylines as requested.
                
            item.setFlag(QGraphicsItem.ItemIsSelectable)
            update_prog()

        # Draw Lines
        for line in entities.get('lines', []):
            s, e = line['start'], line['end']
            item = DXFLineItem(s[0], s[1], e[0], e[1])
            item.setPen(get_pen(line['color']))
            self.scene.addItem(item)
            item.setFlag(QGraphicsItem.ItemIsSelectable) 
            self.snap_segments.append((s, e))
            calc_lines.append(line)
            
            # Midpoint
            mid = ((s[0]+e[0])/2, (s[1]+e[1])/2)
            self._add_snap_point(mid, 'midpoint')
            self._add_snap_point(s, 'endpoint')
            self._add_snap_point(e, 'endpoint')
            update_prog()

        # Draw Polylines
        
        for poly in entities.get('polylines', []):
            points = poly['points']
            if not points: continue
            
            path = QPainterPath()
            path.moveTo(points[0][0], points[0][1])
            self._add_snap_point(points[0], 'endpoint')
            
            for i in range(1, len(points)):
                p_prev = points[i-1]
                p_curr = points[i]
                path.lineTo(p_curr[0], p_curr[1])
                
                # Segmento para interse√ß√£o e Midpoint
                calc_lines.append({'start': p_prev, 'end': p_curr})
                self.snap_segments.append((p_prev, p_curr))
                mid = ((p_prev[0]+p_curr[0])/2, (p_prev[1]+p_curr[1])/2)
                self._add_snap_point(mid, 'midpoint')
                self._add_snap_point(p_curr, 'endpoint')
            
            if poly.get('is_closed'):
                path.closeSubpath()
                p_last = points[-1]
                p_first = points[0]
                self.snap_segments.append((p_last, p_first))
                calc_lines.append({'start': p_last, 'end': p_first})
                mid = ((p_last[0]+p_first[0])/2, (p_last[1]+p_first[1])/2)
                self._add_snap_point(mid, 'midpoint')
            
            item = DXFPathItem(path)
            item.setPen(get_pen(poly['color']))
            self.scene.addItem(item)
            item.setFlag(QGraphicsItem.ItemIsSelectable) 
            update_prog()

        # Calcular Interse√ß√µes (Otimiza√ß√£o: Ignorar se houver muitos elementos)
        if len(calc_lines) < 1000:
            self._calculate_intersections(calc_lines)
        else:
            print(f"Skipping intersection calculation for {len(calc_lines)} lines (Performance protection).")
            
        # [NOVO] Backup de Snaps do DXF para regenera√ß√£o segura
        self.base_snap_points = self.snap_points.copy()
        self.base_snap_segments = self.snap_segments.copy()

        # Draw Texts
        from PySide6.QtWidgets import QGraphicsSimpleTextItem
        from PySide6.QtGui import QFont
        
        for txt in entities.get('texts', []):
            content = txt['text']
            
            # --- CUSTOM OFFSET LOGIC (Parafuso 25/75) ---
            # User req: Shift from 20cm to 30cm (approx +10 relative if existing is base)
            # Assumption: "parafuso 25" e "parafuso 75" mapping to P25/P75 text
            pos_x, pos_y = txt['pos']
            if "P25" in content or "P75" in content: # Adjusted per analysis
                 # Assuming the user meant these specific labels
                 # Adding 10 units to X to shift from theoretical 20 to 30
                 pos_x += 10.0 
            
            item = QGraphicsSimpleTextItem(content)
            item.setPos(pos_x, pos_y)
            item.setBrush(QColor(*txt['color']))
            f = QFont("Arial")
            f.setPointSizeF(8)
            item.setFont(f)
            item.setFlag(QGraphicsItem.ItemIgnoresTransformations)
            item.setFlag(QGraphicsItem.ItemIsSelectable)
            self.scene.addItem(item)
            self._add_snap_point((pos_x, pos_y), 'node')
            update_prog()
            
        self._init_osnap_markers()
        self._init_instruction_overlay()
        
        # Smart View (Ignorar outliers do DXF como pontos no 0,0 ou infinito)
        pts = []
        for t in entities.get('texts', []): pts.append(t['pos'])
        for l in entities.get('lines', []): 
            pts.append(l['start'])
            pts.append(l['end'])
        for p in entities.get('polylines', []):
            for pt in p.get('points', []): pts.append(pt)
        for c in entities.get('circles', []):
            center = c.get('center', c.get('pos'))
            if center: pts.append(center)
            
        if pts:
            xs = sorted([p[0] for p in pts])
            ys = sorted([p[1] for p in pts])
            # Pegar do percentil 2 ao 98 para evitar sujeira de borda do CAD
            idx_low = int(len(xs) * 0.02)
            idx_high = int(len(xs) * 0.98)
            
            if idx_high > idx_low:
                xmin, xmax = xs[idx_low], xs[idx_high]
                ymin, ymax = ys[idx_low], ys[idx_high]
                rect = QRectF(xmin, ymin, xmax - xmin, ymax - ymin)
                
                # UX: Adicionar 2000 unidades de respiro em todas as dire√ß√µes para melhor navega√ß√£o
                margin = 2000.0
                rect = rect.adjusted(-margin, -margin, margin, margin)
                
                self.setSceneRect(rect) # Garante que o scroll considere essa √°rea
                self.fitInView(rect, Qt.KeepAspectRatio)
            else:
                self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)
        else:
            self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def _init_osnap_markers(self):
        """Prepara os marcadores de snap (Quadrado, Tri√¢ngulo, X)"""
        # Endpoint/Center: Quadrado Verde
        sq = self.scene.addRect(-5, -5, 10, 10, QPen(QColor(0, 255, 0), 2))
        sq.setZValue(200); sq.hide(); sq.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['endpoint'] = sq
        self.snap_markers['center'] = sq # Reutiliza
        self.snap_markers['quadrant'] = sq # Reutiliza
        
        # Node: C√≠rculo Verde com X
        node_path = QPainterPath()
        node_path.addEllipse(-4, -4, 8, 8)
        node_path.moveTo(-3, -3); node_path.lineTo(3, 3)
        node_path.moveTo(3, -3); node_path.lineTo(-3, 3)
        node = self.scene.addPath(node_path, QPen(QColor(0, 255, 0), 1))
        node.setZValue(200); node.hide(); node.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['node'] = node

        # Midpoint: Tri√¢ngulo Ciano
        from PySide6.QtGui import QPolygonF
        from PySide6.QtCore import QPointF
        tri_poly = QPolygonF([QPointF(0, -6), QPointF(-5, 4), QPointF(5, 4)])
        tri = self.scene.addPolygon(tri_poly, QPen(QColor(0, 255, 255), 2))
        tri.setZValue(200); tri.hide(); tri.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['midpoint'] = tri

        # Intersection: X Vermelho/Laranja
        path = QPainterPath()
        path.moveTo(-5, -5); path.lineTo(5, 5)
        path.moveTo(5, -5); path.lineTo(-5, 5)
        cross = self.scene.addPath(path, QPen(QColor(255, 100, 0), 2))
        cross.setZValue(200); cross.hide(); cross.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['intersection'] = cross

        # Nearest: Ampulheta/X (Ampulheta simplificada)
        path = QPainterPath()
        path.moveTo(-4, -4); path.lineTo(4, 4); path.lineTo(-4, 4); path.lineTo(4, -4); path.closeSubpath()
        near = self.scene.addPath(path, QPen(QColor(0, 255, 0), 1))
        near.setZValue(200); near.hide(); near.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['nearest'] = near

        # Perpendicular: S√≠mbolo de √¢ngulo reto
        path = QPainterPath()
        path.moveTo(0, -6); path.lineTo(0, 0); path.lineTo(6, 0)
        perp = self.scene.addPath(path, QPen(QColor(0, 255, 0), 2))
        perp.setZValue(200); perp.hide(); perp.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['perpendicular'] = perp

        # Extension: X tracejado ou pequeno circulo
        ext_path = QPainterPath()
        ext_path.moveTo(-4, 0); ext_path.lineTo(4, 0)
        ext_path.moveTo(0, -4); ext_path.lineTo(0, 4)
        ext = self.scene.addPath(ext_path, QPen(QColor(0, 255, 0), 1, Qt.DashLine))
        ext.setZValue(200); ext.hide(); ext.setFlag(QGraphicsItem.ItemIgnoresTransformations)
        self.snap_markers['extension'] = ext

    def _init_instruction_overlay(self):
        """Mensagem fixa no topo do canvas para guiar o usu√°rio"""
        from PySide6.QtWidgets import QLabel
        self.instruction_label = QLabel(self)
        self.instruction_label.setStyleSheet("""
            background: rgba(0, 40, 100, 220); 
            color: white; 
            padding: 12px; 
            border: 1px solid #0078d4; 
            border-radius: 6px;
            font-family: Arial;
            font-size: 11px;
        """)
        self.instruction_label.move(20, 20)
        self.instruction_label.hide()

    def clear_pillars(self):
        """Remove visualiza√ß√µes de pilares existentes para evitar fantasmas"""
        if 'pillar' in self.item_groups and self.item_groups['pillar']:
            for item in self.item_groups['pillar']:
                try: self.scene.removeItem(item)
                except: pass
        
        # Limpar ids do mapa interativo e links persistentes
        ids_to_remove = []
        for pid, item in self.interactive_items.items():
            if item in self.item_groups.get('pillar', []):
                ids_to_remove.append(pid)
        
        for pid in ids_to_remove:
            if pid in self.interactive_items: del self.interactive_items[pid]
            if pid in self.persistent_links: del self.persistent_links[pid]
            
        # 3. Limpar a lista de grupo
        self.item_groups['pillar'] = []
        
        # 4. Regenerar Snaps a partir da base (Remove fantasmas de pilares)
        self.snap_points = self.base_snap_points.copy()
        self.snap_segments = self.base_snap_segments.copy()
        # Nota: Se houver outros itens ativos (lajes/vigas), eles ser√£o regerados pelo draw()
        
        self.scene.update()

    def draw_interactive_pillars(self, pillars_data: list):
        """Desenha pilares processados com suporte a heatmap de confian√ßa/erro"""
        self.clear_pillars()
        for p_data in pillars_data:
            points = p_data.get('points') 
            if points:
                item = PillarGraphicsItem(p_data['id'], points, p_data.get('name'))
                item.setZValue(10) # Pilares sempre acima
                item.proxy.clicked.connect(self.on_pillar_clicked)
                
                # Aplicar Status Inicial (Apenas Validado vs Default)
                if p_data.get('is_validated'):
                    item.set_validated(True)
                
                self.scene.addItem(item)
                self.interactive_items[p_data['id']] = item
                self.item_groups['pillar'].append(item) # Control Group

    def update_pillar_visual_status(self, p_id, status, confidence=1.0):
        """Atualiza a cor de um pilar espec√≠fico em tempo real"""
        if p_id in self.interactive_items:
            try:
                self.interactive_items[p_id].set_visual_status(status, confidence)
            except RuntimeError:
                pass # Item j√° deletado

    def clear_slabs(self):
        """Remove visualiza√ß√µes de lajes existentes para evitar fantasmas"""
        # 1. Remover itens da cena
        if 'slab' in self.item_groups and self.item_groups['slab']:
            for item in self.item_groups['slab']:
                try:
                    if item.scene():
                        self.scene.removeItem(item)
                except RuntimeError:
                    pass # Item j√° deletado C++
        
        # 2. Limpar refer√™ncias no mapa interativo e links persistentes
        ids_to_remove = []
        for pid, item in self.interactive_items.items():
            if item in self.item_groups.get('slab', []):
                ids_to_remove.append(pid)
        
        for pid in ids_to_remove:
            if pid in self.interactive_items: del self.interactive_items[pid]
            if pid in self.persistent_links: del self.persistent_links[pid]
            
        # 3. Limpar a lista de grupo
        self.item_groups['slab'] = []
        
        # 4. Regenerar Snaps a partir da base (Remove fantasmas de lajes)
        self.snap_points = self.base_snap_points.copy()
        self.snap_segments = self.base_snap_segments.copy()
        
        # 5. Force Scene Update (Critical for Ghost removal)
        self.scene.update()

    def draw_slabs(self, slabs_data: list):
        """Desenha lajes apenas via seus v√≠nculos de contorno (Unifica√ß√£o de visual)"""
        # FIX: Limpar lajes anteriores antes de desenhar as novas
        self.clear_slabs()
        
        for s_data in slabs_data:
            # AJUSTE: O SlabGraphicsItem (Preenchimento Branco) agora √© gerado 
            # DENTRO do draw_item_links se houver um v√≠nculo de 'contour'.
            # Isso garante que se o v√≠nculo sumir, a √°rea branca suma tamb√©m.
            
            # Registrar a laje para permitir busca/isolamento b√°sico mesmo sem contorno (ainda)
            # Mas o item real 'interativo' ser√° o contorno criado no draw_item_links.
            self.draw_item_links(s_data, destination='slab', clear=False)
            
        self.scene.update()
            
        self.scene.update()

    def clear_beams(self):
        """Remove visualiza√ß√µes de vigas existentes (labels e links)"""
        if 'beam' in self.item_groups and self.item_groups['beam']:
            for item in self.item_groups['beam']:
                try: self.scene.removeItem(item)
                except: pass
        
        # Limpar Destaques Tempor√°rios de Foco
        for item in getattr(self, 'beam_visuals', []):
            try: self.scene.removeItem(item)
            except: pass
        self.beam_visuals = []

        ids_to_remove = []
        for pid, item in self.interactive_items.items():
            if item in self.item_groups.get('beam', []):
                ids_to_remove.append(pid)
        for pid in ids_to_remove:
            if pid in self.interactive_items: del self.interactive_items[pid]
            if pid in self.persistent_links: del self.persistent_links[pid]
            
        self.item_groups['beam'] = []
        self.scene.update()

    def draw_beams(self, beams_data: list):
        """Desenha labels de identifica√ß√£o para todas as vigas e seus v√≠nculos de segmento"""
        self.clear_beams()
        for b_data in beams_data:
            pos = b_data.get('pos')
            if pos:
                text = b_data.get('name', 'V?')
                item = QGraphicsSimpleTextItem(text)
                
                # Estilo: Destaque solicitado (Magenta/Bold)
                font = QFont("Inter", 12, QFont.Bold)
                item.setFont(font)
                item.setBrush(QBrush(QColor(255, 0, 255))) 
                
                # Centralizar levemente sobre o ponto
                item.setPos(pos[0], pos[1])
                item.setZValue(15) # Acima de tudo
                item.setFlag(QGraphicsItem.ItemIgnoresTransformations)
                
                # Tooltip detalhado
                item.setToolTip(f"Viga: {text}\nID: {b_data.get('id_item', '??')}")

                self.scene.addItem(item)
                
                # Registrar no cache de grupo
                if 'id' in b_data:
                    self.interactive_items[b_data['id']] = item
                    self.item_groups['beam'].append(item)
                
                # AJUSTE 2: Desenhar v√≠nculos de segmentos para a vis√£o global
                self.draw_item_links(b_data, destination='beam', clear=False)

    def draw_focus_beams(self, beams_visual_data: list):
        """Desenha vigas APENAS para o foco atual (pilar selecionado)"""
        self.clear_beams()
        # Suporte sutil para todos os apoios
        for b_data in beams_visual_data:
            pen = QPen(QColor(100, 100, 100, 100), 1, Qt.DashLine)
            pen.setCosmetic(True)
            line = self.scene.addLine(b_data['start'][0], b_data['start'][1], 
                               b_data['end'][0], b_data['end'][1], pen)
            self.beam_visuals.append(line)


    def highlight_multiple_links(self, links, color=None, apply_zoom=True):
        """Destaca m√∫ltiplos v√≠nculos simultaneamente e aplica zoom no conjunto"""
        if not links: return []
        
        self.clear_beams()
        base_color = color if color else QColor(255, 0, 0)
        pen = QPen(base_color, 4) 
        pen.setCosmetic(True)
        
        items_created = []

        from PySide6.QtGui import QPainterPath
        
        for link in links:
            item = None
            l_type = link.get('type')
            
            if l_type == 'text' and 'pos' in link:
                item = self.scene.addSimpleText(link['text'])
                item.setPos(link['pos'][0], link['pos'][1])
                item.setBrush(QBrush(base_color))
                item.setZValue(101)
                item.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
            elif (l_type == 'line' or l_type == 'poly' or l_type == 'geometry') and 'points' in link:
                pts = link['points']
                if len(pts) >= 2:
                    path = QPainterPath()
                    path.moveTo(pts[0][0], pts[0][1])
                    for p in pts[1:]: path.lineTo(p[0], p[1])
                    if l_type == 'poly' or (len(pts) > 2 and pts[0] == pts[-1]):
                        path.closeSubpath()
                    
                    item = self.scene.addPath(path, pen)
                    item.setZValue(100)
            elif l_type == 'circle' and 'pos' in link and 'radius' in link:
                r = link['radius']
                px, py = link['pos']
                item = self.scene.addEllipse(px-r, py-r, r*2, r*2, pen)
                item.setZValue(100)
            
            if item:
                self.beam_visuals.append(item)
                items_created.append(item)

        if items_created and apply_zoom:
            rect = items_created[0].sceneBoundingRect()
            for it in items_created[1:]:
                rect = rect.united(it.sceneBoundingRect())
                
            margin = 400
            self.fitInView(rect.adjusted(-margin, -margin, margin, margin), Qt.KeepAspectRatio)
            self.centerOn(rect.center())
            
        return items_created

    def highlight_link(self, link, color=None, apply_zoom=True):
        """Wrapper para √∫nico link"""
        return self.highlight_multiple_links([link], color, apply_zoom)


    def draw_item_links(self, target, destination='focus', clear=True):
        """
        Desenha os v√≠nculos de um item.
        destination: 'focus' (beam_visuals), 'beam' (item_groups['beam']), 'slab' (item_groups['slab'])
        """
        if not target: return
        item_id = target.get('id')
        
        if clear: self.clear_beams() 
        
        # Se for para um grupo persistente, primeiro limpa o anterior desse item
        # AJUSTE: S√≥ limpar se clear=True ou se n√£o for slab destination (para evitar flickering em redraw full)
        if destination != 'focus' and item_id and clear:
            self.clear_item_persistent_links(item_id)
        
        from PySide6.QtWidgets import QGraphicsSimpleTextItem
        from PySide6.QtGui import QPainterPath
        
        # ... (Colors logic remains same) ...
        base_color = QColor(255, 0, 0) # Default Red
        type_str = target.get('type', '').lower()
        if target.get('is_validated') and not 'laje' in type_str:
            base_color = QColor(76, 175, 80) # Verde para Validados (Exceto Laje)
        elif 'laje' in type_str:
            base_color = QColor(0, 50, 150) # Azul Escuro (Marco)
        elif 'pilar' in type_str:
            base_color = QColor(0, 180, 0) # Verde Escuro
        else:
             base_color = QColor(139, 69, 19) # Viga = Marrom
            
        pen = QPen(base_color, 2)
        pen.setCosmetic(True)
        
        links = target.get('links', {})
        for field_id, slots in links.items():
            # FILTRO: Para vis√µes globais (slab/beam), focar apenas no contorno/geometria principal
            # Evita polui√ß√£o visual de textos de dimens√£o/nome em todos os itens
            if destination == 'slab':
                # print(f"[DEBUG CANVAS] Draw Slab Link Field: {field_id} | Target: {target.get('name')}")
                if field_id not in ['laje_outline_segs', 'laje_islands']:
                    continue
            if destination == 'beam' and field_id != 'viga_segs':
                continue
                
            # Iterate properly to log keys
            if isinstance(slots, dict):
                slots_to_process = list(slots.items())
            else:
                slots_to_process = [('value', slots)]
            
            for slot_name, link_list in slots_to_process:
                # Custom Pen for specific slab slots to highlight them
                local_pen = pen
                if destination == 'slab':
                     if 'acrescimo' in slot_name.lower():
                          local_pen = QPen(QColor(255, 165, 0), 3) # Laranja para Acr√©scimos
                          local_pen.setCosmetic(True)
                     elif 'island' in slot_name.lower() or 'buraco' in slot_name.lower():
                          local_pen = QPen(QColor(255, 0, 255), 2) # Magenta para Ilhas
                          local_pen.setCosmetic(True)

                # if destination == 'slab':
                #      print(f"[DEBUG CANVAS] Slab {target.get('name')} | Field: {field_id} | Slot: {slot_name} | Links: {len(link_list)}")
                for link in link_list:
                    l_type = link.get('type')
                    if not l_type:
                        # print(f"[DEBUG Canvas] Skipping link in {slot_name}: No Type")
                        continue
                    
                    item = None
                    # Texto
                    if l_type == 'text' and link.get('pos'):
                        item = self.scene.addSimpleText(link.get('text', ''))
                        pos = link['pos']
                        item.setPos(pos[0], pos[1])
                        item.setBrush(QBrush(base_color))
                        item.setZValue(105)
                        item.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
                    # Geometria (Linhas/Polys)
                    elif (l_type in ['line', 'poly', 'geometry']):
                        if not link.get('points'):
                             # print(f"[DEBUG Canvas] Skipping link in {slot_name}: Type {l_type} has NO POINTS")
                             continue
                        pts = link['points']
                        # Validar pontos (ignorar Z se vier 3D)
                        if pts and len(pts) > 0:
                            if len(pts[0]) > 2:
                                pts = [(p[0], p[1]) for p in pts]
                            
                            # [NOVO] Registrar Snaps para geometria de v√≠nculo (Contornos, Linhas, etc)
                            if destination != 'focus': 
                                for i, pt in enumerate(pts):
                                    self._add_snap_point(pt, 'endpoint')
                                    if i < len(pts) - 1:
                                        p_next = pts[i+1]
                                        self.snap_segments.append((pt, p_next))
                                        self._add_snap_point(((pt[0]+p_next[0])/2, (pt[1]+p_next[1])/2), 'midpoint')
                                
                                if l_type == 'poly' and pts[0] != pts[-1]:
                                    self.snap_segments.append((pts[-1], pts[0]))
                                    self._add_snap_point(((pts[-1][0]+pts[0][0])/2, (pts[-1][1]+pts[0][1])/2), 'midpoint')

                            # --- AJUSTE: Laje usa SlabGraphicsItem para unir Borda + Fundo Branco ---
                            is_closed = l_type == 'poly' or (len(pts) > 2 and pts[0] == pts[-1])
                            
                            # Apenas o CONTORNO vira SlabGraphicsItem. 
                            # Acr√©scimos e Ilhas devem ser desenhados como PATHS para respeitar cores customizadas
                            is_main_contour = slot_name == 'contour'
                            
                            if destination == 'slab' and is_closed and is_main_contour:
                                # print(f"[DEBUG CANVAS] Creating SlabGraphicsItem for {target.get('name')}")
                                item = SlabGraphicsItem(pts, label=None)
                                item.set_validated(target.get('is_validated', False))
                                # Se n√£o estiver validado, for√ßamos o pen de destaque azul (ou o especificado no loop)
                                if not target.get('is_validated'):
                                    item.setPen(local_pen)
                                item.setZValue(100) # Fundo (atr√°s dos segmentos)
                                item.setToolTip(f"Slab: {target.get('name')} ({slot_name})")
                                self.scene.addItem(item)
                                # print(f"[DEBUG CANVAS] Added SlabGraphicsItem for {target.get('name')} ({slot_name})")
                            else:
                                path = QPainterPath()
                                path.moveTo(pts[0][0], pts[0][1])
                                for p in pts[1:]: path.lineTo(p[0], p[1])
                                if is_closed: path.closeSubpath()
                                item = self.scene.addPath(path, local_pen)
                                item.setZValue(105) # Segmentos (na frente do fundo)
                                # print(f"[DEBUG CANVAS] Added Path for {target.get('name')} ({slot_name}) | Type: {l_type}")

                    # C√≠rculos
                    elif l_type == 'circle' and link.get('pos') and link.get('radius') is not None:
                        r = link['radius']
                        px, py = link['pos']
                        item = self.scene.addEllipse(px-r, py-r, r*2, r*2, pen)
                        item.setZValue(104)
                        # print(f"[DEBUG CANVAS] Added Circle for {target.get('name')} ({slot_name})")

                    if item:
                        if destination == 'focus':
                            self.beam_visuals.append(item)
                        else:
                            # Adicionar ao grupo persistente
                            self.item_groups[destination].append(item)
                            
                            # [NOVO] Registrar como item interativo para isolamento se for o contorno
                            if destination == 'slab' and item_id and isinstance(item, SlabGraphicsItem):
                                self.interactive_items[item_id] = item
                                
                            # Registrar para limpeza individual posterior
                            if item_id:
                                if item_id not in self.persistent_links: self.persistent_links[item_id] = []
                                self.persistent_links[item_id].append(item)

    def highlight_element_by_name(self, name, data_list=[], apply_zoom=True):
        """Destaca itens vinculados em VERMELHO. Se for Pilar, destaca formato."""
        from PySide6.QtWidgets import QGraphicsSimpleTextItem
        from PySide6.QtGui import QPainterPath
        
        self.clear_beams() 
        
        target = next((d for d in data_list if d.get('name') == name), None)
        
        # Cor Base
        base_color = QColor(255, 0, 0) # Default Red
        if target:
            t_type = target.get('type', '').lower()
            if 'laje' in t_type: base_color = QColor(0, 50, 150)
            elif 'pilar' in t_type: base_color = QColor(0, 180, 0)
            else: base_color = QColor(139, 69, 19) # Viga = Marrom
            
        pen = QPen(base_color, 3) 
        pen.setCosmetic(True)
        items_to_focus = []

        # Flag para saber se temos geometria vinculada (para n√£o desenhar a bruta duplicada)
        has_geo_links = False

        if target:
            # 1. Desenhar V√≠nculos (Links) - Prioridade M√°xima
            links = target.get('links', {})
            for field_id, slots in links.items():
                slots_to_process = slots.values() if isinstance(slots, dict) else [slots]
                
                for link_list in slots_to_process:
                    for link in link_list:
                        l_type = link.get('type')
                        
                        if l_type == 'text':
                            t_item = self.scene.addSimpleText(link['text'])
                            t_item.setPos(link.get('pos', [0, 0])[0], link.get('pos', [0, 0])[1])
                            t_item.setBrush(QBrush(base_color))
                            t_item.setZValue(101)
                            t_item.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
                            self.beam_visuals.append(t_item)
                            items_to_focus.append(t_item)
                        # Process both lines and generic geometry links
                        elif l_type in ['line', 'poly', 'geometry', 'circle'] and ('points' in link or 'radius' in link):
                            has_geo_links = True
                            
                            if l_type == 'circle' and 'radius' in link:
                                r = link['radius']
                                px, py = link['pos']
                                item = self.scene.addEllipse(px-r, py-r, r*2, r*2, pen)
                            else:
                                pts = link['points']
                                line_pen = pen # Uses same style
                                if l_type == 'line': # Line is 2 points
                                     line = self.scene.addLine(pts[0][0], pts[0][1], pts[1][0], pts[1][1], line_pen)
                                     line.setZValue(100)
                                     self.beam_visuals.append(line)
                                     items_to_focus.append(line)
                                else: # Poly/Geometry
                                     path = QPainterPath()
                                     path.moveTo(pts[0][0], pts[0][1])
                                     for p in pts[1:]: path.lineTo(p[0], p[1])
                                     if l_type == 'poly': path.closeSubpath()
                                     item = self.scene.addPath(path, line_pen)
                                     item.setZValue(100)
                                     self.beam_visuals.append(item)
                                     items_to_focus.append(item)

            # 2. Desenhar Geometria Item (Desativado conforme solicita√ß√£o do usu√°rio)
            # Apenas o que est√° explicitamente em 'links' deve ser desenhado.
            # Se o usu√°rio quiser ver a geometria padr√£o, esta deve ser adicionada aos links
            # ou o comportamento deve ser revertido.
            if not has_geo_links:
                pass 
                # C√≥digo de fallback (target['points'], target['geometry']) REMOVIDO
                # para garantir que "destaque apenas o que est√° vinculado".

        # 3. Fallback: S√≥ busca texto solto no DXF se N√ÉO ACHOU o target
        # Mantendo apenas este fallback caso o item nem exista na lista de dados,
        # mas se o item existe e n√£o tem links, n√£o desenha nada.
        if not target:
            for ent in self.dxf_entities:
                if ent.get('text') == name:
                    t_item = self.scene.addSimpleText(ent['text'])
                    t_item.setPos(ent['pos'][0], ent['pos'][1])
                    t_item.setBrush(QBrush(base_color))
                    t_item.setZValue(101)
                    t_item.setFlag(QGraphicsItem.ItemIgnoresTransformations)
                    self.beam_visuals.append(t_item)
                    items_to_focus.append(t_item)
                    t_item.setBrush(QBrush(base_color))
                    t_item.setZValue(101)
                    t_item.setFlag(QGraphicsItem.ItemIgnoresTransformations)
                    self.beam_visuals.append(t_item)
                    items_to_focus.append(t_item)

        if items_to_focus and apply_zoom:
            rect = items_to_focus[0].sceneBoundingRect()
            for item in items_to_focus[1:]:
                rect = rect.united(item.sceneBoundingRect())
            
            # Zoom suave no conjunto de itens destacados (400px agrad√°vel)
            margin = 400
            self.fitInView(rect.adjusted(-margin, -margin, margin, margin), Qt.KeepAspectRatio)
            self.centerOn(rect.center())

    def highlight_item_yellow(self, item_id):
        """Alterna a cor do item selecionado para Amarelo (Foco) e reverte o anterior"""
        # 1. Reverter anterior
        if self.current_yellow_item_id and self.current_yellow_item_id != item_id:
            old_item = self.interactive_items.get(self.current_yellow_item_id)
            if old_item:
                if hasattr(old_item, 'set_temp_highlight'):
                    old_item.set_temp_highlight(None)
                elif hasattr(old_item, '_orig_brush'):
                    old_item.setBrush(old_item._orig_brush)
                    del old_item._orig_brush
            self.current_yellow_item_id = None

        # 2. Aplicar novo
        if item_id in self.interactive_items:
            item = self.interactive_items[item_id]
            if hasattr(item, 'set_temp_highlight'):
                yellow_pen = QPen(QColor(255, 255, 0), 4) # Yellow Thick
                yellow_pen.setCosmetic(True)
                item.set_temp_highlight(yellow_pen)
                self.current_yellow_item_id = item_id
                item.update()
            elif isinstance(item, QGraphicsSimpleTextItem):
                if not hasattr(item, '_orig_brush'):
                    item._orig_brush = item.brush()
                item.setBrush(QBrush(QColor(255, 255, 0)))
                self.current_yellow_item_id = item_id
        
    def focus_on_item(self, item_id: int, apply_zoom=True):
        """Destaque um pilar interativo enviando ID"""
        if item_id in self.interactive_items:
            item = self.interactive_items[item_id]
            
            # Zoom suave no pilar (400px agrad√°vel)
            if apply_zoom:
                self.fitInView(item.boundingRect().marginsAdded(QMarginsF(400, 400, 400, 400)), Qt.KeepAspectRatio)

    def update_item_visuals(self, item_data):
        """Atualiza a geometria principal do item no canvas (fantasma fix)"""
        iid = item_data.get('id')
        if not iid or iid not in self.interactive_items: return
        
        item = self.interactive_items[iid]
        points = item_data.get('points')
        if not points: return
        
        from PySide6.QtGui import QPolygonF
        from PySide6.QtCore import QPointF
        
        poly = QPolygonF()
        for x, y in points: poly.append(QPointF(x, y))
        
        # Se for um item de pol√≠gono (Pillar ou Slab)
        if hasattr(item, 'setPolygon'):
            item.setPolygon(poly)
            # Reposicionar texto
            if hasattr(item, 'text_item'):
                 center = poly.boundingRect().center()
                 item.text_item.setPos(center.x(), center.y())
        
        self.scene.update()

    def clear_item_persistent_links(self, item_id):
        """Remove links visuais persistentes de um item espec√≠fico para evitar 'fantasmas' ao atualizar."""
        print(f"[DEBUG_CANVAS] clear_item_persistent_links para {item_id}")
        if item_id in self.persistent_links:
            items_to_remove = self.persistent_links[item_id]
            print(f"[DEBUG_CANVAS] Removendo {len(items_to_remove)} itens do item {item_id}")
            for item in items_to_remove:
                # Remove da cena
                try:
                    if item.scene():
                        self.scene.removeItem(item)
                except Exception as e:
                    print(f"[DEBUG_CANVAS] Erro ao remover item: {e}")
                
                # Remove dos grupos de controle
                for group_key in ['beam', 'link', 'pillar', 'slab']:
                    if group_key in self.item_groups and item in self.item_groups[group_key]:
                        self.item_groups[group_key].remove(item)
                        
            # Limpa e remove a chave para n√£o acumular
            del self.persistent_links[item_id]
            self.scene.update()

    def focus_on_beam_geometry(self, beam_data, apply_zoom=True, clear=True):
        """Foca na geometria completa de uma viga (linhas + textos)"""
        if clear: self.clear_beams() # Limpa destaques anteriores
        items_to_focus = []
        geo = beam_data.get('geometry', {})
        
        # 1. Determinar quais linhas desenhar
        # Prioridade: V√≠nculos em 'viga_segs' (Side A, B, Bottom)
        # Fallback: Geometria bruta do tracer
        line_sources = []
        line_sources = []
        links = beam_data.get('links', {})
        
        # Iterar recursivamente por todos os campos de links para encontrar linhas
        # Ex: links -> 'viga_segs' (dict) -> 'slot_A' (list) -> link
        # Ex: links -> '_comprimento_total' (dict) -> 'adjustment' (list) -> link
        
        def collect_lines(container):
            if isinstance(container, dict):
                for v in container.values(): collect_lines(v)
            elif isinstance(container, list):
                for lk in container:
                     if isinstance(lk, dict) and 'points' in lk and lk.get('type') == 'line':
                         line_sources.append(lk['points'])

        if links:
            collect_lines(links)
        
        # Se n√£o houver v√≠nculos manuais ou auto-populados nos slots, usa a geometria bruta
        # Fallback gen√©rico se nada foi encontrado em links
        if not line_sources:
            line_sources = geo.get('lines', [])

        # 2. Adicionar destaques tempor√°rios em MARROM (solicitado: ajuste)
        brown_color = QColor(139, 69, 19) 
        pen = QPen(brown_color, 4)
        pen.setCosmetic(True)
        
        # Desenhar linhas filtradas (v√≠nculos ativos ou fallback)
        for points in line_sources:
             if len(points) >= 2:
                 path = QPainterPath()
                 path.moveTo(points[0][0], points[0][1])
                 for p in points[1:]: path.lineTo(p[0], p[1])
                 item = self.scene.addPath(path, pen)
                 item.setZValue(100)
                 self.beam_visuals.append(item)
                 items_to_focus.append(item)
        
        # Desenhar textos da viga
        for txt in geo.get('texts', []):
             found_text = txt.get('text', 'V?')
             t_item = self.scene.addSimpleText(found_text)
             t_item.setPos(txt['pos'][0], txt['pos'][1])
             t_item.setBrush(QBrush(brown_color))
             t_item.setZValue(101)
             t_item.setFlag(QGraphicsItem.ItemIgnoresTransformations)
             self.beam_visuals.append(t_item)
             items_to_focus.append(t_item)

        if items_to_focus and apply_zoom:
            # Tentar encontrar o texto do nome da viga para focar nele (Zoom Close-up)
            target_name = str(beam_data.get('name', '')).strip().upper()
            name_item = None
            
            # Procurar item de texto que corresponda ao nome da viga
            for item in items_to_focus:
                if isinstance(item, QGraphicsSimpleTextItem) and item.text().strip().upper() == target_name:
                    name_item = item
                    break
            
            if name_item:
                # Se achou o nome, foca nele com um zoom fixo/agrad√°vel
                self.centerOn(name_item.sceneBoundingRect().center())
                # Define um scale fixo para ver o texto bem de perto
                current_scale = self.transform().m11()
                if current_scale < 2.0: # Se estiver muito longe
                    self.resetTransform()
                    self.scale(3.0, -3.0) # Zoom level 3x, Y-up correction
                else:
                    # Manter escala atual mas centralizar
                    pass
            else:
                # Fallback: Enquadrar toda a geometria (comportamento antigo)
                rect = items_to_focus[0].sceneBoundingRect()
                for item in items_to_focus[1:]:
                    rect = rect.united(item.sceneBoundingRect())
                
                margin = 400
                self.fitInView(rect.adjusted(-margin, -margin, margin, margin), Qt.KeepAspectRatio)
                self.centerOn(rect.center())
                
        # Caso n√£o tenha geometria complexa, tenta focar no label interativo
        else:
             self.focus_on_item(beam_data['id'], apply_zoom)

    def highlight_link(self, link_data, color=None):
        """Destaca geometria espec√≠fica vinculada a um evento de treino e foca nela."""
        self.clear_beams() # Limpa limpezas anteriores
        
        items_to_focus = []
        l_type = link_data.get('type')
        
        # Cor customizada ou ciano brilhante padr√£o
        target_color = color if color and isinstance(color, QColor) else QColor(0, 255, 255)
        
        pen = QPen(target_color, 2)
        pen.setCosmetic(True)
        
        if l_type == 'text' and 'pos' in link_data:
            item = self.scene.addSimpleText(link_data.get('text', '?'))
            item.setPos(link_data['pos'][0], link_data['pos'][1])
            item.setBrush(QBrush(target_color))
            item.setZValue(205)
            # Ignora transforma√ß√µes para manter texto leg√≠vel
            from PySide6.QtWidgets import QGraphicsSimpleTextItem
            item.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
            self.beam_visuals.append(item)
            items_to_focus.append(item)
            
        elif l_type == 'point' and 'pos' in link_data:
             r = 5.0
             px, py = link_data['pos']
             item = self.scene.addEllipse(px-r, py-r, r*2, r*2, pen)
             item.setZValue(205)
             self.beam_visuals.append(item)
             items_to_focus.append(item)
             
        elif l_type in ('line', 'poly', 'geometry') and 'points' in link_data:
             pts = link_data['points']
             if len(pts) >= 2:
                 path = QPainterPath()
                 path.moveTo(pts[0][0], pts[0][1])
                 for p in pts[1:]: path.lineTo(p[0], p[1])
                 if l_type == 'poly' or l_type == 'geometry': path.closeSubpath()
                 
                 item = self.scene.addPath(path, pen)
                 item.setZValue(205)
                 self.beam_visuals.append(item)
                 items_to_focus.append(item)
        
        if items_to_focus:
            rect = items_to_focus[0].sceneBoundingRect()
            for i in items_to_focus[1:]: rect = rect.united(i.sceneBoundingRect())
            
            # Zoom com margem de 300px
            margin = 300
            self.fitInView(rect.adjusted(-margin, -margin, margin, margin), Qt.KeepAspectRatio)
            self.centerOn(rect.center())
            
    def on_pillar_clicked(self, p_id):
        # Deselecionar outros
        for item_id, item in self.interactive_items.items():
            if item_id != p_id:
                item.setSelected(False)
            else:
                item.setSelected(True)
        self.pillar_selected.emit(p_id)

    def update_pillar_status(self, p_id: int, status: str):
        """Atualiza o estado visual de um pilar."""
        if p_id in self.interactive_items:
            item = self.interactive_items[p_id]
            if hasattr(item, 'set_validated'):
                item.set_validated(status == 'validated')

    def update_slab_status(self, s_id: int, status: str):
        """Atualiza o estado visual de uma laje."""
        if s_id in self.interactive_items:
            try:
                item = self.interactive_items[s_id]
                if hasattr(item, 'set_validated'):
                    item.set_validated(status == 'validated')
            except RuntimeError:
                pass

    def update_beam_status(self, b_id: int, status: str):
        """Atualiza o estado visual de uma viga (label)."""
        if b_id in self.interactive_items:
            try:
                item = self.interactive_items[b_id]
                if status == 'validated':
                    item.setBrush(QBrush(QColor(76, 175, 80))) # Green
                else:
                    item.setBrush(QBrush(QColor(255, 0, 255))) # Default Magenta
            except RuntimeError:
                pass

    def set_picking_mode(self, mode, field_id=""):
        self.setFocus()
        self.picking_mode = mode
        self.pick_start = None
        if mode: self.edit_mode = None # Cancela modo de edi√ß√£o se entrar em picking
        
        # Reset Poly
        self.pick_poly_points = []
        if self.poly_visual:
            self.scene.removeItem(self.poly_visual)
            self.poly_visual = None

        if mode:
            self.setDragMode(QGraphicsView.NoDrag)
            self.setCursor(Qt.CrossCursor)
            
            if mode == 'text':
                msg = "CLIQUE NO TEXTO EXATO"
            elif mode == 'poly':
                msg = "CLIQUE PONTO-A-PONTO. [ENTER] PARA FINALIZAR."
            else:
                msg = "M√âTODO 2-CLIQUES (USE SNAP)"

            self.instruction_label.setText(f"<b>Modo Curadoria Ativo</b><br>Campo: {field_id}<br><small>{msg}</small>")
            self.instruction_label.adjustSize()
            self.instruction_label.show()
        elif not self.edit_mode:
            self.setDragMode(QGraphicsView.ScrollHandDrag)
            self.setCursor(Qt.ArrowCursor)
            self.instruction_label.hide()
            # Hide all markers
            for m in self.snap_markers.values(): m.hide()

    def get_snap(self, pos, threshold=1.2):
        """Retorna o dado de snap mais pr√≥ximo {pos, type} ou None"""
        best_snap = None
        min_dist = threshold
        
        # 1. Checa pontos fixos (endpoint, center, midpoint, intersection, node)
        priority_map = {
            'intersection': 0, 'apparent_intersection': 0,
            'endpoint': 1, 'center': 1, 'quadrant': 1, 'node': 1,
            'midpoint': 2,
            'extension': 3,
            'perpendicular': 4,
            'nearest': 5
        }
        
        for s in self.snap_points:
            pt = s['pos']
            dist = ((pt[0]-pos.x())**2 + (pt[1]-pos.y())**2)**0.5
            
            if dist < min_dist:
                if best_snap and abs(dist - min_dist) < 2.0:
                    curr_prio = priority_map.get(s['type'], 99)
                    best_prio = priority_map.get(best_snap['type'], 99)
                    if curr_prio < best_prio:
                        best_snap = s
                        min_dist = dist
                else:
                    min_dist = dist
                    best_snap = s

        # 2. Snaps Din√¢micos (Nearest, Perpendicular, Apparent Intersection, Extension)
        if best_snap and min_dist < 10: # Se j√° achamos um ponto fixo muito perto, ignora din√¢mico
            return best_snap

        # Encontrar segmentos pr√≥ximos
        near_segments = []
        for s, e in self.snap_segments:
            px, py = pos.x(), pos.y()
            sx, sy = s[0], s[1]
            ex, ey = e[0], e[1]
            dx, dy = ex - sx, ey - sy
            mag_sq = dx*dx + dy*dy
            if mag_sq == 0: continue
            
            t = ((px - sx) * dx + (py - sy) * dy) / mag_sq
            t_clamped = max(0, min(1, t))
            proj = QPointF(sx + t_clamped * dx, sy + t_clamped * dy)
            dist = ((proj.x()-px)**2 + (proj.y()-py)**2)**0.5
            
            if dist < threshold:
                near_segments.append(((s, e), dist, t, proj))

        # Ordenar por dist√¢ncia
        near_segments.sort(key=lambda x: x[1])

        # Apparent Intersection (entre os 2 mais pr√≥ximos)
        if len(near_segments) >= 2:
            s1, e1 = near_segments[0][0]
            s2, e2 = near_segments[1][0]
            pt = self._line_intersection(s1, e1, s2, e2, segment_only=False)
            if pt:
                dist_inter = ((pt[0]-pos.x())**2 + (pt[1]-pos.y())**2)**0.5
                if dist_inter < min_dist:
                    best_snap = {'pos': pt, 'type': 'intersection'} # Usa marker de intersection
                    min_dist = dist_inter

        # Perpendicular e Extension
        for seg_data in near_segments:
            (s, e), dist, t, proj = seg_data
            if dist < min_dist:
                # Extension: se t < 0 ou t > 1
                if t < 0 or t > 1:
                     # Se estivermos em modo de desenho, mostra extens√£o
                     if self.edit_mode in ('line', 'dim'):
                         best_snap = {'pos': (proj.x(), proj.y()), 'type': 'extension'}
                         min_dist = dist
                elif self.pick_start and 0 <= t <= 1:
                    if self.edit_mode in ('line', 'dim'):
                        best_snap = {'pos': (proj.x(), proj.y()), 'type': 'perpendicular'}
                        min_dist = dist
                else:
                    best_snap = {'pos': (proj.x(), proj.y()), 'type': 'nearest'}
                    min_dist = dist

        return best_snap

    def mousePressEvent(self, event):
        self.setFocus()
        # 0. Right Click - Deselect Box or Cancel
        if event.button() == Qt.RightButton:
            # Se ja estiver fazendo algo (ex: line), cancela.
            if self.edit_mode != 'select':
                 self.set_edit_mode('select')
                 event.accept()
                 return

            if self.edit_mode == 'select':
                # [NOVO] Cancelamento Cruzado: Se estiver fazendo Box Azul (Left), Right Click cancela
                if self.box_start is not None:
                    if self.selection_box: self.scene.removeItem(self.selection_box)
                    self.selection_box = None
                    self.box_start = None
                    print("DEBUG: Selection Box Cancelled by Right Click")
                    event.accept()
                    return

                # Logica Box Deselecao (Vermelho)
                scene_pos = self.mapToScene(event.pos())
                if self.deselect_box_start is None:
                    self.deselect_box_start = scene_pos
                    self.deselect_box = self.scene.addRect(QRectF(scene_pos, scene_pos),
                                                          QPen(QColor(255, 50, 50), 1),
                                                          QBrush(QColor(255, 50, 50, 60)))
                    self.deselect_box.setZValue(2000)
                else:
                     # Finalizar Box Deselecao
                    rect = QRectF(self.deselect_box_start, scene_pos).normalized()
                    path = QPainterPath()
                    path.addRect(rect)
                    items = self.scene.items(path, Qt.IntersectsItemBoundingRect, Qt.DescendingOrder, QTransform())
                    
                    for i in items:
                        if i == self.deselect_box: continue
                        i.setSelected(False)
                        if i in self.selected_items: self.selected_items.remove(i)
                    
                    self._on_selection_changed() # Update visual for removed items
                    if self.deselect_box: self.scene.removeItem(self.deselect_box)
                    self.deselect_box = None
                    self.deselect_box_start = None
                
                event.accept()
                return

        # 1. Handle Pan (Middle Button)
        if event.button() == Qt.MiddleButton:
            self._is_panning = True
            self._last_pan_pos = event.pos()
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
            return

        scene_pos = self.mapToScene(event.pos())
        snap_data = self.get_snap(scene_pos)
        snap_pos = snap_data['pos'] if snap_data else (scene_pos.x(), scene_pos.y())
        
        # 2. Handle Pick Modes
        if self.picking_mode == 'poly':
            # Apply Ortho if active and not the first point
            final_pos = snap_pos
            if self.ortho_mode and self.pick_poly_points:
                start_pt = QPointF(*self.pick_poly_points[-1])
                curr_pt = QPointF(*snap_pos)
                res_pt = self._apply_ortho(start_pt, curr_pt)
                final_pos = (res_pt.x(), res_pt.y())

            self.pick_poly_points.append(final_pos)
            path = QPainterPath()
            if self.pick_poly_points:
                path.moveTo(*self.pick_poly_points[0])
                for p in self.pick_poly_points[1:]: path.lineTo(*p)
            if not self.poly_visual:
                self.poly_visual = self.scene.addPath(path, QPen(QColor(0, 255, 255), 0, Qt.DashLine))
                self.poly_visual.setZValue(205)
            else:
                self.poly_visual.setPath(path)
                self.poly_visual.setPen(QPen(QColor(0, 255, 255), 0, Qt.DashLine))
            return

        # --- MODOS DE EDI√á√ÉO ---
        if self.edit_mode == 'select':
             # [NOVO] Cancelamento Cruzado: Se estiver fazendo Box Vermelho (Right), Left Click cancela
            if self.deselect_box_start is not None:
                if self.deselect_box: self.scene.removeItem(self.deselect_box)
                self.deselect_box = None
                self.deselect_box_start = None
                print("DEBUG: Deselection Box Cancelled by Left Click")
                event.accept()
                return

            # Calculate picking aperture in Scene Units (40 pixels equivalent - more tolerant)
            view_scale = self.transform().m11()
            if view_scale == 0: view_scale = 1 # Avoid div zero
            aperture_px = 5
            aperture_scene = aperture_px / view_scale
            
            p = scene_pos
            rect = QRectF(p.x() - aperture_scene/2, p.y() - aperture_scene/2, aperture_scene, aperture_scene)
            
            print(f"DEBUG click at: {p}, Scale: {view_scale:.4f}, Aperture: {aperture_scene:.2f}")

            # Manual hit test
            items_at_pos = self.scene.items(rect, Qt.IntersectsItemBoundingRect, Qt.DescendingOrder, QTransform())
            
            # Filter for our actionable items
            valid_items = []
            for i in items_at_pos:
                if i == self.selection_box: continue
                if isinstance(i, (DXFLineItem, DXFPathItem, QGraphicsSimpleTextItem, PillarGraphicsItem, SlabGraphicsItem, BeamGraphicsItem)):
                    valid_items.append(i)
                # Helper for standard items if any
                elif isinstance(i, (QGraphicsLineItem, QGraphicsPathItem)) and i.flags() & QGraphicsItem.ItemIsSelectable:
                     valid_items.append(i)

            print(f"DEBUG Valid Items count: {len(valid_items)}")
            if valid_items:
                 print(f"DEBUG First item type found: {type(valid_items[0])}")
            
            item = valid_items[0] if valid_items else None

            if item and not isinstance(item, QGraphicsScene):
                # Clique em objeto
                if event.modifiers() & Qt.ShiftModifier:
                    # Toggle
                    if item.isSelected():
                        item.setSelected(False)
                        if item in self.selected_items: self.selected_items.remove(item)
                    else:
                         item.setSelected(True)
                         if item not in self.selected_items: self.selected_items.append(item)
                else:
                    # Cumulative by default (User Request: "selecoes sejam cumulativas")
                    if not item.isSelected():
                        item.setSelected(True)
                        if item not in self.selected_items:
                            self.selected_items.append(item)
                
                self._on_selection_changed()
            else:
                # Clique em √°rea vazia - Iniciar/Finalizar Box
                if self.box_start is None:
                    self.box_start = scene_pos
                    self.selection_box = self.scene.addRect(QRectF(scene_pos, scene_pos), 
                                                           QPen(QColor(0, 120, 215), 1), 
                                                           QBrush(QColor(0, 120, 215, 60)))
                    self.selection_box.setZValue(2000)
                else:
                    # Finalizar Box
                    rect = QRectF(self.box_start, scene_pos).normalized()
                    path = QPainterPath()
                    path.addRect(rect)
                    items = self.scene.items(path, Qt.IntersectsItemBoundingRect, Qt.DescendingOrder, QTransform())
                    for i in items:
                        if isinstance(i, (DXFLineItem, DXFPathItem, QGraphicsSimpleTextItem, PillarGraphicsItem, SlabGraphicsItem, BeamGraphicsItem)) or (i.flags() & QGraphicsItem.ItemIsSelectable):
                            i.setSelected(True)
                            if i not in self.selected_items: self.selected_items.append(i)
                    
                    self._on_selection_changed()
                    self.scene.removeItem(self.selection_box)
                    self.selection_box = None
                    self.box_start = None
            return

        elif self.edit_mode == 'line':
            blue_pen = QPen(QColor(30, 144, 255), 2)
            if self.pick_start is None:
                self.pick_start = QPointF(*snap_pos)
                self.temp_item = self.scene.addLine(snap_pos[0], snap_pos[1], snap_pos[0], snap_pos[1], blue_pen)
            else:
                final_pt_obj = QPointF(*snap_pos)
                if self.ortho_mode:
                    final_pt_obj = self._apply_ortho(self.pick_start, final_pt_obj)
                
                final_pos = (final_pt_obj.x(), final_pt_obj.y())
                line = self.scene.addLine(self.pick_start.x(), self.pick_start.y(), final_pos[0], final_pos[1], blue_pen)
                line.setZValue(50)
                line.setFlag(QGraphicsItem.ItemIsSelectable)
                self.overlay_items.append(line)
                
                # [NOVO] Registrar para OSNAP e Metadados
                ent_data = {
                    'type': 'line',
                    'points': [(self.pick_start.x(), self.pick_start.y()), final_pos],
                    'color': 5 # Blue fallback
                }
                self._register_new_geometry(line, ent_data)
                
                self.pick_start = final_pt_obj
                if self.temp_item: self.scene.removeItem(self.temp_item)
                self.temp_item = self.scene.addLine(final_pos[0], final_pos[1], final_pos[0], final_pos[1], blue_pen)
            return

        elif self.edit_mode == 'dim':
            # Cota Manual (2 cliques)
            red_pen = QPen(QColor(255, 50, 50), 1)
            if self.pick_start is None:
                self.pick_start = QPointF(*snap_pos)
                self.temp_item = self.scene.addLine(snap_pos[0], snap_pos[1], snap_pos[0], snap_pos[1], red_pen)
            else:
                final_pos = self._apply_ortho(self.pick_start, QPointF(*snap_pos))
                dist = math.sqrt((self.pick_start.x()-final_pos.x())**2 + (self.pick_start.y()-final_pos.y())**2)
                mid = QPointF((self.pick_start.x()+final_pos.x())/2, (self.pick_start.y()+final_pos.y())/2)
                
                line = self.scene.addLine(self.pick_start.x(), self.pick_start.y(), final_pos.x(), final_pos.y(), red_pen)
                txt = self.scene.addSimpleText(f"{dist:.1f}", QFont("Arial", 10))
                txt.setPos(mid.x(), mid.y())
                txt.setBrush(QBrush(QColor(255, 50, 50)))
                txt.setZValue(120); txt.setFlag(QGraphicsItem.ItemIgnoresTransformations)
                
                self.overlay_items.extend([line, txt])
                self.pick_start = None # N√£o cont√≠nuo para cota geralmente
                if self.temp_item: self.scene.removeItem(self.temp_item); self.temp_item = None
            return

        elif self.edit_mode == 'move':
            if not self.is_moving and self.selected_items:
                self.is_moving = True
                self._last_mouse_pos = scene_pos
            else:
                self.is_moving = False
            return
        
        # Manter outros modos (circle, text, etc) funcionando normalmente
        elif self.edit_mode == 'circle':
            blue_pen = QPen(QColor(30, 144, 255), 2)
            if self.pick_start is None:
                self.pick_start = QPointF(*snap_pos)
                self.temp_item = self.scene.addEllipse(snap_pos[0], snap_pos[1], 0, 0, blue_pen)
            else:
                r = math.sqrt((self.pick_start.x()-snap_pos[0])**2 + (self.pick_start.y()-snap_pos[1])**2)
                circle = self.scene.addEllipse(self.pick_start.x()-r, self.pick_start.y()-r, r*2, r*2, blue_pen)
                circle.setZValue(50); circle.setFlag(QGraphicsItem.ItemIsSelectable); self.overlay_items.append(circle)
                
                # [NOVO] Registrar para OSNAP e Metadados
                ent_data = {
                    'type': 'circle',
                    'center': (self.pick_start.x(), self.pick_start.y()),
                    'radius': r,
                    'color': 5
                }
                self._register_new_geometry(circle, ent_data)
                
                self.pick_start = None
                if self.temp_item: self.scene.removeItem(self.temp_item); self.temp_item = None
            return

        super().mousePressEvent(event)
        
        # --- PICKING MODES EXISTENTES ---
        if self.picking_mode:
            self._handle_pick_at(scene_pos)
    def _handle_pick_at(self, scene_pos):
        """L√≥gica comum de processamento de um clique em modo pick"""
        if not self.picking_mode: return

        # Pegar snap se dispon√≠vel
        snap_data = self.get_snap(scene_pos)
        snap_pos = snap_data['pos'] if snap_data else (scene_pos.x(), scene_pos.y())
        
        if self.picking_mode == 'poly':
            self.pick_poly_points.append((snap_pos[0], snap_pos[1]))
            # Visual feedback
            if not self.poly_visual:
                self.poly_visual = QGraphicsPathItem()
                self.poly_visual.setPen(QPen(QColor(0, 255, 255), 2))
                self.scene.addItem(self.poly_visual)
                self.poly_visual.setZValue(200)
            
            path = QPainterPath()
            path.moveTo(*self.pick_poly_points[0])
            for p in self.pick_poly_points[1:]: path.lineTo(*p)
            self.poly_visual.setPath(path)
            return

        if self.picking_mode == 'text':
             best_ent = self._get_best_entity_under_cursor(scene_pos, mode='text')
             if best_ent:
                 self.pick_completed.emit(best_ent)
                 self.set_picking_mode(None)

        elif self.picking_mode == 'geometry':
             best_ent = self._get_best_entity_under_cursor(scene_pos, mode='geometry')
             if best_ent:
                 self.pick_completed.emit(best_ent)
                 self.set_picking_mode(None)

        elif self.picking_mode == 'line':
            if self.pick_start is None:
                self.pick_start = QPointF(*snap_pos)
                self.temp_line = self.scene.addLine(snap_pos[0], snap_pos[1], snap_pos[0], snap_pos[1],
                                               QPen(QColor(0, 255, 255), 2, Qt.DashLine))
                self.temp_text = self.scene.addSimpleText("0.0")
                self.temp_text.setBrush(QBrush(QColor(0, 255, 255)))
                self.temp_text.setZValue(201)
                self.temp_line.setZValue(201)
                self.temp_text.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
            else:
                # Finalizar linha
                final_pt_obj = QPointF(*snap_pos)
                if self.ortho_mode:
                    final_pt_obj = self._apply_ortho(self.pick_start, final_pt_obj)
                
                final_pos = (final_pt_obj.x(), final_pt_obj.y())
                dist = ((self.pick_start.x()-final_pos[0])**2 + (self.pick_start.y()-final_pos[1])**2)**0.5
                
                self.pick_completed.emit({
                    'text': f"{dist:.1f}", 
                    'type': 'line',
                    'points': [(self.pick_start.x(), self.pick_start.y()), final_pos]
                })
                self.set_picking_mode(None)


    def _apply_ortho(self, start, current):
        """Aplica restri√ß√£o ortogonal se ativa"""
        if not self.ortho_mode: return current
        dx = abs(current.x() - start.x())
        dy = abs(current.y() - start.y())
        if dx > dy: return QPointF(current.x(), start.y())
        else: return QPointF(start.x(), current.y())

    def mouseMoveEvent(self, event):
        # 1. Handle Pan
        if self._is_panning and self._last_pan_pos:
            delta = event.pos() - self._last_pan_pos
            self._last_pan_pos = event.pos()
            h_bar = self.horizontalScrollBar()
            v_bar = self.verticalScrollBar()
            h_bar.setValue(h_bar.value() - delta.x())
            v_bar.setValue(v_bar.value() - delta.y())
            event.accept()
            return

        scene_pos = self.mapToScene(event.pos())
        snap_data = self.get_snap(scene_pos)
        snap_pos = snap_data['pos'] if snap_data else (scene_pos.x(), scene_pos.y())
        
        # 2. Box Selection Preview
        if self.edit_mode == 'select' and self.box_start:
            if self.selection_box:
                self.selection_box.setRect(QRectF(self.box_start, scene_pos).normalized())
            return

        # 2b. Deselection Box Preview (Right Click)
        if self.edit_mode == 'select' and self.deselect_box_start:
             if self.deselect_box:
                 self.deselect_box.setRect(QRectF(self.deselect_box_start, scene_pos).normalized())
             return

        # [MOD] Feedback Visual de Entrada Num√©rica perto do Mouse
        if hasattr(self, 'input_label') and self.input_label and self.input_label.isVisible():
            self.input_label.move(event.pos().x() + 20, event.pos().y() + 20)

        # OSNAP Visual
        if self.picking_mode or self.edit_mode:
            # Hide all markers safely
            for m in list(self.snap_markers.values()):
                try:
                    m.hide()
                except RuntimeError:
                    # Object already deleted on C++ side (scene.clear)
                    pass
            if snap_data:
                marker = self.snap_markers.get(snap_data['type'], self.snap_markers.get('endpoint'))
                if marker:
                    marker.setPos(snap_data['pos'][0], snap_data['pos'][1])
                    marker.show()
        
        # 3. Tool Previews
        if self.edit_mode == 'line' and self.pick_start:
            if self.temp_item:
                final_pos = self._apply_ortho(self.pick_start, QPointF(*snap_pos))
                self.temp_item.setLine(QLineF(self.pick_start, final_pos))
                self.temp_item.setPen(QPen(QColor(255, 255, 255), 0))
        
        elif self.edit_mode == 'dim' and self.pick_start:
             if self.temp_item:
                final_pos = self._apply_ortho(self.pick_start, QPointF(*snap_pos))
                self.temp_item.setLine(QLineF(self.pick_start, final_pos))

        elif self.edit_mode == 'move' and self.is_moving:
            delta = scene_pos - self._last_mouse_pos
            for item in self.selected_items:
                item.moveBy(delta.x(), delta.y())
            self._last_mouse_pos = scene_pos

        elif self.edit_mode == 'circle' and self.pick_start:
            if self.temp_item:
                r = math.sqrt((self.pick_start.x()-snap_pos[0])**2 + (self.pick_start.y()-snap_pos[1])**2)
                self.temp_item.setRect(self.pick_start.x()-r, self.pick_start.y()-r, r*2, r*2)

        # Preview Polyline
        if self.picking_mode == 'poly' and self.pick_poly_points:
            from PySide6.QtGui import QPainterPath
            path = QPainterPath()
            path.moveTo(*self.pick_poly_points[0])
            for p in self.pick_poly_points[1:]:
                path.lineTo(*p)
            
            # Apply Ortho for the rubber band line
            final_snap_pos = snap_pos
            if self.ortho_mode and self.pick_poly_points:
                start_pt = QPointF(*self.pick_poly_points[-1])
                curr_pt = QPointF(*snap_pos)
                final_pt = self._apply_ortho(start_pt, curr_pt)
                final_snap_pos = (final_pt.x(), final_pt.y())
            
            path.lineTo(*final_snap_pos) # Rubber band to cursor

            if not self.poly_visual:
                 # Pen width 0 = Cosmetic (always 1 pixel wide regardless of zoom)
                 self.poly_visual = self.scene.addPath(path, QPen(QColor(0, 255, 255), 0, Qt.DashLine))
                 self.poly_visual.setZValue(205)
            else:
                 self.poly_visual.setPath(path)
                 self.poly_visual.setPen(QPen(QColor(0, 255, 255), 0, Qt.DashLine))

        # Preview da Linha
        if self.picking_mode == 'line' and self.pick_start:
            # Apply Ortho if enabled
            target_pt = QPointF(*snap_pos)
            if self.ortho_mode or (event.modifiers() & Qt.ShiftModifier):
                target_pt = self._apply_ortho(self.pick_start, target_pt)
            
            target = (target_pt.x(), target_pt.y())
            self.temp_line.setLine(self.pick_start.x(), self.pick_start.y(), target[0], target[1])
            self.temp_line.setPen(QPen(QColor(255, 255, 0), 0))
            
            dist = ((self.pick_start.x()-target[0])**2 + (self.pick_start.y()-target[1])**2)**0.5
            self.temp_text.setText(f"{dist:.1f}")
            self.temp_text.setPos(target[0], target[1])
            
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MiddleButton:
            self._is_panning = False
            self.setCursor(Qt.CrossCursor if self.picking_mode else Qt.ArrowCursor)
            event.accept()
            return
            
        if self.edit_mode == 'select':
            event.accept()
            return

        # Desabilitado release para usar o 2-cliques system
        if not self.picking_mode:
            super().mouseReleaseEvent(event)

    def keyPressEvent(self, event):
        key = event.key()
        txt = event.text()
        
        # 4. Captura de N√∫meros/Pontos para Dist√¢ncia (CAD-Like)
        has_poly_start = (self.picking_mode == 'poly' and len(self.pick_poly_points) > 0)
        is_drawing_active = (self.picking_mode == 'line' or self.edit_mode in ('line', 'dim', 'circle')) and self.pick_start
        is_drawing_active = is_drawing_active or has_poly_start

        # 1. Backspace no Buffer Num√©rico
        if key == Qt.Key_Backspace and self.keyboard_buffer:
             self.keyboard_buffer = self.keyboard_buffer[:-1]
             if self.keyboard_buffer:
                  self.input_label.setText(f"Entrada: {self.keyboard_buffer}")
             else:
                  self.input_label.hide()
             return

        # 2. Captura de N√∫meros (Se estiver desenhando)
        if is_drawing_active and (txt.isdigit() or txt == '.'):
            self.keyboard_buffer += txt
            label_pref = "Raio: " if self.edit_mode == 'circle' else "Dist√¢ncia: "
            self.input_label.setText(f"{label_pref}{self.keyboard_buffer}")
            self.input_label.show()
            self.input_label.adjustSize()
            # Posicionar perto do mouse inicial ou cursor atual? Cursor atual √© melhor
            mouse_pos = self.mapFromGlobal(QCursor.pos())
            self.input_label.move(mouse_pos.x() + 20, mouse_pos.y() + 20)
            return

        # 3. Tecla ENTER
        if key in (Qt.Key_Return, Qt.Key_Enter):
            # PRIORIDADE: Usar buffer se existir
            if self.keyboard_buffer and is_drawing_active:
                try: val = float(self.keyboard_buffer)
                except ValueError: val = 0
                
                # Calcular ponto de destino baseado na dist√¢ncia e dire√ß√£o do mouse
                cursor_scene = self.mapToScene(self.mapFromGlobal(QCursor.pos()))
                snap_data = self.get_snap(cursor_scene)
                target_look_at = QPointF(*snap_data['pos']) if snap_data else cursor_scene
                
                # Determinar ponto de partida (Pick Start ou √öltimo ponto da Poly)
                start_pt = self.pick_start
                if self.picking_mode == 'poly' and self.pick_poly_points:
                    start_pt = QPointF(*self.pick_poly_points[-1])

                angle = math.atan2(target_look_at.y() - start_pt.y(), target_look_at.x() - start_pt.x())
                if self.ortho_mode:
                    deg = math.degrees(angle) % 360
                    if (315 <= deg < 360) or (0 <= deg < 45): angle = 0
                    elif (45 <= deg < 135): angle = math.pi/2
                    elif (135 <= deg < 225): angle = math.pi
                    else: angle = 3*math.pi/2

                target_x = start_pt.x() + val * math.cos(angle)
                target_y = start_pt.y() + val * math.sin(angle)
                target_pos_obj = QPointF(target_x, target_y)
                
                self.keyboard_buffer = ""
                self.input_label.hide()

                if self.picking_mode == 'poly':
                    self.pick_poly_points.append((target_x, target_y))
                    if not self.poly_visual:
                        self.poly_visual = QGraphicsPathItem()
                        self.poly_visual.setPen(QPen(QColor(0, 255, 255), 2))
                        self.scene.addItem(self.poly_visual)
                        self.poly_visual.setZValue(200)
                    path = QPainterPath()
                    path.moveTo(*self.pick_poly_points[0])
                    for p in self.pick_poly_points[1:]: path.lineTo(*p)
                    self.poly_visual.setPath(path)
                    return

                if self.picking_mode == 'line':
                    self.pick_completed.emit({
                        'text': f"{val:.1f}", 'type': 'line',
                        'points': [(self.pick_start.x(), self.pick_start.y()), (target_x, target_y)]
                    })
                    self.set_picking_mode(None)
                elif self.edit_mode == 'circle':
                    r = val
                    circle = self.scene.addEllipse(self.pick_start.x()-r, self.pick_start.y()-r, r*2, r*2, QPen(QColor(30, 144, 255), 2))
                    circle.setZValue(50); circle.setFlag(QGraphicsItem.ItemIsSelectable); self.overlay_items.append(circle)
                    self._register_new_geometry(circle, {'type': 'circle', 'center': (self.pick_start.x(), self.pick_start.y()), 'radius': r, 'color': 5})
                    self.pick_start = None
                elif self.edit_mode == 'line':
                    line = self.scene.addLine(self.pick_start.x(), self.pick_start.y(), target_x, target_y, QPen(QColor(30, 144, 255), 2))
                    line.setZValue(50); line.setFlag(QGraphicsItem.ItemIsSelectable); self.overlay_items.append(line)
                    self._register_new_geometry(line, {'type': 'line', 'points': [(self.pick_start.x(), self.pick_start.y()), (target_x, target_y)], 'color': 5})
                    self.pick_start = target_pos_obj 
                elif self.edit_mode == 'dim':
                    line = self.scene.addLine(self.pick_start.x(), self.pick_start.y(), target_x, target_y, QPen(QColor(255, 50, 50), 1))
                    mid = QPointF((self.pick_start.x()+target_x)/2, (self.pick_start.y()+target_y)/2)
                    txt_item = self.scene.addSimpleText(f"{val:.1f}", QFont("Arial", 10))
                    txt_item.setPos(mid.x(), mid.y()); txt_item.setBrush(QBrush(QColor(255, 50, 50)))
                    txt_item.setFlag(QGraphicsSimpleTextItem.ItemIgnoresTransformations)
                    self.overlay_items.extend([line, txt_item])
                    self.pick_start = None
                
                if self.temp_item:
                    if self.pick_start and self.edit_mode == 'line': 
                        self.temp_item.setLine(QLineF(self.pick_start, self.pick_start))
                    else: 
                        self.scene.removeItem(self.temp_item); self.temp_item = None
                return

            # SE N√ÉO HOUVER BUFFER - A√ß√£o normal do Enter
            if self.picking_mode:
                if self.picking_mode == 'poly':
                    if len(self.pick_poly_points) >= 2:
                        poly_data = {'text': 'Polyline', 'type': 'poly', 'points': self.pick_poly_points}
                        path = QPainterPath()
                        path.moveTo(*self.pick_poly_points[0])
                        for p in self.pick_poly_points[1:]: path.lineTo(*p)
                        path.closeSubpath()
                        item = self.scene.addPath(path, QPen(QColor(255, 0, 0), 2), QBrush(QColor(255, 0, 0, 50)))
                        self.overlay_items.append(item)
                        self.pick_completed.emit(poly_data); self.set_picking_mode(None)
                    elif len(self.pick_poly_points) == 1:
                        pt = self.pick_poly_points[0]
                        self.pick_completed.emit({'text': f"Pt:{pt[0]:.0f},{pt[1]:.0f}", 'type': 'geometry', 'pos': pt}); self.set_picking_mode(None)
                    else:
                        cursor_pos = self.mapToScene(self.mapFromGlobal(QCursor.pos()))
                        best_ent = self._get_best_entity_under_cursor(cursor_pos)
                        if best_ent: self.pick_completed.emit(best_ent); self.set_picking_mode(None)
                    return

                elif self.picking_mode == 'line' and self.pick_start:
                    cursor_pos = self.mapToScene(self.mapFromGlobal(QCursor.pos()))
                    snap_data = self.get_snap(cursor_pos)
                    target_pt = QPointF(*snap_data['pos']) if snap_data else cursor_pos
                    if self.ortho_mode: target_pt = self._apply_ortho(self.pick_start, target_pt)
                    final_pos = (target_pt.x(), target_pt.y())
                    dist = ((self.pick_start.x()-final_pos[0])**2 + (self.pick_start.y()-final_pos[1])**2)**0.5
                    self.pick_completed.emit({'text': f"{dist:.1f}", 'type': 'line', 'points': [(self.pick_start.x(), self.pick_start.y()), final_pos]})
                    self.set_picking_mode(None)
                    return

                elif self.picking_mode in ('text', 'geometry'):
                    cursor_pos = self.mapToScene(self.mapFromGlobal(QCursor.pos()))
                    best_ent = self._get_best_entity_under_cursor(cursor_pos, mode=self.picking_mode)
                    if best_ent:
                        self.pick_completed.emit(best_ent); self.set_picking_mode(None)
                    return

            if self.edit_mode == 'move' and self.is_moving:
                self.is_moving = False; self.set_edit_mode('select'); return
            elif self.edit_mode == 'line' and not self.keyboard_buffer:
                 self.set_edit_mode('select'); return

        # 4. Atalhos de Ferramentas e Estado Geral
        if key == Qt.Key_Escape:
            self.set_edit_mode(None)
            self.keyboard_buffer = ""
            self.input_label.hide()
            return

        if key == Qt.Key_F8:
            self.toggle_ortho(); return

        # Atalhos de Edi√ß√£o (Somente se n√£o estiver em picking)
        if not self.picking_mode:
            if key == Qt.Key_L: self.set_edit_mode('line'); return
            if key == Qt.Key_C: self.set_edit_mode('circle'); return
            if key == Qt.Key_T: self.set_edit_mode('text'); return
            if key == Qt.Key_D: self.set_edit_mode('dim'); return
            if key == Qt.Key_M: self.set_edit_mode('move'); return
            if key in (Qt.Key_Delete, Qt.Key_Backspace): self._delete_selection(); return

        super().keyPressEvent(event)
        super().keyPressEvent(event)

    def _get_best_entity_under_cursor(self, scene_pos, mode='geometry', aperture=10.0):
        """Busca a melhor entidade DXF ou interativa sob o cursor para picking"""
        # 1. Tentar primeiro por Itens Reais na Cena (Mais preciso para textos da interface)
        view_scale = self.transform().m11()
        search_aperture = 20 / (view_scale if view_scale > 0 else 1)
        rect = QRectF(scene_pos.x() - search_aperture/2, scene_pos.y() - search_aperture/2, search_aperture, search_aperture)
        items = self.scene.items(rect)
        
        for i in items:
            if mode == 'text' and isinstance(i, QGraphicsSimpleTextItem):
                return {'text': i.text(), 'type': 'text', 'pos': (i.pos().x(), i.pos().y())}
            if mode == 'geometry':
                if isinstance(i, (PillarGraphicsItem, SlabGraphicsItem)):
                     return {'text': i.item_data.get('name', 'Item'), 'type': 'geometry', 'id': i.item_data.get('id')}
                if isinstance(i, DXFLineItem):
                     p1 = (i.line().p1().x(), i.line().p1().y())
                     p2 = (i.line().p2().x(), i.line().p2().y())
                     return {'text': f"{i.line().length():.1f}", 'type': 'line', 'points': [p1, p2]}

        # 2. Tentar por Proximidade nos Meta-Dados DXF (Fallback)
        best_ent = None
        min_dist = aperture
        
        for ent in self.dxf_entities:
            dist = 9999.0
            if mode == 'text':
                if 'text' in ent:
                    p = ent['pos']
                    dist = ((p[0]-scene_pos.x())**2 + (p[1]-scene_pos.y())**2)**0.5
            else: # geometry / all
                if 'points' in ent:
                    for p in ent['points']:
                        d = ((p[0]-scene_pos.x())**2 + (p[1]-scene_pos.y())**2)**0.5
                        if d < dist: dist = d
                elif 'pos' in ent and 'text' in ent:
                    p = ent['pos']
                    dist = ((p[0]-scene_pos.x())**2 + (p[1]-scene_pos.y())**2)**0.5
                elif 'radius' in ent and ('pos' in ent or 'center' in ent):
                    p = ent.get('pos', ent.get('center'))
                    d_center = ((p[0]-scene_pos.x())**2 + (p[1]-scene_pos.y())**2)**0.5
                    dist = abs(d_center - ent['radius'])

            if dist < min_dist:
                min_dist = dist
                best_ent = ent

        if best_ent:
            return {
                'type': best_ent.get('type', 'geometry'),
                'text': best_ent.get('text', 'Entidade CAD'),
                'pos': best_ent.get('pos', best_ent.get('center')),
                'points': best_ent.get('points'),
                'radius': best_ent.get('radius')
            }
        return None

    def wheelEvent(self, event):
        """Zoom in/out com scroll do mouse"""
        zoom_in_factor = 1.15
        zoom_out_factor = 1 / zoom_in_factor

        # Se houver scroll vertical
        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor

        self.scale(zoom_factor, zoom_factor)
        
        # Ignora propaga√ß√£o (evita scroll das barras)
        event.accept()
