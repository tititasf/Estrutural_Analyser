
# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit"))))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo"))))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo"))))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key"))))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id"))))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils"))))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://"))))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com"))))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script"))))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

import uuid
import math
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                                QTabWidget, QTableWidget, QTableWidgetItem, 
                                QPushButton, QHeaderView, QFrame, QMessageBox,
                                QLineEdit, QFormLayout, QScrollArea, QComboBox, QGroupBox, QSizePolicy,
                                QRadioButton, QCheckBox, QButtonGroup, QGridLayout, QInputDialog)
from PySide6.QtCore import Qt, Signal
from .link_manager import LinkManager
from src.ui.widgets.interpretation_dialog import InterpretationDialog

class DetailCard(QWidget):
    """
    Ficha T√©cnica Master - Interface Especialista e Rotulagem de IA.
    Configurada para Pilares (Lados A-H), Vigas (Segmentos A/B) e Lajes.
    """
    data_validated = Signal(dict)
    data_invalidated = Signal(dict)
    element_focused = Signal(object) # (str para nome ou dict para link direto)
    element_removed = Signal(dict)   # (dict com slot e link removido)
    pick_requested = Signal(str, str) # (field_id, type)
    focus_requested = Signal(str)    # (field_id) disparado pelo bot√£o de lupa
    research_requested = Signal(str, str) # field_id, slot_id
    training_requested = Signal(str, dict) # field_id, train_data
    config_updated = Signal(str, list)      # field_key, slots_config
    data_changed = Signal(dict)           # (dict) disparado quando qualquer dado muda (nome, dim, etc)
    log_requested = Signal(str)           # (str) pedido de log no console principal
    
    # Estilos CSS Reutiliz√°veis
    STYLE_DEFAULT = "background: #252525; border: 1px solid #444; padding: 4px 6px; border-radius: 4px; color: #eee; font-size: 13px;"
    STYLE_VALID = "background: #252525; border: 1px solid #00cc66; padding: 4px 6px; border-radius: 4px; color: #eee; font-size: 13px; font-weight: bold;"
    STYLE_NA = "background: #333311; border: 1px solid #ffd600; padding: 4px 6px; border-radius: 4px; color: #ffd600; font-size: 13px; font-style: italic;"

    def __init__(self, item_data: dict, parent=None):
        super().__init__(parent)
        self.item_data = item_data
        
        # FIX: Migra√ß√£o de chave legada (segments -> pilar_segs)
        if self.item_data.get('type') == 'Pilar':
            l = self.item_data.get('links', {})
            if l and 'segments' in l and 'pilar_segs' not in l:
                l['pilar_segs'] = l.pop('segments')
            
            # FIX 2: Migra√ß√£o interna (main -> segments) para bater com LinkManager config
            if l and 'pilar_segs' in l:
                ps = l['pilar_segs']
                if 'main' in ps and 'segments' not in ps:
                    ps['segments'] = ps.pop('main')

        self.fields = {} 
        self.indicators = {} 
        self.action_btns = {} # field_id -> { 'link': btn, 'focus': btn, 'na': btn, 'express': btn }
        self.embedded_managers = {}
        self._tipo_comp_buttons = {}  # Armazena refer√™ncias aos round buttons de tipo comprimento 
        self.init_ui()
        
        # Conectar sinal interno para auto-atualiza√ß√£o do cabe√ßalho
        self.data_changed.connect(self._update_header_counts)

    def _scan_local_segments(self):
        """Conta segmentos locais (A, B) para exibi√ß√£o no cabe√ßalho"""
        sa, sb = {1}, {1}
        for k in self.item_data.keys():
            if '_seg_' in k:
                try:
                    parts = k.split('_')
                    if 'seg' in parts:
                        idx = int(parts[parts.index('seg') + 1])
                        if k.startswith('viga_a_'): sa.add(idx)
                        elif k.startswith('viga_b_'): sb.add(idx)
                except: pass
        return len(sa), len(sb)

    def _update_header_counts(self, _=None):
        """Atualiza widgets de contagem no cabe√ßalho se existirem"""
        if 'viga_count_a' in self.fields or 'viga_count_b' in self.fields:
            na, nb = self._scan_local_segments()
            
            if 'viga_count_a' in self.fields:
                self.fields['viga_count_a'].setText(str(na))
                # For√ßar atualiza√ß√£o visual estilo readonly
                self.fields['viga_count_a'].setStyleSheet("background: #333; color: #00d4ff; font-weight: bold; border: none;")
                
            if 'viga_count_b' in self.fields:
                self.fields['viga_count_b'].setText(str(nb))
                self.fields['viga_count_b'].setStyleSheet("background: #333; color: #00d4ff; font-weight: bold; border: none;")


    def _add_linked_row(self, layout, label_text, field_id, pick_type='text', is_combo=False, combo_items=None, 
                        show_links=True, show_focus=True, hide_input=False, show_validate=True, show_na=True):
        
        w = None
        btn_links = None
        btn_focus = None
        if not hide_input:
            if is_combo:
                w = QComboBox()
                if combo_items: w.addItems(combo_items)
                w.setFixedHeight(22)
                w.setMinimumWidth(20)
                w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
                if "Pos." in label_text: # L√≥gica especial para posi√ß√£o da laje
                    w.currentTextChanged.connect(lambda t: self._on_position_changed(field_id, t))
            else:
                w = QLineEdit()
                w.setFixedHeight(22)
                w.setMinimumWidth(20)
                w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
                
            w.setStyleSheet(self.STYLE_DEFAULT if field_id not in self.item_data.get('validated_fields', []) else self.STYLE_VALID)
            self.fields[field_id] = w
            
            # Conectar mudan√ßa imediata para refletir nas listas do MainWindow
            if is_combo:
                w.currentTextChanged.connect(lambda txt: self._on_field_changed(field_id, txt))
            else:
                w.textChanged.connect(lambda txt: self._on_field_changed(field_id, txt))
            
            # Tentar carregar valor inicial
            initial_val = self._get_initial_value(field_id)
            if initial_val is not None:
                if is_combo: w.setCurrentText(str(initial_val))
                else: w.setText(str(initial_val))
        else:
            # Placeholder invis√≠vel ou label para campos sem input de texto (como apenas segmentos)
            w = QLabel("V√≠nculo Pendente")
            w.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
            self.fields[field_id] = w
            
            # Tentar carregar valor inicial (se houver extra√ß√£o de texto autom√°tica)
            initial_val = self._get_initial_value(field_id)
            
            # Se j√° tiver v√≠nculos, mostrar contagem (Fallback)
            links = self.item_data.get('links', {}).get(field_id, {})
            count = 0
            if isinstance(links, dict):
                for sl_links in links.values(): count += len(sl_links)
            elif isinstance(links, list):
                count = len(links)
                
            if initial_val:
                w.setText(f"Dim: {initial_val}")
                w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")
            elif count > 0 and isinstance(w, QLabel):
                w.setText(f"{count} V√≠nculo(s) Ok")
                w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")

        # Sub-container for the drawer (inline LinkManager)
        drawer_container = QWidget()
        drawer_container.hide()
        drawer_container.setStyleSheet("""
            QWidget { background: #181818; border-left: 2px solid #00d4ff; margin-bottom: 5px; }
        """)

        if show_links:
            btn_links = QPushButton("üîó")
            btn_links.setFixedSize(28, 24)
            btn_links.setProperty("class", "FieldBtn")
            btn_links.setStyleSheet("font-size: 12px; padding: 2px;")
            btn_links.setCursor(Qt.PointingHandCursor)
            btn_links.setToolTip("Gerenciar V√≠nculos (Expandir)")
            btn_links.clicked.connect(lambda: self._toggle_link_drawer(field_id, drawer_container))

        if show_focus:
            btn_focus = QPushButton("üîç")
            btn_focus.setFixedSize(28, 24)
            btn_focus.setProperty("class", "FieldBtn")
            btn_focus.setStyleSheet("font-size: 12px; padding: 2px;")
            btn_focus.setCursor(Qt.PointingHandCursor)
            btn_focus.setToolTip("Localizar objeto no CAD")
            btn_focus.clicked.connect(lambda checked=False, f_id=field_id: self.focus_requested.emit(f_id))
        
        # --- LAYOUT HORIZONTAL √öNICO ---
        # Garante que tudo fique em UMA linha s√≥
        row_layout = QHBoxLayout()
        row_layout.setContentsMargins(0, 0, 0, 0)
        row_layout.setSpacing(1)

        # 1. Label (Largura aumentada para evitar truncamento - Task_01)
        lbl = QLabel(label_text)
        lbl.setFixedWidth(150) 
        lbl.setWordWrap(True) 
        lbl.setStyleSheet("font-size: 10px; color: #ccc; font-weight: bold;")
        lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        row_layout.addWidget(lbl)

        # 2. Input Field (Flex√≠vel, stretch=1)
        # O input vai ocupar todo o espa√ßo que sobrar entre o label e os bot√µes
        if w:
            w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            w.setMinimumWidth(20) # Permite encolher bastante se necess√°rio
            row_layout.addWidget(w, stretch=1)
            
        # 3. Bloco de A√ß√µes (Fixo √† direita)
        actions_frame = QWidget()
        actions_layout = QHBoxLayout(actions_frame)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(1)
        
        # Indicador Confian√ßa
        conf_score = self.item_data.get('confidence_map', {}).get(field_id, 0.0)
        color = "#ff4444"
        if conf_score > 0.8: color = "#00c853"
        elif conf_score > 0.4: color = "#ffd600"
        
        conf_indicator = QLabel("‚óè")
        conf_indicator.setFixedSize(8, 20) # Altura compat√≠vel com bot√µes
        conf_indicator.setStyleSheet(f"color: {color}; font-size: 8px; margin-left: 2px;")
        actions_layout.addWidget(conf_indicator)
        
        if btn_links: 
            btn_links.setText("üîó Vincular")
            btn_links.setFixedWidth(80) 
            btn_links.setFixedHeight(22)
            actions_layout.addWidget(btn_links)
            
        if show_validate:
            # Bot√£o Express Validate (ao lado do link ou isolado)
            btn_express = QPushButton("‚úî Validar")
            btn_express.setFixedWidth(80)
            btn_express.setFixedHeight(22)
            btn_express.setCheckable(True)
            btn_express.setChecked(field_id in self.item_data.get('validated_fields', []))
            btn_express.setProperty("class", "FieldBtn")
            btn_express.setCursor(Qt.PointingHandCursor)
            btn_express.setToolTip("Valida√ß√£o Express (Clique para desfazer)")
            # Estilo verde discreto
            btn_express.setStyleSheet("""
                QPushButton { color: #4CAF50; border: 1px solid #333; border-radius: 2px; font-size: 10px; font-weight: bold;}
                QPushButton:hover { background: #4CAF50; color: white; border: 1px solid #4CAF50; }
                QPushButton:checked { background: #1b3a24; color: #4CAF50; border: 1px solid #4CAF50; }
            """)
            btn_express.clicked.connect(lambda checked, f_id=field_id: self._on_express_validate(f_id))
            actions_layout.addWidget(btn_express)

        if btn_focus: 
            btn_focus.setText("üîç Zoom")
            btn_focus.setFixedWidth(70)
            btn_focus.setFixedHeight(22)
            actions_layout.addWidget(btn_focus)

        if show_na:
            # Bot√£o N/A (üö´)
            btn_na = QPushButton("üö´ N/A")
            btn_na.setFixedWidth(60)
            btn_na.setFixedHeight(22)
            btn_na.setProperty("class", "FieldBtn")
            btn_na.setCursor(Qt.PointingHandCursor)
            btn_na.setToolTip("N√£o se aplica / Omitir")
            btn_na.setStyleSheet("""
                QPushButton { color: #f44336; border: 1px solid #333; border-radius: 2px; font-size: 10px; font-weight: bold; }
                QPushButton:hover { background: #f44336; color: white; }
                QPushButton:checked { background: #ffd600; color: #333; border: 1px solid #ffd600; }
            """)
            btn_na.setCheckable(True)
            btn_na.setChecked(field_id in self.item_data.get('na_fields', []))
            btn_na.clicked.connect(lambda chk, f_id=field_id: self._on_na_clicked(f_id, chk))
            actions_layout.addWidget(btn_na)
        else:
            btn_na = None
        
        # Guardar refer√™ncias para bloqueio reativo
        self.action_btns[field_id] = {
            'link': btn_links,
            'focus': btn_focus,
            'na': btn_na,
            'express': btn_express if 'btn_express' in locals() else None
        }

        row_layout.addWidget(actions_frame)

        # Adiciona a linha principal e o drawer (que come√ßa oculto)
        layout.addRow(row_layout)
        layout.addRow(drawer_container)

    def _on_position_changed(self, field_id, text):
        """Exibe campo de dist√¢ncia se for 'Centro' ou 'Laje central'"""
        dist_field_id = field_id.replace("_p", "_dist_c")
        if dist_field_id in self.fields:
            field_widget = self.fields[dist_field_id]
            visible = (text in ("Centro", "Esquerda", "Direita"))
            field_widget.setEnabled(visible)
            if not visible: field_widget.setText("0.0")
            field_widget.setVisible(True)

    def _toggle_link_drawer(self, field_id, container):
        """Toggles the inline LinkManager drawer"""
        if container.isVisible():
            container.hide()
        else:
            if container.layout() is None or container.layout().count() == 0:
                self._load_link_manager_into(field_id, container)
            
            # For√ßar atualiza√ß√£o de dados antes de exibir
            lm = self.embedded_managers.get(field_id)
            if lm:
                links_dict = self.item_data.get('links', {})
                current_links = links_dict.get(field_id, {})
                if isinstance(current_links, list): current_links = {'label': current_links}
                lm.links = current_links
                lm.refresh_list()
                
            container.show()

    def _load_link_manager_into(self, field_id, container):
        """Instantiates and embeds a LinkManager into the container"""
        # Ensure layout
        if not container.layout():
            layout = QVBoxLayout(container)
            layout.setContentsMargins(0,0,0,0)
            layout.setSpacing(0)
        
        # Get links
        links_dict = self.item_data.get('links', {})
        current_links = links_dict.get(field_id, {})
        if isinstance(current_links, list):
             # CONVERTER E SALVAR: Normaliza para dicion√°rio para manter refer√™ncia consistente
             # Isso corrige o bug onde o LinkManager operava num dict tempor√°rio e o remove_link falhava
             normalized_links = {'label': current_links}
             links_dict[field_id] = normalized_links
             current_links = normalized_links
             
        # New: Retrieve N/A and Validated Slots for this field
        na_slots_map = self.item_data.get('na_link_classes', {})
        current_na_slots = na_slots_map.get(field_id, [])
        
        valid_slots_map = self.item_data.get('validated_link_classes', {})
        current_valid_slots = valid_slots_map.get(field_id, [])
             
        # Create Manager
        lm = LinkManager(field_id, current_links, na_slots=current_na_slots, validated_slots=current_valid_slots, parent=self)
        self.embedded_managers[field_id] = lm
        
        # Connect Signals (Similar to original dialog logic)
        lm.pick_requested.connect(lambda slot_req: self._on_manager_pick_requested(field_id, slot_req))
        lm.focus_requested.connect(lambda l: self.element_focused.emit(l))
        lm.remove_requested.connect(lambda data: self._remove_link(field_id, data, lm))
        lm.research_requested.connect(lambda s_id: self.research_requested.emit(field_id, s_id))
        lm.training_requested.connect(lambda t_data: self.training_requested.emit(field_id, t_data))
        lm.config_changed.connect(lambda k, v: self.config_updated.emit(k, v))
        
        # New Signals for Hierarchy
        lm.slot_na_toggled.connect(lambda s_id, is_na: self._on_slot_na_toggled(field_id, s_id, is_na))
        lm.slot_validated.connect(lambda s_id, checked: self._on_slot_validated(field_id, s_id, checked))
        
        # --- NOVO: Conectar mudan√ßa de metadados de interpreta√ß√£o ---
        lm.metadata_changed.connect(lambda s_id, t_type, d: self._on_metadata_changed(field_id, s_id, t_type, d))
        
        # Injetar metadados existentes para carregar o cache do LM
        if 'field_metadata' in self.item_data:
            # Estrutura esperada: item_data['field_metadata'][field_id][slot_id] = {prompt, patterns}
            field_meta = self.item_data['field_metadata'].get(field_id, {})
            lm.metadata_cache = field_meta.copy() # Copia simples
        
        container.layout().addWidget(lm)

    def _on_metadata_changed(self, field_id, slot_id, meta_type, data):
        """Salva metadados vindos do LinkManager (n√≠vel de Slot)"""
        if 'field_metadata' not in self.item_data:
            self.item_data['field_metadata'] = {}
            
        if field_id not in self.item_data['field_metadata']:
            self.item_data['field_metadata'][field_id] = {}
            
        # Salva especificamente para o slot
        self.item_data['field_metadata'][field_id][slot_id] = data
        
        # Opcional: print debug
        print(f"[DetailCard] Metadados de {meta_type} atualizados para {field_id} -> {slot_id}")
        self.data_changed.emit(self.item_data)

    def _on_manager_pick_requested(self, field_id, slot_req):
        """Disparado quando um slot espec√≠fico pede captura no canvas"""
        self.pick_requested.emit(field_id, slot_req)

    def _remove_link(self, field_id, data, dlg):
        """data is a dict: {'slot': slot_id, 'link': link_obj}"""
        slot_id = data.get('slot')
        link = data.get('link')
        
        links_dict = self.item_data.get('links', {})
        field_links = links_dict.get(field_id, {})
        
        if slot_id in field_links:
            # REMO√á√ÉO ROBUSTA: LinkManager pode j√° ter removido da lista (mesma ref), 
            # ou pode ser uma c√≥pia.
            
            # 1. Tentar remover por identidade de objeto
            if link in field_links[slot_id]:
                field_links[slot_id].remove(link)
                print(f"[DetailCard] Link removido por refer√™ncia direta de {slot_id}.")
            else:
                 # 2. Remover por igualdade de conte√∫do (Fallback)
                 idx_to_remove = -1
                 for i, l in enumerate(field_links[slot_id]):
                     # Compara chaves essenciais para garantir que √© o mesmo v√≠nculo
                     same_text = l.get('text') == link.get('text')
                     same_type = l.get('type') == link.get('type')
                     same_pos = str(l.get('pos')) == str(link.get('pos')) # str compare to avoid float issues
                     same_pts = str(l.get('points')) == str(link.get('points'))
                     
                     if same_type and (same_text or same_pts): # Pelo menos tipo e um identificador
                         if same_pos: # Posi√ß√£o √© forte indicador
                             idx_to_remove = i
                             break
                 
                 if idx_to_remove >= 0:
                     del field_links[slot_id][idx_to_remove]
                     print(f"[DetailCard] Link removido por compara√ß√£o de valor de {slot_id}.")
                 else:
                     print(f"[DetailCard] AVISO: Link n√£o encontrado para remo√ß√£o em {slot_id} (Provavelmente removido pelo LinkManager?)")
                
            # SEMPRE executa limpeza visual e atualiza√ß√£o de labels
            if field_id in self.item_data.get('validated_fields', []):
                self.item_data['validated_fields'].remove(field_id)
            
            # Recalcular is_validated se necess√°rio
            if not self.item_data.get('validated_fields'):
                self.item_data['is_validated'] = False

            print(f"[DetailCard] V√≠nculo removido de {field_id}. Restantes: {len(field_links[slot_id]) if slot_id in field_links else 0}")
            self.refresh_validation_styles()
            
            # Notificar mudan√ßa de dados para sincronizar listas e canvas
            self.data_changed.emit(self.item_data)
            self.element_removed.emit({'slot': slot_id, 'link': link})
            dlg.refresh_list()

    def mark_field_validated(self, field_id, is_valid=True):
        """Aplica estilo visual de valida√ß√£o no widget do campo de forma otimizada"""
        validated = self.item_data.setdefault('validated_fields', [])
        
        # Otimiza√ß√£o: Se j√° estiver no estado desejado, n√£o faz nada
        if is_valid and field_id in validated: return
        if not is_valid and field_id not in validated: return

        if is_valid:
            validated.append(field_id)
            
            # --- CASCADE VALIDATION TO LINKS ---
            if 'links' in self.item_data and field_id in self.item_data['links']:
                links_data = self.item_data['links'][field_id]
                if isinstance(links_data, dict):
                    valid_map = self.item_data.setdefault('validated_link_classes', {})
                    valid_map[field_id] = list(links_data.keys())
                    
                    for slot_id, link_list in links_data.items():
                        for link in link_list:
                            link['validated'] = True
            
            if field_id in self.embedded_managers:
                lm = self.embedded_managers[field_id]
                lm.links = self.item_data['links'].get(field_id, {})
                lm.validated_slots = set(self.item_data.get('validated_link_classes', {}).get(field_id, []))
                lm.refresh_list()
        else:
            validated.remove(field_id)
            
        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def _on_na_clicked(self, field_id, checked):
        """Gerencia o estado 'N√£o se Aplica' de um campo com justificativa"""
        na_fields = self.item_data.setdefault('na_fields', [])
        na_reasons = self.item_data.setdefault('na_reasons', {})
        
        if checked:
            # N√£o solicita mais coment√°rio (Task_01)
            reason = "Omitido pelo usu√°rio"
            na_reasons[field_id] = reason
            if field_id not in na_fields: na_fields.append(field_id)
            self.mark_field_validated(field_id, True)
                
            # --- CASCADE N/A TO SLOTS ---
            if 'na_link_classes' not in self.item_data: self.item_data['na_link_classes'] = {}
            na_map = self.item_data['na_link_classes']
            
            slots_to_na = []
            if field_id in self.embedded_managers:
                lm = self.embedded_managers[field_id]
                slots_to_na = [s['id'] for s in lm._get_slots(field_id)]
            else:
                current_links = self.item_data.get('links', {}).get(field_id, {})
                if isinstance(current_links, dict):
                    slots_to_na = list(current_links.keys())
            
            na_map[field_id] = list(set(slots_to_na))
            
            # Limpa v√≠nculos
            if 'links' in self.item_data and field_id in self.item_data['links']:
                links_data = self.item_data['links'][field_id]
                if isinstance(links_data, dict):
                    for k in links_data: links_data[k] = []
                elif isinstance(links_data, list):
                    self.item_data['links'][field_id] = {}

            # Atualiza LM se existir
            if field_id in self.embedded_managers:
                lm = self.embedded_managers[field_id]
                lm.na_slots = set(slots_to_na)
                lm.links = self.item_data['links'].get(field_id, {})
                lm.refresh_list()
            
            # Visual Clean
            widget = self.fields.get(field_id)
            if widget:
                if isinstance(widget, QLineEdit): widget.setText("N/A")
                elif isinstance(widget, QComboBox):
                    idx = widget.findText("N/A")
                    if idx >= 0: widget.setCurrentIndex(idx)
            
            # Treino em Cascata
            for s_id in slots_to_na:
                self.training_requested.emit(field_id, {
                    'status': 'na',
                    'comment': f"Cascata N/A: {reason}",
                    'slot': s_id
                })
            if not slots_to_na:
                self.training_requested.emit(field_id, {
                    'status': 'na',
                    'comment': f"Campo N/A: {reason}",
                    'slot': 'main'
                })
        else:
            if field_id in na_fields: na_fields.remove(field_id)
            if field_id in na_reasons: del na_reasons[field_id]
            
            widget = self.fields.get(field_id)
            if widget and isinstance(widget, QLineEdit) and widget.text() == "N/A":
                widget.setText("")
            
            na_map = self.item_data.get('na_link_classes', {})
            slots_to_reset = na_map.get(field_id, [])
            for s_id in slots_to_reset:
                 self.training_requested.emit(field_id, { 'status': 'removed', 'slot': s_id, 'link': {'text': 'N/A'} })
            
            if field_id in na_map: del na_map[field_id]
            self.mark_field_validated(field_id, False)
        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def _on_express_validate(self, field_id):
        """Valida o campo imediatamente ou Desfaz (Undo) se j√° estava validado"""
        is_already_validated = field_id in self.item_data.get('validated_fields', [])
        
        if is_already_validated:
             self.undo_field_validation(field_id)
             return
             
        widget = self.fields.get(field_id)
        if not widget: return
        
        val = ""
        if isinstance(widget, QLineEdit): val = widget.text()
        elif isinstance(widget, QComboBox): val = widget.currentText()
        
        # Recuperar links existentes para treino
        links = self.item_data.get('links', {}).get(field_id, {})
        if isinstance(links, list): links = {'label': links}
        
        target_link = None
        target_slot = 'default'
        
        # Busca primeiro link dispon√≠vel
        for slot, link_list in links.items():
            if link_list:
                target_link = link_list[0]
                target_slot = slot
                break
        
        if not target_link:
            # Cria synthetic link se n√£o houver
            target_link = {
                'text': val, 
                'type': 'text', 
                'pos': self.item_data.get('pos', (0,0)), 
                'debug': 'Express Validation'
            }
            
        # Emite sinal de treino para o campo principal (se aplicavel)
        if target_slot == 'default':
             self.training_requested.emit(field_id, {
                 'slot': target_slot,
                 'link': target_link,
                 'comment': "Expresso: Validado pelo usu√°rio",
                 'status': "valid",
                 'propagate': False
             })

        # --- SMART VALIDATION CASCADE ---
        # 1. Obter slots esperados para este campo
        expected_slots = []
        if field_id in self.embedded_managers:
             expected_slots = [s['id'] for s in self.embedded_managers[field_id]._get_slots(field_id)]
        else:
             # Inst√¢ncia tempor√°ria para obter configura√ß√£o
             try:
                 tmp = LinkManager(field_id, {}, parent=None)
                 expected_slots = [s['id'] for s in tmp._get_slots(field_id)]
                 tmp.deleteLater()
             except:
                 expected_slots = []

        # 2. Verificar conte√∫do e distribuir status
        if expected_slots:
             valid_map = self.item_data.setdefault('validated_link_classes', {})
             na_map = self.item_data.setdefault('na_link_classes', {})
             
             # Garante listas iniciadas
             if field_id not in valid_map: valid_map[field_id] = []
             if field_id not in na_map: na_map[field_id] = []
             
             current_links = self.item_data.get('links', {}).get(field_id, {})
             if isinstance(current_links, list): current_links = {'label': current_links} # Normalize
             
             for slot_id in expected_slots:
                 has_links = slot_id in current_links and len(current_links[slot_id]) > 0
                 
                 if has_links:
                     # Tem links -> Valida
                     if slot_id not in valid_map[field_id]: 
                         valid_map[field_id].append(slot_id)
                     if slot_id in na_map[field_id]:
                         na_map[field_id].remove(slot_id)
                         
                     # Treinar este slot como valido
                     self.training_requested.emit(field_id, {
                         'slot': slot_id,
                         'link': current_links[slot_id][0], # Usa o primeiro link como exemplo
                         'comment': f"Smart Validation: Slot {slot_id} validado.",
                         'status': "valid",
                         'propagate': False
                     })
                 else:
                     # Vazio -> Marca N/A (N√£o se aplica a este item)
                     if slot_id not in na_map[field_id]:
                         na_map[field_id].append(slot_id)
                     if slot_id in valid_map[field_id]:
                         valid_map[field_id].remove(slot_id)
                         
                     # Treinar este slot como N/A
                     self.training_requested.emit(field_id, {
                         'status': 'na',
                         'comment': f"Smart Validation: Slot {slot_id} vazio marcado como N/A",
                         'slot': slot_id
                     })
        
        # Marca e atualiza visual
        self.mark_field_validated(field_id, True)
        
        if self.embedded_managers.get(field_id):
            return

    def _add_pilar_opening_group(self, form_layout, label_text, prefix):
        """Creates a specialized grouped row for Pillar Openings (Clean List)"""
        # Outer container for the group
        group_container = QWidget()
        group_layout = QVBoxLayout(group_container)
        group_layout.setContentsMargins(0, 5, 0, 5)
        group_layout.setSpacing(2)

        # Header with Label + Link Button
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0,0,0,0)
        
        lbl = QLabel(label_text)
        lbl.setStyleSheet("font-size: 11px; color: #00bcd4; font-weight: bold;")
        
        # Drawer for Pillar
        drawer = QWidget()
        drawer.hide()
        drawer.setStyleSheet("background: #181818; border-left: 2px solid #00bcd4;")

        btn_link = QPushButton("üîó Vincular")
        btn_link.setCursor(Qt.PointingHandCursor)
        btn_link.setStyleSheet("""
            QPushButton { border: 1px solid #444; border-radius: 4px; background: #222; color: #aaa; padding: 2px 6px; font-size: 10px; }
            QPushButton:hover { background: #333; color: white; border-color: #666; }
        """)
        btn_link.clicked.connect(lambda: self._toggle_link_drawer(prefix, drawer))
        
        btn_focus = QPushButton("üîç")
        btn_focus.setFixedSize(24, 20)
        btn_focus.setCursor(Qt.PointingHandCursor)
        btn_focus.setStyleSheet("background: transparent; border: 1px solid #444; color: #aaa; font-size: 10px;")
        btn_focus.clicked.connect(lambda checked=False, p=prefix: self.focus_requested.emit(p))
        
        header_layout.addWidget(lbl)
        header_layout.addStretch()
        header_layout.addWidget(btn_focus)
        header_layout.addWidget(btn_link)
        
        group_layout.addWidget(header_widget)
        group_layout.addWidget(drawer) # Add drawer here too
        
        # Internal Form for Fields (Indented)
        form_inner_widget = QWidget()
        form_inner = QFormLayout(form_inner_widget)
        form_inner.setContentsMargins(5, 0, 0, 0) # Reduzido ident para caber melhor
        form_inner.setSpacing(1)
        form_inner.setLabelAlignment(Qt.AlignLeft)
        
        # Fields: Dist, Larg, Diff
        # Remove fixed width restrictions for cleaner look
        f_dist = self._create_sub_field(prefix, "dist", "", 0) 
        f_larg = self._create_sub_field(prefix, "larg", "", 0)
        f_diff = self._create_sub_field(prefix, "diff", "", 0)
        
        form_inner.addRow("Dist:", f_dist)
        form_inner.addRow("Larg:", f_larg)
        form_inner.addRow("Dif:", f_diff)
        
        group_layout.addWidget(form_inner_widget)
        
        # Add the whole group as a single row in the main form (spanning both cols)
        form_layout.addRow(group_container)

    def _add_beam_opening_group(self, form_layout, label_text, prefix):
        """Creates a specialized grouped row for Beam Openings (Clean List)"""
        group_container = QWidget()
        group_layout = QVBoxLayout(group_container)
        group_layout.setContentsMargins(0, 5, 0, 5)
        group_layout.setSpacing(2)

        # Header
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0,0,0,0)
        
        lbl = QLabel(label_text)
        lbl.setStyleSheet("font-size: 11px; color: #00bcd4; font-weight: bold;")
        
        # Drawer for Beam
        drawer = QWidget()
        drawer.hide()
        drawer.setStyleSheet("background: #181818; border-left: 2px solid #00bcd4;")

        btn_link = QPushButton("üîó Vincular")
        btn_link.setCursor(Qt.PointingHandCursor)
        btn_link.setStyleSheet("""
            QPushButton { border: 1px solid #444; border-radius: 4px; background: #222; color: #aaa; padding: 2px 6px; font-size: 10px; }
            QPushButton:hover { background: #333; color: white; border-color: #666; }
        """)
        btn_link.clicked.connect(lambda: self._toggle_link_drawer(prefix, drawer))
        
        btn_focus = QPushButton("üîç")
        btn_focus.setFixedSize(24, 20)
        btn_focus.setCursor(Qt.PointingHandCursor)
        btn_focus.setStyleSheet("background: transparent; border: 1px solid #444; color: #aaa; font-size: 10px;")
        btn_focus.clicked.connect(lambda checked=False, p=prefix: self.focus_requested.emit(p))
        
        header_layout.addWidget(lbl)
        header_layout.addStretch()
        header_layout.addWidget(btn_focus)
        header_layout.addWidget(btn_link)
        
        group_layout.addWidget(header_widget)
        group_layout.addWidget(drawer)

        # Internal Form
        form_inner_widget = QWidget()
        form_inner = QFormLayout(form_inner_widget)
        form_inner.setContentsMargins(5, 0, 0, 0) # Reduzido ident
        form_inner.setSpacing(1)
        form_inner.setLabelAlignment(Qt.AlignLeft)

        # Fields: Larg, Aj.Boca, Prof, Aj.Prof
        f_larg = self._create_sub_field(prefix, "larg", "", 0)
        f_aj_b = self._create_sub_field(prefix, "aj_boca", "", 0)
        f_prof = self._create_sub_field(prefix, "prof", "", 0)
        f_aj_p = self._create_sub_field(prefix, "aj_prof", "", 0)

        form_inner.addRow("Larg M:", f_larg)
        form_inner.addRow("Aj. Boca:", f_aj_b)
        form_inner.addRow("Prof:", f_prof)
        form_inner.addRow("Aj. Prof:", f_aj_p)
        
        group_layout.addWidget(form_inner_widget)

        form_layout.addRow(group_container)

    def _create_sub_field(self, prefix, suffix, placeholder, width):
        """Helper to create sub-fields for complex groups"""
        full_key = f"{prefix}_{suffix}"
        
        default_val = self.item_data.get(full_key, "")
        
        f = QLineEdit(str(default_val))
        if placeholder: f.setPlaceholderText(placeholder)
        if width > 0:
            f.setFixedWidth(width)
        else:
            f.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            
        f.setStyleSheet(self.STYLE_DEFAULT)
        f.textChanged.connect(lambda txt: self._on_field_changed(full_key, txt))
        
        self.fields[full_key] = f
        return f

    def _on_field_changed(self, key, value):
        """Atualiza item_data imediatamente ao digitar"""
        self.item_data[key] = value
        self.data_changed.emit(self.item_data)
        
        # Sincroniza√ß√£o especial para Marco DXF
        if key.startswith('ext_viga_') and 'vigas_individuais' in self.item_data:
            v_id = key.replace('ext_viga_', '')
            for v in self.item_data['vigas_individuais']:
                if v.get('id') == v_id:
                    try:
                        v['extension_len'] = float(value)
                        v['final_len'] = v['original_len'] + v['extension_len']
                    except: pass
                    break

    def refresh_validation_styles(self):
        """Otimizado: Varre campos e aplica estilos apenas em mudan√ßas de estado"""
        validated_fields = set(self.item_data.get('validated_fields', []))
        na_fields = set(self.item_data.get('na_fields', []))
        
        for fid, w in self.fields.items():
            if isinstance(w, QButtonGroup): continue
            
            is_valid = fid in validated_fields
            is_na = fid in na_fields
            
            # 1. Input Fields (Optimized Stylesheet)
            if isinstance(w, (QLineEdit, QComboBox)):
                if not is_na and fid.endswith(('_prof', '_boca', '_dist', '_larg', '_h_sel')):
                     # Verificar N/A herdado de tabelas de abertura
                     # Prefixo pai √© o fid sem o sufixo
                     parent_na = False
                     for suf in ['_prof', '_boca', '_dist', '_larg', '_h_sel']:
                         if fid.endswith(suf):
                             parent_id = fid[:-len(suf)]
                             if parent_id in na_fields:
                                 is_na = True
                                 parent_na = True
                                 break
                
                target_style = self.STYLE_NA if is_na else (self.STYLE_VALID if is_valid else self.STYLE_DEFAULT)
                if w.styleSheet() != target_style:
                    w.setStyleSheet(target_style)
                
                target_enabled = not is_na
                if w.isEnabled() != target_enabled:
                    w.setEnabled(target_enabled)

            # 2. Action Buttons
            btns = self.action_btns.get(fid, {})
            if btns:
                for bkey in ['focus', 'express']:
                    b = btns.get(bkey)
                    if b and b.isEnabled() == is_na: # Toggle only if needed
                        b.setEnabled(not is_na)
                
                b_na = btns.get('na')
                if b_na:
                    if b_na.isChecked() != is_na:
                        b_na.blockSignals(True)
                        b_na.setChecked(is_na)
                        b_na.blockSignals(False)
            
            # 3. Linked Labels (hide_input=True)
            if isinstance(w, QLabel):
                if is_na:
                    new_text = "N/A - N√£o se aplica"
                    if w.text() != new_text:
                        w.setText(new_text)
                        w.setStyleSheet("color: #ffd600; font-weight: bold; font-size: 10px; font-style: italic;")
                else:
                    links = self.item_data.get('links', {}).get(fid, {})
                    count = 0
                    if isinstance(links, dict):
                        count = len(links.get('seg_bottom', [])) if fid == 'viga_segs' else sum(len(l) for l in links.values())
                    elif isinstance(links, list):
                        count = len(links)
                    
                    if is_valid:
                        txt = f"{count} V√≠nculo(s) ‚úÖ" if count > 0 else "Validado ‚úÖ"
                        if w.text() != txt:
                            w.setText(txt)
                            w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 11px; background: rgba(0, 204, 102, 0.1); border: 1px solid #00cc66; border-radius: 4px; padding: 2px;")
                    elif count > 0:
                        txt = f"{count} V√≠nculo(s) Ok"
                        if w.text() != txt:
                            w.setText(txt)
                            w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")
                    else:
                        if w.text() != "V√≠nculo Pendente":
                            w.setText("V√≠nculo Pendente")
                            w.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")

            # 4. Indicators
            if fid in self.indicators:
                indicator = self.indicators[fid]
                if is_na:
                    st = "color: #ffd600; font-size: 14px; margin-right: 5px;"
                elif is_valid:
                    st = "color: #00cc66; font-size: 14px; margin-right: 5px;"
                else:
                    conf = self.item_data.get('confidence_map', {}).get(fid, 0.0)
                    clr = "#ff4444" if conf <= 0.4 else ("#ffd600" if conf <= 0.8 else "#00c853")
                    st = f"color: {clr}; font-size: 14px; margin-right: 5px;"
                
                if indicator.styleSheet() != st:
                    indicator.setStyleSheet(st)
        
        # Async-like update for LinkManagers
        for fid, lm in self.embedded_managers.items():
            if lm.isVisible(): # Optimization: Refresh only if visible
                lm.na_slots = set(self.item_data.get('na_link_classes', {}).get(fid, []))
                lm.validated_slots = set(self.item_data.get('validated_link_classes', {}).get(fid, []))
                lm.refresh_list()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(2, 5, 2, 5) # Margem m√≠nima
        layout.setSpacing(3)
        
        # --- Cabe√ßalho Din√¢mico ---
        elem_type = self.item_data.get('type', 'Pilar').upper()
        
        # PARA LAJES ou MARCO: O Header √© omitido aqui e criado dentro da aba/view espec√≠fica
        if 'LAJE' not in elem_type and 'MARCO' not in elem_type:
            header_title = f"DADOS GERAIS - {elem_type}"
            
            header = QGroupBox(header_title)
            header.setStyleSheet("QGroupBox { font-size: 10px; font-weight: bold; color: #ffb300; border: 1px solid #333; margin-top: 5px; padding-top: 8px; }")
            h_layout = QFormLayout(header)
            h_layout.setContentsMargins(2, 2, 2, 2)
            h_layout.setSpacing(1)
            
            self._add_linked_row(h_layout, "N¬∫ Item:", "id_item", "text", show_links=False, show_focus=False, show_validate=False, show_na=False)
            self._add_linked_row(h_layout, "Nome:", "name", "text")
            
            if 'VIGA' in elem_type:
                 # Campo Segmentos agora cont√©m apenas seg_bottom (fundos)
                 # self._add_linked_row(h_layout, "Segmentos:", "viga_segs", "poly", hide_input=True)
                 
                 # Novos contadores de segmentos (Read Only via update loop)
                 na, nb = self._scan_local_segments()
                 self._add_linked_row(h_layout, "Qtd. Seg. A:", "viga_count_a", "text", show_links=False, show_focus=False, show_validate=False, show_na=False)
                 self.fields['viga_count_a'].setText(str(na))
                 self.fields['viga_count_a'].setReadOnly(True)
                 
                 self._add_linked_row(h_layout, "Qtd. Seg. B:", "viga_count_b", "text", show_links=False, show_focus=False, show_validate=False, show_na=False)
                 self.fields['viga_count_b'].setText(str(nb))
                 self.fields['viga_count_b'].setReadOnly(True)
                 
                 # Trigger initial style
                 self._update_header_counts()
                 
            else: # Pilar (default)
                self._add_linked_row(h_layout, "Dimens√£o:", "dim", "text")
                self._add_linked_row(h_layout, "Segmentos:", "pilar_segs", "poly", hide_input=True)
                
                # Formato (Apenas Pilar)
                self.fields['format'] = QComboBox()
                self.fields['format'].addItems(["Retangular", "Circular", "Em L", "Em T", "Em U"])
                self.fields['format'].setCurrentText(self.item_data.get('format', 'Retangular'))
                self.fields['format'].setFixedHeight(24)
                self.fields['format'].setStyleSheet("background: #252525; border: 1px solid #444; border-radius: 3px; color: #eee;")
                self.fields['format'].currentTextChanged.connect(lambda txt: self._on_field_changed('format', txt))
                h_layout.addRow("Formato:", self.fields['format'])
            
            layout.addWidget(header)

        # Container para conte√∫do din√¢mico (Abas que mudam com o formato)
        self.dynamic_container = QWidget()
        self.dynamic_layout = QVBoxLayout(self.dynamic_container)
        self.dynamic_layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.dynamic_container, 1) # Give stretch factor to expand

        # Inicializa conte√∫do din√¢mico
        self._refresh_dynamic_content()
        
        # Conecta sinal de mudan√ßa de formato (se existir)
        if 'format' in self.fields:
            self.fields['format'].currentTextChanged.connect(self._on_format_changed)

        layout.addLayout(self._create_action_buttons())
        scroll.setWidget(container)
        main_layout.addWidget(scroll)
        
        # Garante aplica√ß√£o de estilos de valida√ß√£o ap√≥s toda UI estar pronta
        self.refresh_validation_styles()

    # ... (keeps existing helper methods until _setup_laje_complex_view)

    def _setup_laje_complex_view(self, layout):
        tabs = QTabWidget()
        tabs.setStyleSheet("""
            QTabBar::tab { padding: 8px 20px; font-weight: bold; }
            QTabWidget::pane { border: 1px solid #444; }
        """)
        
        tab = QWidget()
        l = QVBoxLayout(tab)
        l.setSpacing(10)
        
        # --- DADOS GERAIS (Exclusivo para Laje aqui dentro) ---
        grp = QGroupBox("DADOS GERAIS - LAJE")
        grp.setStyleSheet("QGroupBox { font-size: 11px; font-weight: bold; border: 1px solid #444; margin-top: 5px; padding-top: 10px; color: #00ffcc; }")
        form = QFormLayout(grp)
        form.setSpacing(5)
        
        # Campos principais movidos para c√°
        self._add_linked_row(form, "N¬∫ Item:", "id_item", "text", show_links=False, show_focus=False)
        self._add_linked_row(form, "Nome:", "name", "text")
        self._add_linked_row(form, "Dimens√£o:", "laje_dim", "text")
        self._add_linked_row(form, "N√≠vel (ex: +2.80):", "laje_nivel", "text")
        self._add_linked_row(form, "Segmentos da √Årea:", "laje_outline_segs", "poly", hide_input=True)
        self._add_linked_row(form, "Contorno da Ilha:", "laje_islands", "poly", hide_input=True)

        if "laje_dim" in self.fields:
             self.fields["laje_dim"].textChanged.connect(lambda t: self._clean_laje_dim_input(t))
        
        l.addWidget(grp)
        l.addStretch() # Empurrar tudo para cima
        
        tabs.addTab(tab, "Laje")
        layout.addWidget(tabs)

    def _setup_pilar_complex_view(self, layout):
        tabs = QTabWidget()
        tabs.setStyleSheet("QTabBar::tab { padding: 5px; font-size: 10px; }")
        shape = self.fields['format'].currentText()
        
        sides = ['A', 'B', 'C', 'D']
        if shape == "Circular": sides = ["Superior", "Inferior"]
        elif shape == "Em L": sides = ['A', 'B', 'C', 'D', 'E', 'F']
        elif shape in ["Em T", "Em U"]: sides = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

        for side in sides:
            tab = QWidget()
            tab_l = QVBoxLayout(tab)
            tab_l.setContentsMargins(5, 5, 5, 5)
            tab_l.setSpacing(2)
            
            # Lajes - Layout Vertical (Laje 2 abaixo da Laje 1) para compactar largura
            for i in [1, 2]:
                grp = QGroupBox(f"Laje {i}")
                grp.setStyleSheet("QGroupBox { font-size: 10px; font-weight: bold; border: 1px solid #333; margin-top: 5px; padding-top: 5px; }")
                f = QFormLayout(grp)
                f.setSpacing(1)
                f.setContentsMargins(2, 5, 2, 2)
                self._add_linked_row(f, "Nome da Laje:", f'p_s{side}_l{i}_n', "text")
                self._add_linked_row(f, "Altura / Espessura (H):", f'p_s{side}_l{i}_h', "text")
                self._add_linked_row(f, "N√≠vel da Laje:", f'p_s{side}_l{i}_v', "text")
                
                # Ajuste Laje 2: Pos. -> Laje central e op√ß√µes Esquerda/Direita
                if i == 2:
                    self._add_linked_row(f, "Posi√ß√£o da Laje C:", f'p_s{side}_l{i}_p', "text", is_combo=True, combo_items=["Esquerda", "Direita"])
                else:
                    self._add_linked_row(f, "Posi√ß√£o da Laje:", f'p_s{side}_l{i}_p', "text", is_combo=True, combo_items=["Topo", "Centro", "Fundo"])
                
                self._add_linked_row(f, "Dist√¢ncia ao Centro:", f'p_s{side}_l{i}_dist_c', "poly")
                
                # Novo Campo Laje 2: Dist. do Topo
                if i == 2:
                    self._add_linked_row(f, "Dist√¢ncia ao Topo:", f'p_s{side}_l{i}_dist_t', "poly") 
                
                # Inicializa√ß√£o de visibilidade
                self._on_position_changed(f'p_s{side}_l{i}_p', self.fields[f'p_s{side}_l{i}_p'].currentText())
                
                tab_l.addWidget(grp)

            # Categorias de Vigas
            beam_categories = [
                ("Viga de Contorno Esquerda", "esq", False),
                ("Viga de Contorno Direita", "dir", False),
                ("Viga de Chegada 1", "ch1", True),
                ("Viga de Chegada 2", "ch2", True),
                ("Viga de Chegada 3", "ch3", True)
            ]
            
            for cat_name, cat_id, is_arrival in beam_categories:
                v_grp = QGroupBox(cat_name)
                v_grp.setStyleSheet("QGroupBox { font-size: 10px; color: #0078D4; border: 1px solid #333; margin-top: 10px; padding-top: 5px; }")
                vf = QFormLayout(v_grp)
                vf.setSpacing(1)
                vf.setContentsMargins(2, 5, 2, 2)
                
                id_pref = f'p_s{side}_v_{cat_id}'
                self._add_linked_row(vf, "Nome da Viga:", f'{id_pref}_n', "text")
                self._add_linked_row(vf, "Dimens√£o (B x H):", f'{id_pref}_d', "text")
                self._add_linked_row(vf, "Segmentos Geometria:", f'{id_pref}_segs', "poly", hide_input=True)
                if is_arrival:
                    self._add_linked_row(vf, "Dist√¢ncia Face:", f'{id_pref}_dist', "poly")
                
                # Profundidade sem link, auto-calculado
                self._add_linked_row(vf, "Profundidade (Auto):", f'{id_pref}_prof', "text", show_links=False)
                
                # Auto-update logic
                dim_widget = self.fields[f'{id_pref}_d']
                prof_widget = self.fields[f'{id_pref}_prof']
                dim_widget.textChanged.connect(lambda t, w=prof_widget: self._update_depth_from_dim(t, w))
                
                self._add_linked_row(vf, "Dif. N√≠vel:", f'{id_pref}_diff_v', "text")
                tab_l.addWidget(v_grp)
                
            tabs.addTab(tab, f"Lado {side}")
            
        layout.addWidget(tabs)

    def _update_depth_from_dim(self, text, target_widget):
        """Calcula profundidade (maior valor) baseado no texto de dimens√£o (ex: '15x40')"""
        import re
        try:
            # Busca n√∫meros, suportando decimais com ponto ou v√≠rgula
            nums = [float(n.replace(',', '.')) for n in re.findall(r'\d+[.,]?\d*', text)]
            if len(nums) >= 2:
                # Se tiver pelo menos 2 n√∫meros (ex: 15 e 40), pega o maior
                max_val = max(nums)
                # Formata removendo .0 se for inteiro
                txt_val = f"{int(max_val)}" if max_val.is_integer() else f"{max_val}"
                target_widget.setText(txt_val)
        except Exception:
            pass

    def _setup_viga_complex_view(self, layout):
        """Implementa detalhamento rigoroso de Lado A, Lado B e Fundo"""
        tabs = QTabWidget()
        sides_config = [('A', 'Lado A', False), ('B', 'Lado B', False), ('Fundo', 'Fundo', True)]
        
        for side, label, is_bottom in sides_config:
            tab = QWidget()
            tab_l = QVBoxLayout(tab)
            tab_l.setSpacing(15)
            tab_l.setContentsMargins(5, 5, 5, 5)
            
            prefix = f"viga_{side.lower()}"

            if not is_bottom:
                # Container de Segmentos Rica
                segs_container = QWidget()
                segs_layout = QVBoxLayout(segs_container)
                segs_layout.setContentsMargins(0,0,0,0)
                segs_layout.setSpacing(15)
                tab_l.addWidget(segs_container)
                
                # L√≥gica de Carga:
                existing_indices = set([1]) # Sempre garanta pelo menos o 1
                for key in self.item_data.keys():
                    if key.startswith(f"{prefix}_seg_"):
                        try:
                            parts = key.split('_')
                            idx = int(parts[parts.index('seg') + 1])
                            existing_indices.add(idx)
                        except: pass
                
                for i in sorted(list(existing_indices)):
                    self._add_rich_segment_pack(segs_layout, prefix, i)
                    
                # Bot√£o Add
                btn_add = QPushButton(" + Adicionar Segmento Completo")
                btn_add.setFixedHeight(30)
                btn_add.setStyleSheet("background: #004444; color: #00ffcc; border: 1px dashed #00ffcc; font-weight: bold; font-size: 11px;")
                btn_add.setCursor(Qt.PointingHandCursor)
                btn_add.clicked.connect(lambda checked=False, l=segs_layout, p=prefix: self._add_rich_segment_pack(l, p))
                tab_l.addWidget(btn_add)

            else:
                # Layout Din√¢mico para Fundo (Segmentos Fundo)
                segs_container = QWidget()
                segs_layout = QVBoxLayout(segs_container)
                segs_layout.setContentsMargins(0,0,0,0)
                segs_layout.setSpacing(15)
                tab_l.addWidget(segs_container)
                
                # Carga de Segmentos Existentes
                existing_indices = set([1]) # Sempre garanta pelo menos o 1
                for key in self.item_data.keys():
                    if key.startswith(f"{prefix}_seg_"):
                        try:
                            parts = key.split('_')
                            idx = int(parts[parts.index('seg') + 1])
                            existing_indices.add(idx)
                        except: pass
                
                for i in sorted(list(existing_indices)):
                    self._add_fundo_segment_pack(segs_layout, prefix, i)
                
                # Bot√£o Adicionar Segmento Fundo
                btn_add = QPushButton(" + Adicionar Segmento Fundo")
                btn_add.setFixedHeight(30)
                btn_add.setStyleSheet("background: #440044; color: #ff88ff; border: 1px dashed #ff88ff; font-weight: bold; font-size: 11px;")
                btn_add.setCursor(Qt.PointingHandCursor)
                btn_add.clicked.connect(lambda checked=False, l=segs_layout, p=prefix: self._add_fundo_segment_pack(l, p))
                tab_l.addWidget(btn_add)
            
            tabs.addTab(tab, label)
            
        layout.addWidget(tabs)

    def _add_rich_segment_pack(self, layout, prefix, idx_override=None):
        """Cria um Box Completo de Segmento com todos os campos de engenharia"""
        
        # Determinar √≠ndice
        if idx_override:
            idx = idx_override
        else:
            # Contagem baseada nos widgets visuais para sequencia logica
            idx = layout.count() + 1
            
            # Garantir exist√™ncia no item_data para detec√ß√£o externa
            marker_key = f"{prefix}_seg_{idx}_exists"
            if marker_key not in self.item_data:
                self.item_data[marker_key] = True
                # Emitir sinal para atualizar UI principal imediatamente
                self.data_changed.emit(self.item_data)
            
        seg_uid = f"{prefix}_seg_{idx}"
        
        # Grupo Principal do Segmento
        pack = QGroupBox(f"Segmento {idx}")
        # Estilo "Gigante" e vis√≠vel
        pack.setStyleSheet("""
            QGroupBox { 
                font-size: 12px; 
                font-weight: bold; 
                border: 2px solid #555; 
                border-radius: 6px;
                margin-top: 10px; 
                padding-top: 15px; 
                background: #1e1e1e;
            }
            QGroupBox::title {
                color: #00ffcc;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 3px 0 3px;
            }
        """)
        
        # Layout principal do pack
        main_v = QVBoxLayout(pack)
        main_v.setSpacing(10)
        
        # 1. Campos de Geometria (FormLayout)
        form_w = QWidget()
        form = QFormLayout(form_w)
        form.setSpacing(4)
        form.setContentsMargins(2,2,2,2)
        
        # Determinar lado (A ou B) baseado no prefixo
        # prefix pode ser "viga_a", "viga_b" ou "viga_fundo"
        # Este m√©todo s√≥ √© chamado para lados A e B (n√£o para fundo)
        if prefix == "viga_a":
            side_label = "A"
        elif prefix == "viga_b":
            side_label = "B"
        else:
            side_label = ""  # Fallback (n√£o deveria acontecer neste m√©todo)
        
        # 1. Comprimento Total (Renomeado para "A-comp. total viga para" ou "B-comp. total viga para")
        # Adicionar round buttons de sele√ß√£o √∫nica entre "passa" e "para"
        row_layout = QHBoxLayout()
        row_layout.setContentsMargins(0, 0, 0, 0)
        
        # Round button "Para"
        rb_para = QRadioButton("Para")
        rb_para.setObjectName(f'{seg_uid}_tipo_comp_para')
        rb_para.setStyleSheet("QRadioButton { font-size: 10px; color: #ccc; padding: 2px; }")
        
        # Round button "Passa"
        rb_passa = QRadioButton("Passa")
        rb_passa.setObjectName(f'{seg_uid}_tipo_comp_passa')
        rb_passa.setStyleSheet("QRadioButton { font-size: 10px; color: #ccc; padding: 2px; }")
        
        # ButtonGroup para garantir sele√ß√£o √∫nica
        btn_group = QButtonGroup()
        btn_group.addButton(rb_para, 0)  # 0 = Para
        btn_group.addButton(rb_passa, 1)  # 1 = Passa
        
        # Carregar estado salvo
        tipo_comp_key = f'{seg_uid}_tipo_comp'
        tipo_salvo = self.item_data.get(tipo_comp_key, 'para')  # Default: 'para'
        if tipo_salvo == 'passa':
            rb_passa.setChecked(True)
        else:
            rb_para.setChecked(True)
        
        # Conectar mudan√ßas para salvar
        def on_tipo_changed(checked):
            if checked:
                tipo = 'passa' if btn_group.checkedId() == 1 else 'para'
                self.item_data[tipo_comp_key] = tipo
                self._on_field_changed(tipo_comp_key, tipo)
        
        rb_para.toggled.connect(on_tipo_changed)
        rb_passa.toggled.connect(on_tipo_changed)
        
        # Armazenar refer√™ncias para atualiza√ß√£o externa
        if not hasattr(self, '_tipo_comp_buttons'):
            self._tipo_comp_buttons = {}
        self._tipo_comp_buttons[seg_uid] = {
            'group': btn_group,
            'rb_para': rb_para,
            'rb_passa': rb_passa,
            'key': tipo_comp_key
        }
        
        row_layout.addWidget(rb_para)
        row_layout.addWidget(rb_passa)
        row_layout.addStretch()
        
        # Adicionar row ao form
        form.addRow("Tipo:", row_layout)
        
        # 2. Campo "Comprimento Viga Para"
        self._add_linked_row(form, "Comprimento Viga Para:", f'{seg_uid}_comprimento_total', "poly")
        
        # 3. Campo "Comprimento Viga Passa"
        self._add_linked_row(form, "Comprimento Viga Passa:", f'{seg_uid}_comp_total_passa', "poly")
        
        # 4. Campo "Ajuste Comprimento"
        # Agora puramente manual, sem bot√µes de a√ß√£o (Task_02)
        self._add_linked_row(form, "Ajuste Comprimento:", f'{seg_uid}_ajuste_comprimento', "text", 
                             show_links=False, show_focus=False, show_validate=False, show_na=False)
        
        # 5. Vis√£o de Corte
        self._add_linked_row(form, "Vis√£o de Corte (Se√ß√£o Transversal):", f'{seg_uid}_visao_corte', "group", hide_input=True)
        
        # 3. Campos de Apoio
        self._add_linked_row(form, "Apoio Inicial (Viga/Pilar):", f'{seg_uid}_ini_name', "text")
        self._add_linked_row(form, "Apoio Final (Viga/Pilar):", f'{seg_uid}_end_name', "text")
        
        # 4. Campos Principais
        self._add_linked_row(form, "N√≠vel da Viga (Este Lado):", f'{seg_uid}_nivel_viga', "text")
        self._add_linked_row(form, "N√≠vel da Viga (Lado Oposto):", f'{seg_uid}_nivel_oposto', "text")
        
        # Lajes
        self._add_linked_row(form, "Laje Superior (Adjacente):", f'{seg_uid}_laje_sup', "text")
        self._add_linked_row(form, "Laje Central (Recorte):", f'{seg_uid}_laje_cen', "text")
        self._add_linked_row(form, "Laje Inferior (Adjacente):", f'{seg_uid}_laje_inf', "text")
        
        # Dimens√£o da Viga (B x H) - Movido para acima das Alturas
        self._add_linked_row(form, "Dimens√£o da Viga (B x H):", f'{seg_uid}_dim', "text")

        # Alturas
        self._add_linked_row(form, "Altura Paineis Laterais H1:", f'{seg_uid}_h1', "text")
        self._add_linked_row(form, "Altura Paineis Laterais H2:", f'{seg_uid}_h2', "text")
        
        # 2. Modos de Painel (Radio Groups) - Lado a Lado
        modes_layout = QHBoxLayout()
        modes_layout.setSpacing(5)
        h1_opts = ["Sarrafo", "Garfo", "Grade"]
        modes_layout.addWidget(self._create_radio_group("Modo Painel H1", h1_opts, f"{seg_uid}_mode_h1", has_grade_input=True))
        
        h2_opts = ["Sarrafo", "Garfo", "Grade"]
        modes_layout.addWidget(self._create_radio_group("Modo Painel H2", h2_opts, f"{seg_uid}_mode_h2", has_grade_input=True))
        main_v.addLayout(modes_layout)
        
        # 3. Continuidade (Radio)
        cont_opts = ["Obst√°culo", "Viga", "√öltimo Seg."]
        main_v.addWidget(self._create_radio_group("Configura√ß√£o de Continuidade", cont_opts, f"{seg_uid}_continuidade"))
        
        # 4. Sarrafos (Checkbox Grid)
        sarrafos_opts = [
            ("Vertical Esq H1", "v_e_h1"), ("Press√£o Esq H1", "p_e_h1"),
            ("Vertical Esq H2", "v_e_h2"), ("Press√£o Esq H2", "p_e_h2"),
            ("Vertical Dir H1", "v_d_h1"), ("Press√£o Dir H1", "p_d_h1"),
            ("Vertical Dir H2", "v_d_h2"), ("Press√£o Dir H2", "p_d_h2")
        ]
        cb_group = self._create_checkbox_group("Detalhamento de Sarrafos e Travamento", sarrafos_opts, seg_uid)
        main_v.addWidget(cb_group)

        # 1. Campos de Engenharia (FormLayout)
        main_v.addWidget(form_w)
        
        # Aberturas (TABELAS) - Agora abaixo de tudo
        self._add_pillar_openings_table(main_v, f'{seg_uid}_abert_pilar_esq', f'{seg_uid}_abert_pilar_dir')
        self._add_beam_openings_table(main_v, f'{seg_uid}_abert_viga_top_esq', f'{seg_uid}_abert_viga_top_dir', 
                                      f'{seg_uid}_abert_viga_fun_esq', f'{seg_uid}_abert_viga_fun_dir')
        
        # Bot√£o Remover (se n√£o for o segmento 1, ou permitir remover todos?)
        # Geralmente segmento 1 √© obrigat√≥rio, mas vamos permitir flexibilidade
        if idx > 1:
            btn_rem = QPushButton("Remover Este Segmento")
            btn_rem.setStyleSheet("color: #ff5555; background: transparent; border: 1px solid #ff5555; border-radius: 4px; padding: 4px;")
            btn_rem.setCursor(Qt.PointingHandCursor)
            btn_rem.clicked.connect(lambda: self._remove_segment(pack, layout, prefix, idx))
            main_v.addWidget(btn_rem)
            
        layout.addWidget(pack)
    
    def update_all_tipo_comp_buttons(self, tipo: str):
        """
        Atualiza todos os round buttons de tipo de comprimento (passa/para) para o tipo especificado.
        tipo: 'passa' ou 'para'
        """
        if not hasattr(self, '_tipo_comp_buttons'):
            return
        
        for seg_uid, button_data in self._tipo_comp_buttons.items():
            btn_group = button_data['group']
            key = button_data['key']
            
            # Atualizar estado do bot√£o (bloquear sinais temporariamente para evitar loops)
            button_data['rb_para'].blockSignals(True)
            button_data['rb_passa'].blockSignals(True)
            
            if tipo == 'passa':
                button_data['rb_passa'].setChecked(True)
            else:
                button_data['rb_para'].setChecked(True)
            
            button_data['rb_para'].blockSignals(False)
            button_data['rb_passa'].blockSignals(False)
            
            # Salvar no item_data
            self.item_data[key] = tipo
            self._on_field_changed(key, tipo)

    def _add_fundo_segment_pack(self, layout, prefix, idx_override=None):
        """Cria um Box Completo de Segmento de Fundo"""
        
        # Determinar √≠ndice
        if idx_override:
            idx = idx_override
        else:
            idx = layout.count() + 1
            
            # Garantir exist√™ncia no item_data para detec√ß√£o externa
            marker_key = f"{prefix}_seg_{idx}_exists"
            if marker_key not in self.item_data:
                self.item_data[marker_key] = True
                self.data_changed.emit(self.item_data)

        seg_uid = f"{prefix}_seg_{idx}"
        
        # Grupo Principal do Segmento
        pack = QGroupBox(f"Segmento Fundo {idx}")
        # Estilo "Gigante" e vis√≠vel (Mesmo estilo do side)
        pack.setStyleSheet("""
            QGroupBox { 
                font-size: 12px; 
                font-weight: bold; 
                border: 2px solid #5544aa; 
                border-radius: 6px;
                margin-top: 10px; 
                padding-top: 15px; 
                background: #1e1e22;
            }
            QGroupBox::title {
                color: #aa88ff;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 3px 0 3px;
            }
        """)
        
        # Layout principal do pack
        main_v = QVBoxLayout(pack)
        main_v.setSpacing(10)
        
        # 1. Campos de Engenharia (FormLayout)
        form_w = QWidget()
        form = QFormLayout(form_w)
        form.setSpacing(4)
        form.setContentsMargins(2,2,2,2)
        
        # Campos Solicitados
        self._add_linked_row(form, "Segmentos de √Årea (Geometria):", f'{seg_uid}_area_segs', "poly", hide_input=True)
        
        # Dimens√£o (Movido dos Dados Gerais para c√°)
        self._add_linked_row(form, "Dimens√£o:", "dim", "text")
        
        self._add_linked_row(form, "Largura Total do Fundo:", f'{seg_uid}_largura', "text")
        self._add_linked_row(form, "Comprimento Total do Fundo:", f'{seg_uid}_comprimento', "poly")
        self._add_linked_row(form, "Localiza√ß√£o Inicial (Ref.):", f'{seg_uid}_local_ini', "text", hide_input=True)
        self._add_linked_row(form, "Localiza√ß√£o Final (Ref.):", f'{seg_uid}_local_fim', "text", hide_input=True)
        
        self._add_linked_row(form, "Abertura Especial (Personalizada):", f'{seg_uid}_abert_especial', "poly")
        
        # Chanfros
        self._add_linked_row(form, "Chanfro Esquerda Topo:", f'{seg_uid}_chanfro_esq_top', "poly")
        self._add_linked_row(form, "Chanfro Esquerda Fundo:", f'{seg_uid}_chanfro_esq_fun', "poly")
        self._add_linked_row(form, "Chanfro Direita Topo:", f'{seg_uid}_chanfro_dir_top', "poly")
        self._add_linked_row(form, "Chanfro Direita Fundo:", f'{seg_uid}_chanfro_dir_fun', "poly")
        
        main_v.addWidget(form_w)

        # Aberturas (TABELA) - Agora ap√≥s todos os campos
        self._add_beam_openings_table(main_v, f'{seg_uid}_abert_top_esq', f'{seg_uid}_abert_top_dir', 
                                      f'{seg_uid}_abert_fun_esq', f'{seg_uid}_abert_fun_dir')
        
        # 2. Continuidade (Radio)
        cont_opts_fundo = ["Obst√°culo", "Recorte", "√öltimo Seg."]
        main_v.addWidget(self._create_radio_group("Continuidade (Fundo)", cont_opts_fundo, f"{seg_uid}_continuidade"))
        
        # Bot√£o Remover
        if idx > 1:
            btn_rem = QPushButton("Remover Este Segmento")
            btn_rem.setStyleSheet("color: #ff5555; background: transparent; border: 1px solid #ff5555; border-radius: 4px; padding: 4px;")
            btn_rem.setCursor(Qt.PointingHandCursor)
            btn_rem.clicked.connect(lambda: self._remove_segment(pack, layout, prefix, idx))
            main_v.addWidget(btn_rem)
            
        layout.addWidget(pack)


    def _create_radio_group(self, title, options, key_prefix, has_grade_input=False):
        """Cria um grupo de op√ß√µes exclusivas (Sarrafo/Garfo/Grade) - Super Compacto"""
        grp = QGroupBox(title)
        grp.setStyleSheet("QGroupBox { font-size: 9px; font-weight: bold; border: 1px solid #333; padding-top: 5px; margin-top: 2px; }")
        l = QHBoxLayout(grp)
        l.setContentsMargins(4, 10, 4, 1) # Margens m√≠nimas em Y
        l.setSpacing(8)
        
        bg = QButtonGroup(grp) # Garante exclusividade l√≥gica
        self.fields[f"{key_prefix}_bg"] = bg # Mant√©m ref para n√£o ser garbage collected
        
        # Valor atual salvo
        current_val = self.item_data.get(key_prefix, options[0])
        
        for opt in options:
            rb = QRadioButton(opt)
            rb.setStyleSheet("QRadioButton { font-size: 10px; color: #ccc; }")
            if opt == current_val: rb.setChecked(True)
            bg.addButton(rb)
            l.addWidget(rb)
            
            # Se for op√ß√£o "Grade" e tiver input ativado
            if has_grade_input and "Grade" in opt:
                grade_input = QLineEdit()
                grade_input.setPlaceholderText("Tam. Grade (cm)")
                grade_input.setFixedHeight(20)
                grade_input.setStyleSheet(self.STYLE_DEFAULT)
                
                # Chave para salvar tamanho da grade
                grade_key = f"{key_prefix}_grade_size"
                self.fields[grade_key] = grade_input
                grade_input.setText(str(self.item_data.get(grade_key, "")))
                
                # Visibilidade condicional
                grade_input.setVisible(rb.isChecked())
                rb.toggled.connect(grade_input.setVisible)
                
                l.addWidget(grade_input)
                
        # Conectar mudan√ßa do grupo para atualizar data (opcional, pois validamos no final)
        # bg.buttonClicked.connect(lambda btn: self.item_data.update({key_prefix: btn.text()}))
        
        return grp

    def _create_checkbox_group(self, title, options, key_prefix):
        """Cria Grid de Checkboxes compacta para Sarrafos (4 colunas)"""
        grp = QGroupBox(title)
        grp.setStyleSheet("QGroupBox { font-size: 11px; border: 1px solid #444; padding-top: 5px; }")
        
        grid = QGridLayout()
        grid.setContentsMargins(5, 12, 5, 5)
        grid.setSpacing(5)
        
        # Mapeamento para grid 4x2
        # Op√ß√µes v√™m em ordem: Esq H1, Esq H1, Esq H2, Esq H2, Dir H1...
        # Vamos usar l√≥gica de sufixo para posicionar
        for label, suffix in options:
            cb = QCheckBox(label)
            cb.setStyleSheet("QCheckBox { font-size: 10px; color: #ccc; }")
            full_key = f"{key_prefix}_chk_{suffix}"
            self.fields[full_key] = cb
            if self.item_data.get(full_key, False): cb.setChecked(True)
            
            # L√≥gica de posicionamento (Compacta)
            row = 0 if 'h1' in suffix else 1
            col = 0
            if 'v_e' in suffix: col = 0
            elif 'p_e' in suffix: col = 1
            elif 'v_d' in suffix: col = 2
            elif 'p_d' in suffix: col = 3
            
            grid.addWidget(cb, row, col)
            
        grp.setLayout(grid)
        return grp


    def _remove_segment(self, widget, layout, prefix, idx):
        """Remove visualmente e limpa refer√™ncias"""
        widget.hide()
        layout.removeWidget(widget)
        widget.deleteLater()
        
        # Limpar do self.fields para n√£o ser salvo novamente
        keys_to_remove = [k for k in self.fields.keys() if k.startswith(f"{prefix}_seg_{idx}")]
        for k in keys_to_remove:
            del self.fields[k]
        
        # Removendo imediatamente do item_data para garantir consist√™ncia visual x dados
        keys_data_remove = [k for k in self.item_data.keys() if k.startswith(f"{prefix}_seg_{idx}")]
        for k in keys_data_remove:
            del self.item_data[k]
            
        self.data_changed.emit(self.item_data)


    def _get_initial_value(self, field_id):
        """Busca valor, priorizando links > sides_data > flat_key"""
        
        # 1. Prioridade: Valor do V√≠nculo (Se existir e for Texto/Line validado)
        links = self.item_data.get('links', {})
        if field_id in links:
            slots = links[field_id]
            if isinstance(slots, dict):
                 # L√≥gica especial para campos de comprimento que usam polyline
                 # Calcular comprimento se for campo comp_total_passa ou comprimento_total
                 if 'comp_total_passa' in field_id or '_comprimento_total' in field_id:
                     # Procurar por slots com pontos (polyline)
                     for slot_id, s_list in slots.items():
                         if s_list and len(s_list) > 0:
                             link_obj = s_list[0]
                             pts = link_obj.get('points', [])
                             if len(pts) >= 2:
                                 # Calcular comprimento total da polyline
                                 length = sum(((pts[i][0]-pts[i+1][0])**2 + (pts[i][1]-pts[i+1][1])**2)**0.5 for i in range(len(pts)-1))
                                 # Salvar no item_data para persist√™ncia
                                 self.item_data[field_id] = f"{length:.0f}"
                                 return f"{length:.0f}"
                 
                 # L√≥gica padr√£o para outros campos
                 for s_list in slots.values():
                     if s_list and len(s_list) > 0:
                         txt = str(s_list[0].get('text', ''))
                         if txt.strip(): 
                             # Somente extrair n√∫mero se N√ÉO for campo de nome ou dimens√£o
                             is_dim_or_name = "dim" in field_id or "name" in field_id or field_id.endswith("_n") or field_id.endswith("_d")
                             if not is_dim_or_name:
                                 import re
                                 nums = re.findall(r'\d+[.,]?\d*', txt)
                                 if nums:
                                     return nums[0].replace(',', '.')
                             return txt
            elif isinstance(slots, list) and len(slots) > 0:
                 # L√≥gica especial para campos de comprimento (polyline)
                 if 'comp_total_passa' in field_id or '_comprimento_total' in field_id:
                     link_obj = slots[0]
                     pts = link_obj.get('points', [])
                     if len(pts) >= 2:
                         length = sum(((pts[i][0]-pts[i+1][0])**2 + (pts[i][1]-pts[i+1][1])**2)**0.5 for i in range(len(pts)-1))
                         self.item_data[field_id] = f"{length:.0f}"
                         return f"{length:.0f}"
                 
                 txt = str(slots[0].get('text', ''))
                 if txt.strip(): 
                     is_dim_or_name = "dim" in field_id or "name" in field_id or field_id.endswith("_n") or field_id.endswith("_d")
                     if not is_dim_or_name:
                         import re
                         nums = re.findall(r'\d+[.,]?\d*', txt)
                         if nums:
                             return nums[0].replace(',', '.')
                     return txt

        # 2. Prioridade: Flat Key
        if field_id in self.item_data:
            return self.item_data[field_id]
        
        # 3. Prioridade: Nested Data (sides_data)
        if field_id.startswith('p_s'):
            try:
                parts = field_id.split('_', 2) 
                if len(parts) >= 3:
                    side = parts[1][1:] 
                    key = parts[2]
                    sides = self.item_data.get('sides_data', {})
                    side_content = sides.get(side, {})
                    return side_content.get(key)
            except Exception: pass
            
        return None

    def _create_action_buttons(self):
        # Layout Vertical para economizar largura no painel
        v = QVBoxLayout()
        v.setContentsMargins(0, 5, 0, 0)
        v.setSpacing(5)

        btn_valid = QPushButton("VALIDAR (TREINAR IA)")
        btn_valid.setObjectName("Success")
        btn_valid.setCursor(Qt.PointingHandCursor)
        btn_valid.setFixedHeight(35) # Altura menor
        btn_valid.setToolTip("Salva e treina o padr√£o atual no banco de dados")
        btn_valid.clicked.connect(self.on_validate)

        btn_invalid = QPushButton("MARCAR FALHA")
        btn_invalid.setObjectName("Danger")
        btn_invalid.setCursor(Qt.PointingHandCursor)
        btn_invalid.setFixedHeight(35) # Altura menor
        btn_invalid.setToolTip("Marca este item para revis√£o manual posterior")
        btn_invalid.clicked.connect(self.on_invalidate)

        v.addWidget(btn_valid)
        v.addWidget(btn_invalid)
        
        return v

    def on_validate(self):
        final_data = self.item_data.copy()
        validated = final_data.setdefault('validated_fields', [])
        
        # Ensure sides_data exists
        if 'sides_data' not in final_data: final_data['sides_data'] = {}
        
        for key, widget in self.fields.items():
            if isinstance(widget, QLineEdit): val = widget.text()
            elif isinstance(widget, QComboBox): val = widget.currentText()
            else: continue
            
            final_data[key] = val
            # Ao validar o card todo, todos os campos preenchidos ganham selo de validado
            if val and key not in validated:
                validated.append(key)
        
        # [NOVO] SELO AZUL (Valida√ß√£o Completa de Contexto)
        # S√≥ este bot√£o concede o status de "Item 100% Validado" para curadoria
        final_data['is_fully_validated'] = True
        
        self.refresh_validation_styles()
            
        self.data_validated.emit(final_data)
        QMessageBox.information(self, "IA Training", "Dados enviados para o banco de padr√µes! (Selo Azul)")

    def on_invalidate(self):
        self.data_invalidated.emit(self.item_data)
        QMessageBox.warning(self, "IA Training", "Item marcado para revis√£o manual.")

    def _on_format_changed(self, text):
        """Reage √† mudan√ßa no ComboBox de formato"""
        self.item_data['format'] = text
        self._refresh_dynamic_content()

    def _refresh_dynamic_content(self):
        """Reconstr√≥i a √°rea din√¢mica baseada no tipo e formato atual"""
        self._clear_dynamic_content()
        
        elem_type = self.item_data.get('type', '').lower()
        if 'pilar' in elem_type:
            # Garante que usamos o layout din√¢mico
            self._setup_pilar_complex_view(self.dynamic_layout)
        elif 'viga' in elem_type:
            self._setup_viga_complex_view(self.dynamic_layout)
        elif 'laje' in elem_type:
            self._setup_laje_complex_view(self.dynamic_layout)
        elif 'marcodxf' in elem_type:
            self._setup_marco_view(self.dynamic_layout)

    def _clear_dynamic_content(self):
        """Remove widgets din√¢micos e limpa refer√™ncias no self.fields"""
        # Identifica campos que pertencem ao container din√¢mico para remover do self.fields
        to_remove = []
        for key, widget in self.fields.items():
            if self._is_descendant(widget, self.dynamic_container):
                to_remove.append(key)
        
        for k in to_remove:
            del self.fields[k]
            
        # Remove widgets do layout
        while self.dynamic_layout.count():
            item = self.dynamic_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                # Se for um layout aninhado, precisamos limpar recursivamente ou deletar o item
                # Layouts em Qt n√£o s√£o widgets, mas items layout.
                # O ideal √© que tudo esteja dentro de widgets.
                # Como usamos .addWidget(tabs), tabs √© um widget.
                pass

    def _is_descendant(self, widget, ancestor):
        """Verifica se widget √© descendente de ancestor (para limpeza segura)"""
        p = widget
        while p:
            if p == ancestor: return True
            p = p.parentWidget()
        return False

    def _clean_laje_dim_input(self, text):
        """Limpa entrada de dimens√£o de laje (ex: 'd=12' -> '12')"""
        import re
        # Se tiver d= ou h=, extrai o n√∫mero
        match = re.search(r'[dhDH]=\s*(\d+[.,]?\d*)', text)
        if match:
             clean_val = match.group(1)
             # Evita loop infinito
             current = self.fields['laje_dim'].text()
             if current != clean_val:
                  self.fields['laje_dim'].blockSignals(True)
                  self.fields['laje_dim'].setText(clean_val)
                  self.fields['laje_dim'].blockSignals(False)
                  # Atualiza dados
                  self._on_field_changed('laje_dim', clean_val)

    def _setup_marco_view(self, layout_container):
        """View em formato de Tabela (Grid) para o Tratamento Pr√©vio do Marco"""
        from PySide6.QtWidgets import QGridLayout, QFrame
        
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)
        
        lbl_head = QLabel("üõ†Ô∏è TRATAMENTO PR√âVIO - PER√çMETRO")
        lbl_head.setStyleSheet("font-size: 13px; font-weight: bold; color: #00d4ff;")
        layout.addWidget(lbl_head)

        vigas = self.item_data.get('vigas_individuais', [])
        
        if not vigas:
            layout.addWidget(QLabel("Nenhuma viga de extremidade detectada."))
        else:
            # Header da "Tabela"
            header_frame = QFrame()
            header_frame.setStyleSheet("background: #222; border-bottom: 1px solid #444;")
            h_lay = QHBoxLayout(header_frame)
            h_lay.setContentsMargins(5, 5, 5, 5)
            
            lbl_ref = QLabel("Refer√™ncia"); lbl_ref.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_tam = QLabel("Tamanho"); lbl_tam.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_lnk = QLabel("A√ß√µes"); lbl_lnk.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_val = QLabel("Soma (cm)"); lbl_val.setStyleSheet("font-weight: bold; color: #aaa;")
            
            h_lay.addWidget(lbl_ref, 2)
            h_lay.addWidget(lbl_tam, 2)
            h_lay.addWidget(lbl_lnk, 2) 
            h_lay.addWidget(lbl_val, 2)
            layout.addWidget(header_frame)

            # Lista de Itens (Rows)
            for v in vigas:
                v_id = v.get('id')
                field_key = f"ext_viga_{v_id}"
                
                row_container = QFrame()
                row_container.setStyleSheet("border-bottom: 1px solid #222;")
                row_v_lay = QVBoxLayout(row_container)
                row_v_lay.setContentsMargins(0, 0, 0, 0)
                row_v_lay.setSpacing(0)
                
                # Linha de Dados
                data_row = QWidget()
                dr_lay = QHBoxLayout(data_row)
                dr_lay.setContentsMargins(5, 4, 5, 4) # Mais margem
                
                # 1. Refer√™ncia
                lbl_v_id = QLabel(f"Viga_{v_id[:4]}")
                lbl_v_id.setStyleSheet("color: #ddd; font-weight: bold;")
                dr_lay.addWidget(lbl_v_id, 2)
                
                # 2. Tamanho (Original)
                dr_lay.addWidget(QLabel(f"{v.get('original_len', 0):.1f}"), 2)
                
                # 3. Bloco de Bot√µes (Compacto: √çcones Ajustados)
                btns_widget = QWidget()
                btns_lay = QHBoxLayout(btns_widget)
                btns_lay.setContentsMargins(0, 0, 0, 0)
                btns_lay.setSpacing(4)
                
                drawer = QWidget()
                drawer.hide()
                drawer.setStyleSheet("background: #141414; border-left: 3px solid #00d4ff; margin: 2px; border-radius: 2px;")
                
                # Bot√£o ZOOM
                btn_zoom = QPushButton("üîç")
                btn_zoom.setFixedSize(24, 24)
                btn_zoom.setCursor(Qt.PointingHandCursor)
                btn_zoom.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #ffca28; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(100, 100, 100, 255); border: 1px solid #ffca28; }
                """)
                btn_zoom.clicked.connect(lambda checked=False, f=field_key: self.focus_requested.emit(f))
                
                # Bot√£o VINC
                btn_link = QPushButton("üîó")
                btn_link.setFixedSize(24, 24)
                btn_link.setCursor(Qt.PointingHandCursor)
                btn_link.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #00d4ff; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(100, 100, 100, 255); border: 1px solid #00d4ff; }
                """)
                btn_link.clicked.connect(lambda checked=False, f=field_key, d=drawer: self._toggle_link_drawer(f, d))
                
                # Bot√£o EXCL
                btn_del = QPushButton("‚úñ")
                btn_del.setFixedSize(24, 24)
                btn_del.setCursor(Qt.PointingHandCursor)
                btn_del.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #ff5252; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(220, 50, 50, 255); border: 1px solid #ff5252; }
                """)
                btn_del.clicked.connect(lambda checked=False, vid=v_id, cont=row_container: self._remove_marco_row(vid, cont))
                
                btns_lay.addWidget(btn_zoom)
                btns_lay.addWidget(btn_link)
                btns_lay.addWidget(btn_del)
                dr_lay.addWidget(btns_widget, 2)
                
                # 4. Campo Valor
                ext_val = v.get('extension_len', 10.0)
                display_val = "10.0"
                if isinstance(ext_val, (int, float)):
                     display_val = f"{ext_val:.1f}"
                elif isinstance(ext_val, str) and ext_val.replace('.','',1).isdigit():
                     display_val = ext_val
                else: 
                     display_val = "10.0" # Fallback se vier lixo (ex: 'Polyline...')

                val_edit = QLineEdit(display_val)
                val_edit.setFixedWidth(60)
                val_edit.setAlignment(Qt.AlignCenter)
                val_edit.setStyleSheet("""
                    QLineEdit { 
                        background: #181818; border: 1px solid #333; color: #00e676; 
                        font-weight: bold; border-radius: 4px; font-size: 12px; padding: 2px;
                    }
                    QLineEdit:focus { border: 1px solid #00e676; background: #202020; }
                """)
                val_edit.textChanged.connect(lambda t, k=field_key: self._on_field_changed(k, t))
                self.fields[field_key] = val_edit
                
                dr_lay.addWidget(val_edit, 2)
                
                row_v_lay.addWidget(data_row)
                row_v_lay.addWidget(drawer)
                layout.addWidget(row_container)

        # Bot√£o Adicionar Nova Viga
        btn_add = QPushButton("‚ûï ADICIONAR VIGA MANUAL")
        btn_add.setStyleSheet("""
            QPushButton { background: #1a3a5a; color: #00d4ff; border: 1px dashed #00d4ff; padding: 8px; font-weight: bold; margin-top: 10px; border-radius: 4px;}
            QPushButton:hover { background: #2a5a8a; border-style: solid; }
        """)
        btn_add.clicked.connect(self._add_manual_marco_row)
        layout.addWidget(btn_add)

        # Uni√µes do Marco (Separado)
        group_uniao = QGroupBox("FECHAMENTO DO MARCO (UNI√ïES PONTAS)")
        group_uniao.setStyleSheet("QGroupBox { font-size: 11px; font-weight: bold; color: #ffb300; border: 1px solid #333; margin-top: 20px; padding-top: 15px; }")
        uniao_layout = QFormLayout(group_uniao)
        self._add_linked_row(uniao_layout, "Uni√µes Marco:", "unioes_marco", pick_type='poly', hide_input=True)
        layout.addWidget(group_uniao)
        
        layout.addStretch()
        layout_container.addWidget(container)

    def _remove_marco_row(self, v_id, container):
        """Remove uma viga da lista de extremidades e limpa seus v√≠nculos"""
        # Exclus√£o direta conforme solicitado
        vigas = self.item_data.get('vigas_individuais', [])
        self.item_data['vigas_individuais'] = [v for v in vigas if v.get('id') != v_id]
        
        # Limpar v√≠nculos do campo
        field_key = f"ext_viga_{v_id}"
        if 'links' in self.item_data and field_key in self.item_data['links']:
            del self.item_data['links'][field_key]
        
        if field_key in self.fields:
            del self.fields[field_key]
        
        # Remover widget
        container.deleteLater()
        
        # Sincronizar mudan√ßa externamente
        self.data_changed.emit(self.item_data)
        self.refresh_validation_styles()

    def _add_manual_marco_row(self):
        """Adiciona manualmente uma nova viga √† lista de tratamento pr√©vio"""
        new_id = str(uuid.uuid4())[:8]
        new_viga = {
            'id': new_id,
            'type': 'line',
            'points': [],
            'text': f'Viga_{new_id[:4]}',
            'original_len': 0.0,
            'extension_len': 10.0,
            'final_len': 10.0
        }
        
        if 'vigas_individuais' not in self.item_data:
            self.item_data['vigas_individuais'] = []
            
        self.item_data['vigas_individuais'].append(new_viga)
        
        # Iniciar links vazios para ela (Main = Viga Total, Default = Segmento Ajuste)
        if 'links' not in self.item_data: self.item_data['links'] = {}
        self.item_data['links'][f"ext_viga_{new_id}"] = {'main': [], 'default': []}
        
        # Feedback visual removido para dinamismo
    def _on_slot_na_toggled(self, field_id, slot_id, is_na):
        """Gerencia o N/A de um slot espec√≠fico (Classe de V√≠nculo)"""
        na_slots_map = self.item_data.setdefault('na_link_classes', {})
        na_list = na_slots_map.setdefault(field_id, [])
        
        if is_na:
            if slot_id not in na_list: na_list.append(slot_id)
            # Limpar links deste slot
            if 'links' in self.item_data and field_id in self.item_data['links']:
                field_links = self.item_data['links'][field_id]
                if isinstance(field_links, dict) and slot_id in field_links:
                    print(f"[DEBUG HIERARCHY] Slot '{slot_id}' marked N/A. Clearing {len(field_links[slot_id])} links.")
                    field_links[slot_id] = []
            # Limpar valida√ß√£o se marcar N/A
            valid_map = self.item_data.get('validated_link_classes', {})
            if field_id in valid_map and slot_id in valid_map[field_id]:
                valid_map[field_id].remove(slot_id)
            
            # Emitir Treino para N/A da Classe
            self.training_requested.emit(field_id, {
                'status': 'na',
                'comment': f"Usu√°rio marcou classe {slot_id} como N/A",
                'slot': slot_id
            })
        else:
            if slot_id in na_list: na_list.remove(slot_id)
            print(f"[DEBUG HIERARCHY] Slot '{slot_id}' unmarked N/A.")
            
        print(f"[DetailCard] Slot NA toggled: {field_id} -> {slot_id} = {is_na}")
        self.data_changed.emit(self.item_data)
        self.refresh_validation_styles()

    def _on_slot_validated(self, field_id, slot_id, checked=True):
        """Gerencia valida√ß√£o (ou undo) de uma classe/slot espec√≠fica"""
        valid_map = self.item_data.setdefault('validated_link_classes', {})
        if field_id not in valid_map: valid_map[field_id] = []
        
        if checked:
            if slot_id not in valid_map[field_id]:
                valid_map[field_id].append(slot_id)
            
            # Cascata: Validar todos os links internos
            links_dict = self.item_data.get('links', {})
            field_links = links_dict.get(field_id, {})
            if isinstance(field_links, dict) and slot_id in field_links:
                for lk in field_links[slot_id]:
                    # Treinar como v√°lido se ainda n√£o for
                    if not lk.get('validated'):
                         self.training_requested.emit(field_id, {
                             'slot': slot_id, 'link': lk, 'status': 'valid'
                         })
                    lk['validated'] = True
                    lk.pop('failed', None)
        else:
            # UNDO SLOT
            self.undo_slot_validation(field_id, slot_id)

        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def undo_slot_validation(self, field_id, slot_id):
        """Remove a valida√ß√£o de um slot e seus v√≠nculos (Undo)"""
        # 1. Remover do mapa de validados
        valid_map = self.item_data.get('validated_link_classes', {})
        if field_id in valid_map and slot_id in valid_map[field_id]:
            valid_map[field_id].remove(slot_id)

        # 2. Resetar links internos e pedir REMO√á√ÉO de treino
        links_dict = self.item_data.get('links', {})
        field_links = links_dict.get(field_id, {})
        if isinstance(field_links, dict) and slot_id in field_links:
            for lk in field_links[slot_id]:
                # S√≥ pedimos remo√ß√£o se estava validado/erro (para n√£o limpar o que j√° estava limpo)
                if lk.get('validated') or lk.get('failed'):
                    self.training_requested.emit(field_id, {
                        'slot': slot_id, 'link': lk, 'status': 'removed'
                    })
                lk.pop('validated', None)
                lk.pop('failed', None)
        
        # Se LM aberto, refresh
        if field_id in self.embedded_managers:
            self.embedded_managers[field_id].refresh_list()

    def undo_field_validation(self, field_id):
        """Desfaz toda a valida√ß√£o de um campo (Undo de alto n√≠vel)"""
        validated = self.item_data.get('validated_fields', [])
        if field_id in validated:
            validated.remove(field_id)
        
        # Cascata para Slots
        valid_map = self.item_data.get('validated_link_classes', {})
        if field_id in valid_map:
            slots_to_undo = list(valid_map[field_id]) # C√≥pia para iterar
            for s_id in slots_to_undo:
                self.undo_slot_validation(field_id, s_id)
        
        # Reset visual
        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)
        self.log_requested.emit(f"üîÑ Valida√ß√£o do campo '{field_id}' desfeita.")

    def _on_slot_na_toggled(self, field_id, slot_id, is_na):
        """Gerencia o estado 'N√£o se Aplica' para um slot/classe espec√≠fica"""
        na_map = self.item_data.setdefault('na_link_classes', {})
        if field_id not in na_map: na_map[field_id] = []
        
        if is_na:
            if slot_id not in na_map[field_id]:
                na_map[field_id].append(slot_id)
            
            # Limpa v√≠nculos desse slot
            links_dict = self.item_data.get('links', {})
            field_links = links_dict.get(field_id, {})
            if isinstance(field_links, dict) and slot_id in field_links:
                field_links[slot_id] = []
            
            # Treinar como N/A
            self.training_requested.emit(field_id, {
                'status': 'na',
                'comment': f"Slot '{slot_id}' marcado como N/A pelo usu√°rio.",
                'slot': slot_id
            })
        else:
            if slot_id in na_map[field_id]:
                na_map[field_id].remove(slot_id)
            
            # Undo N/A Treino
            self.training_requested.emit(field_id, {
                'status': 'removed',
                'slot': slot_id,
                'link': {'text': 'N/A'}
            })

        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def _refresh_dynamic_content(self):
        """Atualiza o conte√∫do din√¢mico (abas/campos) baseado no tipo e formato do item"""
        if not hasattr(self, 'dynamic_layout') or self.dynamic_layout is None:
            return
            
        # Limpar conte√∫do anterior do layout din√¢mico
        while self.dynamic_layout.count():
            item = self.dynamic_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
            elif item.layout():
                self._clear_layout_recursive(item.layout())
        
        itype = self.item_data.get('type', '').lower()
        if 'pilar' in itype: 
            self._setup_pilar_complex_view(self.dynamic_layout)
        elif 'viga' in itype: 
            self._setup_viga_complex_view(self.dynamic_layout)
        elif 'laje' in itype: 
            self._setup_laje_complex_view(self.dynamic_layout)
            
        # Garante que os estilos de valida√ß√£o se apliquem aos novos widgets criados
        self.refresh_validation_styles()

    def _clear_layout_recursive(self, layout):
        if not layout: return
        while layout.count():
            item = layout.takeAt(0)
            w = item.widget()
            if w: w.deleteLater()
            elif item.layout(): self._clear_layout_recursive(item.layout())

    def _add_pillar_openings_table(self, container_layout, key_esq, key_dir):
        """M√≥dulo de Aberturas de Pilares em formato de Tabela com Link no final"""
        grp = QGroupBox("Aberturas em Pilares (Esq / Dir)")
        grp.setStyleSheet("""
            QGroupBox { border: 1px solid #444; border-radius: 6px; margin-top: 10px; padding-top: 15px; background: #1a1a1e; }
            QGroupBox::title { color: #00d4ff; subcontrol-origin: margin; left: 10px; }
        """)
        
        layout = QVBoxLayout(grp)
        layout.setSpacing(5)

        # Header da Tabela
        grid = QGridLayout()
        grid.setSpacing(5)
        
        headers = ["Lado", "Dist√¢ncia (cm)", "Largura (cm)", "A√ß√µes"]
        for col, h in enumerate(headers):
            lbl = QLabel(h)
            lbl.setStyleSheet("font-size: 10px; font-weight: bold; color: #888;")
            grid.addWidget(lbl, 0, col)

        # Linha Pilar Esquerdo
        grid.addWidget(QLabel("ESQUERDO"), 1, 0)
        f_dist_e = self._create_opening_field(key_esq, "dist", "0.0", 60)
        f_larg_e = self._create_opening_field(key_esq, "larg", "0.0", 60)
        grid.addWidget(f_dist_e, 1, 1)
        grid.addWidget(f_larg_e, 1, 2)
        
        # A√ß√µes Pilar Esquerdo
        actions_e, drawer_e = self._create_action_buttons_for_row(key_esq)
        grid.addWidget(actions_e, 1, 3)
        grid.addWidget(drawer_e, 2, 0, 1, 4) # Span 4 cols

        # Linha Pilar Direito
        grid.addWidget(QLabel("DIREITO"), 3, 0)
        f_dist_d = self._create_opening_field(key_dir, "dist", "0.0", 60)
        f_larg_d = self._create_opening_field(key_dir, "larg", "0.0", 60)
        grid.addWidget(f_dist_d, 3, 1)
        grid.addWidget(f_larg_d, 3, 2)
        
        # A√ß√µes Pilar Direito
        actions_d, drawer_d = self._create_action_buttons_for_row(key_dir)
        grid.addWidget(actions_d, 3, 3)
        grid.addWidget(drawer_d, 4, 0, 1, 4)

        layout.addLayout(grid)
        container_layout.addWidget(grp)

    def _add_beam_openings_table(self, container_layout, k_top_e, k_top_d, k_fun_e, k_fun_d):
        """M√≥dulo de Aberturas de Vigas em formato de Tabela"""
        grp = QGroupBox("Aberturas em Vigas (Topo / Fundo)")
        grp.setStyleSheet("""
            QGroupBox { border: 1px solid #444; border-radius: 6px; margin-top: 10px; padding-top: 15px; background: #1a1a1e; }
            QGroupBox::title { color: #ffca28; subcontrol-origin: margin; left: 10px; }
        """)
        
        layout = QVBoxLayout(grp)
        layout.setSpacing(5)
        
        grid = QGridLayout()
        grid.setSpacing(4)
        grid.setVerticalSpacing(8)
        
        headers = ["Posi√ß√£o", "Profundidade", "Boca/Largura", "Ref. (H)", "A√ß√µes"]
        for col, h in enumerate(headers):
            lbl = QLabel(h)
            lbl.setAlignment(Qt.AlignCenter)
            lbl.setStyleSheet("font-size: 9px; font-weight: bold; color: #666; text-transform: uppercase;")
            grid.addWidget(lbl, 0, col)

        # Configura√ß√£o das 4 linhas solicitadas
        rows_config = [
            ("TOPO / ESQ.", k_top_e),
            ("TOPO / DIR.", k_top_d),
            ("FUNDO / ESQ.", k_fun_e),
            ("FUNDO / DIR.", k_fun_d)
        ]

        for i, (label, key) in enumerate(rows_config):
            row_idx = (i * 2) + 1 # 1, 3, 5, 7 (para dar lugar ao drawer)
            
            # Label de Posi√ß√£o
            lbl_pos = QLabel(label)
            lbl_pos.setStyleSheet("font-size: 10px; color: #aaa; font-weight: bold;")
            grid.addWidget(lbl_pos, row_idx, 0, Qt.AlignVCenter)
            
            f_prof = self._create_opening_field(key, "prof", "0.0", 65)
            f_boca = self._create_opening_field(key, "boca", "0.0", 65)
            h_sel = self._create_h_selector(key)
            
            grid.addWidget(f_prof, row_idx, 1, Qt.AlignCenter)
            grid.addWidget(f_boca, row_idx, 2, Qt.AlignCenter)
            grid.addWidget(h_sel, row_idx, 3, Qt.AlignCenter)
            
            # A√ß√µes
            actions_w, drawer_w = self._create_action_buttons_for_row(key)
            grid.addWidget(actions_w, row_idx, 4)
            grid.addWidget(drawer_w, row_idx + 1, 0, 1, 5) # Span 5 cols

        layout.addLayout(grid)
        container_layout.addWidget(grp)

    def _create_opening_field(self, prefix, suffix, placeholder, width):
        """Helper para criar mini-fields para as tabelas"""
        f = QLineEdit()
        f.setPlaceholderText(placeholder)
        if width > 0: f.setFixedWidth(width)
        f.setStyleSheet(self.STYLE_DEFAULT)
        
        full_key = f"{prefix}_{suffix}"
        self.fields[full_key] = f
        
        val = self._get_initial_value(full_key)
        if val: f.setText(str(val))
        
        f.textChanged.connect(lambda t, k=full_key: self._on_field_changed(k, t))
        return f

    def _create_h_selector(self, key_prefix):
        """Cria seletor H1/H2 compacto para tabela"""
        widget = QWidget()
        l = QHBoxLayout(widget)
        l.setContentsMargins(0,0,0,0)
        l.setSpacing(5)
        
        bg = QButtonGroup(widget)
        rb1 = QRadioButton("H1"); rb2 = QRadioButton("H2")
        rb1.setStyleSheet("font-size: 10px; color: #ccc;")
        rb2.setStyleSheet("font-size: 10px; color: #ccc;")
        
        full_key = f"{key_prefix}_h_sel"
        current = self.item_data.get(full_key, "H1")
        if current == "H2": rb2.setChecked(True)
        else: rb1.setChecked(True)
        
        bg.addButton(rb1); bg.addButton(rb2)
        l.addWidget(rb1); l.addWidget(rb2)
        
        rb1.toggled.connect(lambda checked: self._on_field_changed(full_key, "H1") if checked else None)
        rb2.toggled.connect(lambda checked: self._on_field_changed(full_key, "H2") if checked else None)
        
        return widget

    def _create_action_buttons_for_row(self, field_id):
        """Helper para criar o bloco de bot√µes de a√ß√£o e o drawer LinkManager para uma linha de tabela"""
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # Drawer
        drawer = QWidget()
        drawer.hide()
        drawer.setStyleSheet("background: #141418; border-top: 1px solid #444; margin-top: 2px;")

        # Bot√£o Vincular
        btn_link = QPushButton("Vinc.")
        btn_link.setFixedSize(40, 22)
        btn_link.setProperty("class", "FieldBtn")
        btn_link.setCursor(Qt.PointingHandCursor)
        btn_link.setToolTip("Vincular / Gerenciar")
        btn_link.setStyleSheet("font-size: 10px; font-weight: bold; padding: 0px;")
        btn_link.clicked.connect(lambda: self._toggle_link_drawer(field_id, drawer))
        layout.addWidget(btn_link)

        # Bot√£o Validar
        btn_valid = QPushButton("Ok")
        btn_valid.setFixedSize(30, 22)
        btn_valid.setCheckable(True)
        btn_valid.setChecked(field_id in self.item_data.get('validated_fields', []))
        btn_valid.setProperty("class", "FieldBtn")
        btn_valid.setCursor(Qt.PointingHandCursor)
        btn_valid.setStyleSheet("""
            QPushButton { font-size: 10px; font-weight: bold; padding: 0px; }
            QPushButton:checked { color: #4CAF50; border-color: #4CAF50; }
        """)
        btn_valid.clicked.connect(lambda checked, f_id=field_id: self._on_express_validate(f_id))
        layout.addWidget(btn_valid)

        # Bot√£o Zoom
        btn_zoom = QPushButton("Zoom")
        btn_zoom.setFixedSize(35, 22)
        btn_zoom.setProperty("class", "FieldBtn")
        btn_zoom.setCursor(Qt.PointingHandCursor)
        btn_zoom.setStyleSheet("font-size: 10px; font-weight: bold; padding: 0px;")
        btn_zoom.clicked.connect(lambda checked=False, f_id=field_id: self.focus_requested.emit(f_id))
        layout.addWidget(btn_zoom)

        # Bot√£o N/A
        btn_na = QPushButton("N/A")
        btn_na.setFixedSize(30, 22)
        btn_na.setCheckable(True)
        btn_na.setChecked(field_id in self.item_data.get('na_fields', []))
        btn_na.setProperty("class", "FieldBtn")
        btn_na.setCursor(Qt.PointingHandCursor)
        btn_na.setStyleSheet("""
            QPushButton { font-size: 10px; font-weight: bold; padding: 0px; }
            QPushButton:checked { color: #f44336; border-color: #f44336; }
        """)
        btn_na.clicked.connect(lambda chk, f_id=field_id: self._on_na_clicked(f_id, chk))
        layout.addWidget(btn_na)

        # Registrar no mapa para atualiza√ß√µes de estilo
        self.action_btns[field_id] = {
            'link': btn_link,
            'express': btn_valid,
            'focus': btn_zoom,
            'na': btn_na
        }

        return container, drawer
