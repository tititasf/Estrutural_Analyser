
# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofusca√ß√£o (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit"))))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo"))))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo"))))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key"))))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id"))))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils"))))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://"))))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com"))))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script"))))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

import uuid
import math
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                                QTabWidget, QTableWidget, QTableWidgetItem, 
                                QPushButton, QHeaderView, QFrame, QMessageBox,
                                QLineEdit, QFormLayout, QScrollArea, QComboBox, QGroupBox, QSizePolicy,
                                QRadioButton, QCheckBox, QButtonGroup, QGridLayout, QInputDialog)
from PySide6.QtCore import Qt, Signal
from .link_manager import LinkManager
from src.ui.widgets.interpretation_dialog import InterpretationDialog

class DetailCard(QWidget):
    """
    Ficha T√©cnica Master - Interface Especialista e Rotulagem de IA.
    Configurada para Pilares (Lados A-H), Vigas (Segmentos A/B) e Lajes.
    """
    data_validated = Signal(dict)
    data_invalidated = Signal(dict)
    element_focused = Signal(object) # (str para nome ou dict para link direto)
    element_removed = Signal(dict)   # (dict com slot e link removido)
    pick_requested = Signal(str, str) # (field_id, type)
    focus_requested = Signal(str)    # (field_id) disparado pelo bot√£o de lupa
    research_requested = Signal(str, str) # field_id, slot_id
    training_requested = Signal(str, dict) # field_id, train_data
    config_updated = Signal(str, list)      # field_key, slots_config
    data_changed = Signal(dict)           # (dict) disparado quando qualquer dado muda (nome, dim, etc)
    
    # Estilos CSS Reutiliz√°veis
    STYLE_DEFAULT = "background: #252525; border: 1px solid #444; padding: 4px 6px; border-radius: 4px; color: #eee; font-size: 13px;"
    STYLE_VALID = "background: #252525; border: 1px solid #00cc66; padding: 4px 6px; border-radius: 4px; color: #eee; font-size: 13px; font-weight: bold;"
    STYLE_NA = "background: #333311; border: 1px solid #ffd600; padding: 4px 6px; border-radius: 4px; color: #ffd600; font-size: 13px; font-style: italic;"

    def __init__(self, item_data: dict, parent=None):
        super().__init__(parent)
        self.item_data = item_data
        
        # FIX: Migra√ß√£o de chave legada (segments -> pilar_segs)
        if self.item_data.get('type') == 'Pilar':
            l = self.item_data.get('links', {})
            if l and 'segments' in l and 'pilar_segs' not in l:
                l['pilar_segs'] = l.pop('segments')
            
            # FIX 2: Migra√ß√£o interna (main -> segments) para bater com LinkManager config
            if l and 'pilar_segs' in l:
                ps = l['pilar_segs']
                if 'main' in ps and 'segments' not in ps:
                    ps['segments'] = ps.pop('main')

        self.fields = {} 
        self.indicators = {} 
        self.action_btns = {} # field_id -> { 'link': btn, 'focus': btn, 'na': btn, 'express': btn }
        self.embedded_managers = {} 
        self.init_ui()

    def _add_linked_row(self, layout, label_text, field_id, pick_type='text', is_combo=False, combo_items=None, 
                        show_links=True, show_focus=True, hide_input=False, show_validate=True):
        
        w = None
        btn_links = None
        btn_focus = None
        if not hide_input:
            if is_combo:
                w = QComboBox()
                if combo_items: w.addItems(combo_items)
                w.setFixedHeight(22)
                w.setMinimumWidth(20)
                w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
                if "Pos." in label_text: # L√≥gica especial para posi√ß√£o da laje
                    w.currentTextChanged.connect(lambda t: self._on_position_changed(field_id, t))
            else:
                w = QLineEdit()
                w.setFixedHeight(22)
                w.setMinimumWidth(20)
                w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
                
            w.setStyleSheet(self.STYLE_DEFAULT if field_id not in self.item_data.get('validated_fields', []) else self.STYLE_VALID)
            self.fields[field_id] = w
            
            # Conectar mudan√ßa imediata para refletir nas listas do MainWindow
            if is_combo:
                w.currentTextChanged.connect(lambda txt: self._on_field_changed(field_id, txt))
            else:
                w.textChanged.connect(lambda txt: self._on_field_changed(field_id, txt))
            
            # Tentar carregar valor inicial
            initial_val = self._get_initial_value(field_id)
            if initial_val is not None:
                if is_combo: w.setCurrentText(str(initial_val))
                else: w.setText(str(initial_val))
        else:
            # Placeholder invis√≠vel ou label para campos sem input de texto (como apenas segmentos)
            w = QLabel("V√≠nculo Pendente")
            w.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
            self.fields[field_id] = w
            
            # Tentar carregar valor inicial (se houver extra√ß√£o de texto autom√°tica)
            initial_val = self._get_initial_value(field_id)
            
            # Se j√° tiver v√≠nculos, mostrar contagem (Fallback)
            links = self.item_data.get('links', {}).get(field_id, {})
            count = 0
            if isinstance(links, dict):
                for sl_links in links.values(): count += len(sl_links)
            elif isinstance(links, list):
                count = len(links)
                
            if initial_val:
                w.setText(f"Dim: {initial_val}")
                w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")
            elif count > 0 and isinstance(w, QLabel):
                w.setText(f"{count} V√≠nculo(s) Ok")
                w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")

        # Sub-container for the drawer (inline LinkManager)
        drawer_container = QWidget()
        drawer_container.hide()
        drawer_container.setStyleSheet("""
            QWidget { background: #181818; border-left: 2px solid #00d4ff; margin-bottom: 5px; }
        """)

        if show_links:
            btn_links = QPushButton("üîó")
            btn_links.setFixedSize(28, 24)
            btn_links.setProperty("class", "FieldBtn")
            btn_links.setStyleSheet("font-size: 12px; padding: 2px;")
            btn_links.setCursor(Qt.PointingHandCursor)
            btn_links.setToolTip("Gerenciar V√≠nculos (Expandir)")
            btn_links.clicked.connect(lambda: self._toggle_link_drawer(field_id, drawer_container))

        if show_focus:
            btn_focus = QPushButton("üîç")
            btn_focus.setFixedSize(28, 24)
            btn_focus.setProperty("class", "FieldBtn")
            btn_focus.setStyleSheet("font-size: 12px; padding: 2px;")
            btn_focus.setCursor(Qt.PointingHandCursor)
            btn_focus.setToolTip("Localizar objeto no CAD")
            btn_focus.clicked.connect(lambda checked=False, f_id=field_id: self.focus_requested.emit(f_id))
        
        # --- LAYOUT HORIZONTAL √öNICO ---
        # Garante que tudo fique em UMA linha s√≥
        row_layout = QHBoxLayout()
        row_layout.setContentsMargins(0, 0, 0, 0)
        row_layout.setSpacing(1)

        # 1. Label (Largura reduzida para economizar espa√ßo horizontal)
        lbl = QLabel(label_text)
        lbl.setFixedWidth(65) 
        lbl.setWordWrap(True) 
        lbl.setStyleSheet("font-size: 10px; color: #ccc; font-weight: bold;")
        lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        row_layout.addWidget(lbl)

        # 2. Input Field (Flex√≠vel, stretch=1)
        # O input vai ocupar todo o espa√ßo que sobrar entre o label e os bot√µes
        if w:
            w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            w.setMinimumWidth(20) # Permite encolher bastante se necess√°rio
            row_layout.addWidget(w, stretch=1)
            
        # 3. Bloco de A√ß√µes (Fixo √† direita)
        actions_frame = QWidget()
        actions_layout = QHBoxLayout(actions_frame)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(1)
        
        # Indicador Confian√ßa
        conf_score = self.item_data.get('confidence_map', {}).get(field_id, 0.0)
        color = "#ff4444"
        if conf_score > 0.8: color = "#00c853"
        elif conf_score > 0.4: color = "#ffd600"
        
        conf_indicator = QLabel("‚óè")
        conf_indicator.setFixedSize(8, 20) # Altura compat√≠vel com bot√µes
        conf_indicator.setStyleSheet(f"color: {color}; font-size: 8px; margin-left: 2px;")
        actions_layout.addWidget(conf_indicator)
        
        if btn_links: 
            btn_links.setFixedSize(24, 20)
            actions_layout.addWidget(btn_links)
            
        if show_validate:
            # Bot√£o Express Validate (ao lado do link ou isolado)
            btn_express = QPushButton("‚úî")
            btn_express.setFixedSize(24, 20)
            btn_express.setProperty("class", "FieldBtn")
            btn_express.setCursor(Qt.PointingHandCursor)
            btn_express.setToolTip("Valida√ß√£o Express: Aceitar")
            # Estilo verde discreto
            btn_express.setStyleSheet("""
                QPushButton { color: #4CAF50; border: 1px solid #333; border-radius: 2px; }
                QPushButton:hover { background: #4CAF50; color: white; border: 1px solid #4CAF50; }
            """)
            btn_express.clicked.connect(lambda checked=False, f_id=field_id: self._on_express_validate(f_id))
            actions_layout.addWidget(btn_express)

        if btn_focus: 
            btn_focus.setFixedSize(24, 20)
            actions_layout.addWidget(btn_focus)

        # Bot√£o N/A (üö´)
        btn_na = QPushButton("üö´")
        btn_na.setFixedSize(24, 20)
        btn_na.setProperty("class", "FieldBtn")
        btn_na.setCursor(Qt.PointingHandCursor)
        btn_na.setToolTip("N√£o se aplica / Omitir")
        btn_na.setStyleSheet("""
            QPushButton { color: #f44336; border: 1px solid #333; border-radius: 2px; font-size: 10px; }
            QPushButton:hover { background: #f44336; color: white; }
            QPushButton:checked { background: #ffd600; color: #333; border: 1px solid #ffd600; }
        """)
        btn_na.setCheckable(True)
        btn_na.setChecked(field_id in self.item_data.get('na_fields', []))
        btn_na.clicked.connect(lambda chk, f_id=field_id: self._on_na_clicked(f_id, chk))
        actions_layout.addWidget(btn_na)
        
        # Guardar refer√™ncias para bloqueio reativo
        self.action_btns[field_id] = {
            'link': btn_links,
            'focus': btn_focus,
            'na': btn_na,
            'express': btn_express if 'btn_express' in locals() else None
        }

        row_layout.addWidget(actions_frame)

        # Adiciona a linha principal e o drawer (que come√ßa oculto)
        layout.addRow(row_layout)
        layout.addRow(drawer_container)

    def _on_position_changed(self, field_id, text):
        """Exibe campo de dist√¢ncia se for 'Centro' ou 'Laje central'"""
        dist_field_id = field_id.replace("_p", "_dist_c")
        if dist_field_id in self.fields:
            field_widget = self.fields[dist_field_id]
            visible = (text in ("Centro", "Esquerda", "Direita"))
            field_widget.setEnabled(visible)
            if not visible: field_widget.setText("0.0")
            field_widget.setVisible(True)

    def _toggle_link_drawer(self, field_id, container):
        """Toggles the inline LinkManager drawer"""
        if container.isVisible():
            container.hide()
        else:
            if container.layout() is None or container.layout().count() == 0:
                self._load_link_manager_into(field_id, container)
            
            # For√ßar atualiza√ß√£o de dados antes de exibir
            lm = self.embedded_managers.get(field_id)
            if lm:
                links_dict = self.item_data.get('links', {})
                current_links = links_dict.get(field_id, {})
                if isinstance(current_links, list): current_links = {'label': current_links}
                lm.links = current_links
                lm.refresh_list()
                
            container.show()

    def _load_link_manager_into(self, field_id, container):
        """Instantiates and embeds a LinkManager into the container"""
        # Ensure layout
        if not container.layout():
            layout = QVBoxLayout(container)
            layout.setContentsMargins(0,0,0,0)
            layout.setSpacing(0)
        
        # Get links
        links_dict = self.item_data.get('links', {})
        current_links = links_dict.get(field_id, {})
        if isinstance(current_links, list):
             # CONVERTER E SALVAR: Normaliza para dicion√°rio para manter refer√™ncia consistente
             # Isso corrige o bug onde o LinkManager operava num dict tempor√°rio e o remove_link falhava
             normalized_links = {'label': current_links}
             links_dict[field_id] = normalized_links
             current_links = normalized_links
             
        # New: Retrieve N/A and Validated Slots for this field
        na_slots_map = self.item_data.get('na_link_classes', {})
        current_na_slots = na_slots_map.get(field_id, [])
        
        valid_slots_map = self.item_data.get('validated_link_classes', {})
        current_valid_slots = valid_slots_map.get(field_id, [])
             
        # Create Manager
        lm = LinkManager(field_id, current_links, na_slots=current_na_slots, validated_slots=current_valid_slots, parent=self)
        self.embedded_managers[field_id] = lm
        
        # Connect Signals (Similar to original dialog logic)
        lm.pick_requested.connect(lambda slot_req: self._on_manager_pick_requested(field_id, slot_req))
        lm.focus_requested.connect(lambda l: self.element_focused.emit(l))
        lm.remove_requested.connect(lambda data: self._remove_link(field_id, data, lm))
        lm.research_requested.connect(lambda s_id: self.research_requested.emit(field_id, s_id))
        lm.training_requested.connect(lambda t_data: self.training_requested.emit(field_id, t_data))
        lm.config_changed.connect(lambda k, v: self.config_updated.emit(k, v))
        
        # New Signals for Hierarchy
        lm.slot_na_toggled.connect(lambda s_id, is_na: self._on_slot_na_toggled(field_id, s_id, is_na))
        lm.slot_validated.connect(lambda s_id: self._on_slot_validated(field_id, s_id))
        
        # --- NOVO: Conectar mudan√ßa de metadados de interpreta√ß√£o ---
        lm.metadata_changed.connect(lambda s_id, t_type, d: self._on_metadata_changed(field_id, s_id, t_type, d))
        
        # Injetar metadados existentes para carregar o cache do LM
        if 'field_metadata' in self.item_data:
            # Estrutura esperada: item_data['field_metadata'][field_id][slot_id] = {prompt, patterns}
            field_meta = self.item_data['field_metadata'].get(field_id, {})
            lm.metadata_cache = field_meta.copy() # Copia simples
        
        container.layout().addWidget(lm)

    def _on_metadata_changed(self, field_id, slot_id, meta_type, data):
        """Salva metadados vindos do LinkManager (n√≠vel de Slot)"""
        if 'field_metadata' not in self.item_data:
            self.item_data['field_metadata'] = {}
            
        if field_id not in self.item_data['field_metadata']:
            self.item_data['field_metadata'][field_id] = {}
            
        # Salva especificamente para o slot
        self.item_data['field_metadata'][field_id][slot_id] = data
        
        # Opcional: print debug
        print(f"[DetailCard] Metadados de {meta_type} atualizados para {field_id} -> {slot_id}")
        self.data_changed.emit(self.item_data)

    def _on_manager_pick_requested(self, field_id, slot_req):
        """Disparado quando um slot espec√≠fico pede captura no canvas"""
        self.pick_requested.emit(field_id, slot_req)

    def _remove_link(self, field_id, data, dlg):
        """data is a dict: {'slot': slot_id, 'link': link_obj}"""
        slot_id = data.get('slot')
        link = data.get('link')
        
        links_dict = self.item_data.get('links', {})
        field_links = links_dict.get(field_id, {})
        
        if slot_id in field_links:
            # REMO√á√ÉO ROBUSTA: LinkManager pode j√° ter removido da lista (mesma ref), 
            # ou pode ser uma c√≥pia.
            
            # 1. Tentar remover por identidade de objeto
            if link in field_links[slot_id]:
                field_links[slot_id].remove(link)
                print(f"[DetailCard] Link removido por refer√™ncia direta de {slot_id}.")
            else:
                 # 2. Remover por igualdade de conte√∫do (Fallback)
                 idx_to_remove = -1
                 for i, l in enumerate(field_links[slot_id]):
                     # Compara chaves essenciais para garantir que √© o mesmo v√≠nculo
                     same_text = l.get('text') == link.get('text')
                     same_type = l.get('type') == link.get('type')
                     same_pos = str(l.get('pos')) == str(link.get('pos')) # str compare to avoid float issues
                     same_pts = str(l.get('points')) == str(link.get('points'))
                     
                     if same_type and (same_text or same_pts): # Pelo menos tipo e um identificador
                         if same_pos: # Posi√ß√£o √© forte indicador
                             idx_to_remove = i
                             break
                 
                 if idx_to_remove >= 0:
                     del field_links[slot_id][idx_to_remove]
                     print(f"[DetailCard] Link removido por compara√ß√£o de valor de {slot_id}.")
                 else:
                     print(f"[DetailCard] AVISO: Link n√£o encontrado para remo√ß√£o em {slot_id} (Provavelmente removido pelo LinkManager?)")
                
            # SEMPRE executa limpeza visual e atualiza√ß√£o de labels
            if field_id in self.item_data.get('validated_fields', []):
                self.item_data['validated_fields'].remove(field_id)
            
            # Recalcular is_validated se necess√°rio
            if not self.item_data.get('validated_fields'):
                self.item_data['is_validated'] = False

            print(f"[DetailCard] V√≠nculo removido de {field_id}. Restantes: {len(field_links[slot_id]) if slot_id in field_links else 0}")
            self.refresh_validation_styles()
            
            # Notificar mudan√ßa de dados para sincronizar listas e canvas
            self.data_changed.emit(self.item_data)
            self.element_removed.emit({'slot': slot_id, 'link': link})
            dlg.refresh_list()

    def mark_field_validated(self, field_id, is_valid=True):
        """Aplica estilo visual de valida√ß√£o no widget do campo"""
        validated = self.item_data.setdefault('validated_fields', [])
        if is_valid:
            if field_id not in validated: validated.append(field_id)
            
            # --- CASCADE VALIDATION TO LINKS ---
            # Se o campo foi marcado como validado, validar todos os v√≠nculos internos
            if 'links' in self.item_data and field_id in self.item_data['links']:
                links_data = self.item_data['links'][field_id]
                if isinstance(links_data, dict):
                    # Marcar todas as classes como validadas
                    valid_map = self.item_data.setdefault('validated_link_classes', {})
                    valid_map[field_id] = list(links_data.keys())
                    
                    for slot_id, link_list in links_data.items():
                        for link in link_list:
                            link['validated'] = True
            
            # Atualiza LM se existir
            if field_id in self.embedded_managers:
                lm = self.embedded_managers[field_id]
                lm.links = self.item_data['links'].get(field_id, {})
                lm.validated_slots = set(self.item_data.get('validated_link_classes', {}).get(field_id, []))
                lm.refresh_list()
        else:
            if field_id in validated: validated.remove(field_id)
            
        print(f"[DEBUG HIERARCHY] Field '{field_id}' validation set to {is_valid}. Validated fields: {self.item_data.get('validated_fields', [])}")
        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def _on_na_clicked(self, field_id, checked):
        """Gerencia o estado 'N√£o se Aplica' de um campo com justificativa"""
        na_fields = self.item_data.setdefault('na_fields', [])
        na_reasons = self.item_data.setdefault('na_reasons', {})
        
        if checked:
            # Pedir justificativa
            reason, ok = QInputDialog.getText(self, "Justificativa N/A", 
                                            f"Por que o campo '{field_id}' n√£o se aplica?", 
                                            text=na_reasons.get(field_id, ""))
            if ok and reason.strip():
                na_reasons[field_id] = reason.strip()
                if field_id not in na_fields: na_fields.append(field_id)
                self.mark_field_validated(field_id, True)
                
                # --- CASCADE N/A TO SLOTS ---
                # Identificar e marcar todas as classes/slots como N/A tamb√©m
                if 'na_link_classes' not in self.item_data: self.item_data['na_link_classes'] = {}
                na_map = self.item_data['na_link_classes']
                
                slots_to_na = []
                # 1. Se LM existe, pega os slots oficiais
                if field_id in self.embedded_managers:
                    lm = self.embedded_managers[field_id]
                    slots_to_na = [s['id'] for s in lm._get_slots(field_id)]
                else:
                    # 2. LinkManager n√£o ativo: varre links existentes
                    current_links = self.item_data.get('links', {}).get(field_id, {})
                    if isinstance(current_links, dict):
                        slots_to_na = list(current_links.keys())
                
                # Marca todos
                na_map[field_id] = list(set(slots_to_na))
                
                # Limpa v√≠nculos (apenas conte√∫do, mantendo chaves)
                if 'links' in self.item_data and field_id in self.item_data['links']:
                    links_data = self.item_data['links'][field_id]
                    if isinstance(links_data, dict):
                        for k in links_data: links_data[k] = []
                    elif isinstance(links_data, list):
                        self.item_data['links'][field_id] = {}

                # Atualiza LM se existir
                if field_id in self.embedded_managers:
                    lm = self.embedded_managers[field_id]
                    lm.na_slots = set(slots_to_na)
                    lm.links = self.item_data['links'].get(field_id, {})
                    lm.refresh_list()
                
                # Visual Clean
                widget = self.fields.get(field_id)
                if widget:
                    if isinstance(widget, QLineEdit): widget.setText("N/A")
                    elif isinstance(widget, QComboBox):
                        idx = widget.findText("N/A")
                        if idx >= 0: widget.setCurrentIndex(idx)
                         
                print(f"[DEBUG HIERARCHY] Field '{field_id}' set to N/A. Reason: {reason}")
                print(f"[DEBUG HIERARCHY] Cascade N/A to slots: {slots_to_na}")
                self.data_changed.emit(self.item_data)

                # Emitir Treino para N/A (Aprendizado Negativo)
                self.training_requested.emit(field_id, {
                    'status': 'na',
                    'comment': f"Usu√°rio marcou campo como N/A: {reason}",
                    'slot': 'main'
                })
            else:
                # Cancelado ou vazio -> Reverte o bot√£o
                sender = self.sender() # O bot√£o que clicou
                if sender: sender.setChecked(False)
                return 
        else:
            if field_id in na_fields: na_fields.remove(field_id)
            if field_id in na_reasons: del na_reasons[field_id]
            print(f"[DEBUG HIERARCHY] Field '{field_id}' removed from N/A state.")
            
            # Restaurar valor
            widget = self.fields.get(field_id)
            if widget:
                if isinstance(widget, QLineEdit) and widget.text() == "N/A":
                    widget.setText("")
        
        self.refresh_validation_styles()
        self.data_changed.emit(self.item_data)

    def _on_express_validate(self, field_id):
        """Valida o campo imediatamente, enviando para treino"""
        widget = self.fields.get(field_id)
        if not widget: return
        
        val = ""
        if isinstance(widget, QLineEdit): val = widget.text()
        elif isinstance(widget, QComboBox): val = widget.currentText()
        
        # Recuperar links existentes para treino
        links = self.item_data.get('links', {}).get(field_id, {})
        if isinstance(links, list): links = {'label': links}
        
        target_link = None
        target_slot = 'default'
        
        # Busca primeiro link dispon√≠vel
        for slot, link_list in links.items():
            if link_list:
                target_link = link_list[0]
                target_slot = slot
                break
        
        if not target_link:
            # Cria synthetic link se n√£o houver
            target_link = {
                'text': val, 
                'type': 'text', 
                'pos': self.item_data.get('pos', (0,0)), 
                'debug': 'Express Validation'
            }
            
        # Emite sinal de treino para o campo principal (se aplicavel)
        if target_slot == 'default':
             self.training_requested.emit(field_id, {
                 'slot': target_slot,
                 'link': target_link,
                 'comment': "Expresso: Validado pelo usu√°rio",
                 'status': "valid",
                 'propagate': False
             })

        # --- SMART VALIDATION CASCADE ---
        # 1. Obter slots esperados para este campo
        expected_slots = []
        if field_id in self.embedded_managers:
             expected_slots = [s['id'] for s in self.embedded_managers[field_id]._get_slots(field_id)]
        else:
             # Inst√¢ncia tempor√°ria para obter configura√ß√£o
             try:
                 tmp = LinkManager(field_id, {}, parent=None)
                 expected_slots = [s['id'] for s in tmp._get_slots(field_id)]
                 tmp.deleteLater()
             except:
                 expected_slots = []

        # 2. Verificar conte√∫do e distribuir status
        if expected_slots:
             valid_map = self.item_data.setdefault('validated_link_classes', {})
             na_map = self.item_data.setdefault('na_link_classes', {})
             
             # Garante listas iniciadas
             if field_id not in valid_map: valid_map[field_id] = []
             if field_id not in na_map: na_map[field_id] = []
             
             current_links = self.item_data.get('links', {}).get(field_id, {})
             if isinstance(current_links, list): current_links = {'label': current_links} # Normalize
             
             for slot_id in expected_slots:
                 has_links = slot_id in current_links and len(current_links[slot_id]) > 0
                 
                 if has_links:
                     # Tem links -> Valida
                     if slot_id not in valid_map[field_id]: 
                         valid_map[field_id].append(slot_id)
                     if slot_id in na_map[field_id]:
                         na_map[field_id].remove(slot_id)
                         
                     # Treinar este slot como valido
                     self.training_requested.emit(field_id, {
                         'slot': slot_id,
                         'link': current_links[slot_id][0], # Usa o primeiro link como exemplo
                         'comment': f"Smart Validation: Slot {slot_id} validado.",
                         'status': "valid",
                         'propagate': False
                     })
                 else:
                     # Vazio -> Marca N/A (N√£o se aplica a este item)
                     if slot_id not in na_map[field_id]:
                         na_map[field_id].append(slot_id)
                     if slot_id in valid_map[field_id]:
                         valid_map[field_id].remove(slot_id)
                         
                     # Treinar este slot como N/A
                     self.training_requested.emit(field_id, {
                         'status': 'na',
                         'comment': f"Smart Validation: Slot {slot_id} vazio marcado como N/A",
                         'slot': slot_id
                     })
        
        # Marca e atualiza visual
        self.mark_field_validated(field_id, True)
        
        if self.embedded_managers.get(field_id):
            return

    def _add_pilar_opening_group(self, form_layout, label_text, prefix):
        """Creates a specialized grouped row for Pillar Openings (Clean List)"""
        # Outer container for the group
        group_container = QWidget()
        group_layout = QVBoxLayout(group_container)
        group_layout.setContentsMargins(0, 5, 0, 5)
        group_layout.setSpacing(2)

        # Header with Label + Link Button
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0,0,0,0)
        
        lbl = QLabel(label_text)
        lbl.setStyleSheet("font-size: 11px; color: #00bcd4; font-weight: bold;")
        
        # Drawer for Pillar
        drawer = QWidget()
        drawer.hide()
        drawer.setStyleSheet("background: #181818; border-left: 2px solid #00bcd4;")

        btn_link = QPushButton("üîó Vincular")
        btn_link.setCursor(Qt.PointingHandCursor)
        btn_link.setStyleSheet("""
            QPushButton { border: 1px solid #444; border-radius: 4px; background: #222; color: #aaa; padding: 2px 6px; font-size: 10px; }
            QPushButton:hover { background: #333; color: white; border-color: #666; }
        """)
        btn_link.clicked.connect(lambda: self._toggle_link_drawer(prefix, drawer))
        
        btn_focus = QPushButton("üîç")
        btn_focus.setFixedSize(24, 20)
        btn_focus.setCursor(Qt.PointingHandCursor)
        btn_focus.setStyleSheet("background: transparent; border: 1px solid #444; color: #aaa; font-size: 10px;")
        btn_focus.clicked.connect(lambda checked=False, p=prefix: self.focus_requested.emit(p))
        
        header_layout.addWidget(lbl)
        header_layout.addStretch()
        header_layout.addWidget(btn_focus)
        header_layout.addWidget(btn_link)
        
        group_layout.addWidget(header_widget)
        group_layout.addWidget(drawer) # Add drawer here too
        
        # Internal Form for Fields (Indented)
        form_inner_widget = QWidget()
        form_inner = QFormLayout(form_inner_widget)
        form_inner.setContentsMargins(5, 0, 0, 0) # Reduzido ident para caber melhor
        form_inner.setSpacing(1)
        form_inner.setLabelAlignment(Qt.AlignLeft)
        
        # Fields: Dist, Larg, Diff
        # Remove fixed width restrictions for cleaner look
        f_dist = self._create_sub_field(prefix, "dist", "", 0) 
        f_larg = self._create_sub_field(prefix, "larg", "", 0)
        f_diff = self._create_sub_field(prefix, "diff", "", 0)
        
        form_inner.addRow("Dist:", f_dist)
        form_inner.addRow("Larg:", f_larg)
        form_inner.addRow("Dif:", f_diff)
        
        group_layout.addWidget(form_inner_widget)
        
        # Add the whole group as a single row in the main form (spanning both cols)
        form_layout.addRow(group_container)

    def _add_beam_opening_group(self, form_layout, label_text, prefix):
        """Creates a specialized grouped row for Beam Openings (Clean List)"""
        group_container = QWidget()
        group_layout = QVBoxLayout(group_container)
        group_layout.setContentsMargins(0, 5, 0, 5)
        group_layout.setSpacing(2)

        # Header
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0,0,0,0)
        
        lbl = QLabel(label_text)
        lbl.setStyleSheet("font-size: 11px; color: #00bcd4; font-weight: bold;")
        
        # Drawer for Beam
        drawer = QWidget()
        drawer.hide()
        drawer.setStyleSheet("background: #181818; border-left: 2px solid #00bcd4;")

        btn_link = QPushButton("üîó Vincular")
        btn_link.setCursor(Qt.PointingHandCursor)
        btn_link.setStyleSheet("""
            QPushButton { border: 1px solid #444; border-radius: 4px; background: #222; color: #aaa; padding: 2px 6px; font-size: 10px; }
            QPushButton:hover { background: #333; color: white; border-color: #666; }
        """)
        btn_link.clicked.connect(lambda: self._toggle_link_drawer(prefix, drawer))
        
        btn_focus = QPushButton("üîç")
        btn_focus.setFixedSize(24, 20)
        btn_focus.setCursor(Qt.PointingHandCursor)
        btn_focus.setStyleSheet("background: transparent; border: 1px solid #444; color: #aaa; font-size: 10px;")
        btn_focus.clicked.connect(lambda checked=False, p=prefix: self.focus_requested.emit(p))
        
        header_layout.addWidget(lbl)
        header_layout.addStretch()
        header_layout.addWidget(btn_focus)
        header_layout.addWidget(btn_link)
        
        group_layout.addWidget(header_widget)
        group_layout.addWidget(drawer)

        # Internal Form
        form_inner_widget = QWidget()
        form_inner = QFormLayout(form_inner_widget)
        form_inner.setContentsMargins(5, 0, 0, 0) # Reduzido ident
        form_inner.setSpacing(1)
        form_inner.setLabelAlignment(Qt.AlignLeft)

        # Fields: Larg, Aj.Boca, Prof, Aj.Prof
        f_larg = self._create_sub_field(prefix, "larg", "", 0)
        f_aj_b = self._create_sub_field(prefix, "aj_boca", "", 0)
        f_prof = self._create_sub_field(prefix, "prof", "", 0)
        f_aj_p = self._create_sub_field(prefix, "aj_prof", "", 0)

        form_inner.addRow("Larg M:", f_larg)
        form_inner.addRow("Aj. Boca:", f_aj_b)
        form_inner.addRow("Prof:", f_prof)
        form_inner.addRow("Aj. Prof:", f_aj_p)
        
        group_layout.addWidget(form_inner_widget)

        form_layout.addRow(group_container)

    def _create_sub_field(self, prefix, suffix, placeholder, width):
        """Helper to create sub-fields for complex groups"""
        full_key = f"{prefix}_{suffix}"
        
        default_val = self.item_data.get(full_key, "")
        
        f = QLineEdit(str(default_val))
        if placeholder: f.setPlaceholderText(placeholder)
        if width > 0:
            f.setFixedWidth(width)
        else:
            f.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            
        f.setStyleSheet(self.STYLE_DEFAULT)
        f.textChanged.connect(lambda txt: self._on_field_changed(full_key, txt))
        
        self.fields[full_key] = f
        return f

    def _on_field_changed(self, key, value):
        """Atualiza item_data imediatamente ao digitar"""
        self.item_data[key] = value
        self.data_changed.emit(self.item_data)
        
        # Sincroniza√ß√£o especial para Marco DXF
        if key.startswith('ext_viga_') and 'vigas_individuais' in self.item_data:
            v_id = key.replace('ext_viga_', '')
            for v in self.item_data['vigas_individuais']:
                if v.get('id') == v_id:
                    try:
                        v['extension_len'] = float(value)
                        v['final_len'] = v['original_len'] + v['extension_len']
                    except: pass
                    break

    def refresh_validation_styles(self):
        """Varre campos e aplica borda verde nos validados e atualiza contadores de v√≠nculos"""
        validated_fields = self.item_data.get('validated_fields', [])
        for fid, w in self.fields.items():
            # Skip QButtonGroup (logical container, not visual)
            if isinstance(w, QButtonGroup):
                continue
            
            is_valid = fid in validated_fields
            is_na = fid in self.item_data.get('na_fields', [])
            
            # --- Atualizar Estilo Visual (Bordas/Cores) ---
            if isinstance(w, (QLineEdit, QComboBox)):
                if is_na:
                    w.setStyleSheet(self.STYLE_NA)
                    w.setEnabled(False) # Bloqueia edi√ß√£o direta
                elif is_valid:
                    w.setStyleSheet(self.STYLE_VALID)
                    w.setEnabled(True)
                else:
                    w.setStyleSheet(self.STYLE_DEFAULT)
                    w.setEnabled(True)

            # --- Bloquear/Desbloquear Bot√µes de A√ß√£o ---
            btns = self.action_btns.get(fid, {})
            if btns:
                # Se for N/A, bloqueia Focus, Express e Interp (MAS MANTEM LINK PARA REVISAO)
                for bkey in ['focus', 'express']:
                    b = btns.get(bkey)
                    if b: b.setEnabled(not is_na)
                
                # Garantir que o bot√£o N/A reflita o estado (caso venha de carga de dados)
                if btns.get('na'):
                    btns['na'].blockSignals(True)
                    btns['na'].setChecked(is_na)
                    btns['na'].blockSignals(False)
            
            # --- Atualizar Labels de V√≠nculo (se for hide_input=True) ---
            # INDEPENDENTE de ter bot√µes ou n√£o, se for QLabel, atualiza texto (Caso viga_segs)
            if isinstance(w, QLabel):
                if is_na:
                    w.setText("N/A - N√£o se aplica")
                    w.setStyleSheet("color: #ffd600; font-weight: bold; font-size: 10px; font-style: italic;")
                else:
                    links = self.item_data.get('links', {}).get(fid, {})
                    count = 0
                    if isinstance(links, dict):
                        for sl_links in links.values(): count += len(sl_links)
                    elif isinstance(links, list):
                        count = len(links)
                    
                    if is_valid:
                        w.setText(f"{count} V√≠nculo(s) ‚úÖ" if count > 0 else "Validado ‚úÖ")
                        w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 11px; background: rgba(0, 204, 102, 0.1); border: 1px solid #00cc66; border-radius: 4px; padding: 2px;")
                    elif count > 0:
                        w.setText(f"{count} V√≠nculo(s) Ok")
                        w.setStyleSheet("color: #00cc66; font-weight: bold; font-size: 10px;")
                        print(f"[DetailCard] Label {fid} atualizado para {count} v√≠nculos")
                    else:
                        w.setText("V√≠nculo Pendente")
                        w.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
                        print(f"[DetailCard] Label {fid} atualizado para V√≠nculo Pendente")

            # --- Atualizar a bolinha (indicador) ---
            if fid in self.indicators:
                indicator = self.indicators[fid]
                if is_na:
                    indicator.setStyleSheet("color: #ffd600; font-size: 14px; margin-right: 5px;")
                elif is_valid:
                    indicator.setStyleSheet("color: #00cc66; font-size: 14px; margin-right: 5px;")
                else:
                    # Restaurar cor baseada na confian√ßa da IA original
                    conf_score = self.item_data.get('confidence_map', {}).get(fid, 0.0)
                    color = "#ff4444" 
                    if conf_score > 0.8: color = "#00c853"
                    elif conf_score > 0.4: color = "#ffd600"
                    
                    style = f"color: {color}; font-size: 14px; margin-right: 5px;"
                    if indicator.styleSheet() != style:
                        print(f"[DEBUG HIERARCHY] Field Indicator '{fid}' reverting to confidence color (is_valid=False)")
                        indicator.setStyleSheet(style)
        
        # --- Atualizar managers embutidos se estiverem abertos ---
        for fid, lm in self.embedded_managers.items():
            # Refresh even if not visible to ensure data is ready when opened
            links_dict = self.item_data.get('links', {})
            current_links = links_dict.get(fid, {})
            if isinstance(current_links, list):
                current_links = {'label': current_links}
            lm.links = current_links
            
            # Passar tamb√©m slots validados e N/A atualizados
            lm.na_slots = set(self.item_data.get('na_link_classes', {}).get(fid, []))
            lm.validated_slots = set(self.item_data.get('validated_link_classes', {}).get(fid, []))
            
            lm.refresh_list()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(2, 5, 2, 5) # Margem m√≠nima
        layout.setSpacing(3)
        
        # --- Cabe√ßalho Din√¢mico ---
        elem_type = self.item_data.get('type', 'Pilar').upper()
        
        # PARA LAJES ou MARCO: O Header √© omitido aqui e criado dentro da aba/view espec√≠fica
        if 'LAJE' not in elem_type and 'MARCO' not in elem_type:
            header_title = f"DADOS GERAIS - {elem_type}"
            
            header = QGroupBox(header_title)
            header.setStyleSheet("QGroupBox { font-size: 10px; font-weight: bold; color: #ffb300; border: 1px solid #333; margin-top: 5px; padding-top: 8px; }")
            h_layout = QFormLayout(header)
            h_layout.setContentsMargins(2, 2, 2, 2)
            h_layout.setSpacing(1)
            
            self._add_linked_row(h_layout, "N¬∫ Item:", "id_item", "text", show_links=False, show_focus=False, show_validate=True)
            self._add_linked_row(h_layout, "Nome:", "name", "text")
            
            if 'VIGA' in elem_type:
                 self._add_linked_row(h_layout, "Dimens√£o:", "dim", "text")
                 self._add_linked_row(h_layout, "Segmentos:", "viga_segs", "poly", hide_input=True)
                 
            else: # Pilar (default)
                self._add_linked_row(h_layout, "Dimens√£o:", "dim", "text")
                self._add_linked_row(h_layout, "Segmentos:", "pilar_segs", "poly", hide_input=True)
                
                # Formato (Apenas Pilar)
                self.fields['format'] = QComboBox()
                self.fields['format'].addItems(["Retangular", "Circular", "Em L", "Em T", "Em U"])
                self.fields['format'].setCurrentText(self.item_data.get('format', 'Retangular'))
                self.fields['format'].setFixedHeight(24)
                self.fields['format'].setStyleSheet("background: #252525; border: 1px solid #444; border-radius: 3px; color: #eee;")
                self.fields['format'].currentTextChanged.connect(lambda txt: self._on_field_changed('format', txt))
                h_layout.addRow("Formato:", self.fields['format'])
            
            layout.addWidget(header)

        # Container para conte√∫do din√¢mico (Abas que mudam com o formato)
        self.dynamic_container = QWidget()
        self.dynamic_layout = QVBoxLayout(self.dynamic_container)
        self.dynamic_layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.dynamic_container, 1) # Give stretch factor to expand

        # Inicializa conte√∫do din√¢mico
        self._refresh_dynamic_content()
        
        # Conecta sinal de mudan√ßa de formato (se existir)
        if 'format' in self.fields:
            self.fields['format'].currentTextChanged.connect(self._on_format_changed)

        layout.addLayout(self._create_action_buttons())
        scroll.setWidget(container)
        main_layout.addWidget(scroll)
        
        # Garante aplica√ß√£o de estilos de valida√ß√£o ap√≥s toda UI estar pronta
        self.refresh_validation_styles()

    # ... (keeps existing helper methods until _setup_laje_complex_view)

    def _setup_laje_complex_view(self, layout):
        tabs = QTabWidget()
        tabs.setStyleSheet("""
            QTabBar::tab { padding: 8px 20px; font-weight: bold; }
            QTabWidget::pane { border: 1px solid #444; }
        """)
        
        tab = QWidget()
        l = QVBoxLayout(tab)
        l.setSpacing(10)
        
        # --- DADOS GERAIS (Exclusivo para Laje aqui dentro) ---
        grp = QGroupBox("DADOS GERAIS - LAJE")
        grp.setStyleSheet("QGroupBox { font-size: 11px; font-weight: bold; border: 1px solid #444; margin-top: 5px; padding-top: 10px; color: #00ffcc; }")
        form = QFormLayout(grp)
        form.setSpacing(5)
        
        # Campos principais movidos para c√°
        self._add_linked_row(form, "N¬∫ Item:", "id_item", "text", show_links=False, show_focus=False)
        self._add_linked_row(form, "Nome:", "name", "text")
        self._add_linked_row(form, "Dimens√£o:", "laje_dim", "text")
        self._add_linked_row(form, "N√≠vel (ex: +2.80):", "laje_nivel", "text")
        self._add_linked_row(form, "Segmentos da √Årea:", "laje_outline_segs", "poly", hide_input=True)
        self._add_linked_row(form, "Contorno da Ilha:", "laje_islands", "poly", hide_input=True)

        if "laje_dim" in self.fields:
             self.fields["laje_dim"].textChanged.connect(lambda t: self._clean_laje_dim_input(t))
        
        l.addWidget(grp)
        l.addStretch() # Empurrar tudo para cima
        
        tabs.addTab(tab, "Laje")
        layout.addWidget(tabs)

    def _setup_pilar_complex_view(self, layout):
        tabs = QTabWidget()
        tabs.setStyleSheet("QTabBar::tab { padding: 5px; font-size: 10px; }")
        shape = self.fields['format'].currentText()
        
        sides = ['A', 'B', 'C', 'D']
        if shape == "Circular": sides = ["Superior", "Inferior"]
        elif shape == "Em L": sides = ['A', 'B', 'C', 'D', 'E', 'F']
        elif shape in ["Em T", "Em U"]: sides = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

        for side in sides:
            tab = QWidget()
            tab_l = QVBoxLayout(tab)
            tab_l.setContentsMargins(5, 5, 5, 5)
            tab_l.setSpacing(2)
            
            # Lajes - Layout Vertical (Laje 2 abaixo da Laje 1) para compactar largura
            for i in [1, 2]:
                grp = QGroupBox(f"Laje {i}")
                grp.setStyleSheet("QGroupBox { font-size: 10px; font-weight: bold; border: 1px solid #333; margin-top: 5px; padding-top: 5px; }")
                f = QFormLayout(grp)
                f.setSpacing(1)
                f.setContentsMargins(2, 5, 2, 2)
                self._add_linked_row(f, "Nome:", f'p_s{side}_l{i}_n', "text")
                self._add_linked_row(f, "H:", f'p_s{side}_l{i}_h', "text")
                self._add_linked_row(f, "N√≠vel:", f'p_s{side}_l{i}_v', "text")
                
                # Ajuste Laje 2: Pos. -> Laje central e op√ß√µes Esquerda/Direita
                if i == 2:
                    self._add_linked_row(f, "Pos. C:", f'p_s{side}_l{i}_p', "text", is_combo=True, combo_items=["Esquerda", "Direita"])
                else:
                    self._add_linked_row(f, "Pos.:", f'p_s{side}_l{i}_p', "text", is_combo=True, combo_items=["Topo", "Centro", "Fundo"])
                
                self._add_linked_row(f, "Dist. C:", f'p_s{side}_l{i}_dist_c', "poly")
                
                # Novo Campo Laje 2: Dist. do Topo
                if i == 2:
                    self._add_linked_row(f, "Dist. T:", f'p_s{side}_l{i}_dist_t', "poly") 
                
                # Inicializa√ß√£o de visibilidade
                self._on_position_changed(f'p_s{side}_l{i}_p', self.fields[f'p_s{side}_l{i}_p'].currentText())
                
                tab_l.addWidget(grp)

            # Categorias de Vigas
            beam_categories = [
                ("V. Cont. Esq.", "esq", False),
                ("V. Cont. Dir.", "dir", False),
                ("V. Cheg. 1", "ch1", True),
                ("V. Cheg. 2", "ch2", True),
                ("V. Cheg. 3", "ch3", True)
            ]
            
            for cat_name, cat_id, is_arrival in beam_categories:
                v_grp = QGroupBox(cat_name)
                v_grp.setStyleSheet("QGroupBox { font-size: 10px; color: #0078D4; border: 1px solid #333; margin-top: 10px; padding-top: 5px; }")
                vf = QFormLayout(v_grp)
                vf.setSpacing(1)
                vf.setContentsMargins(2, 5, 2, 2)
                
                id_pref = f'p_s{side}_v_{cat_id}'
                self._add_linked_row(vf, "Nome:", f'{id_pref}_n', "text")
                self._add_linked_row(vf, "Dim.:", f'{id_pref}_d', "text")
                self._add_linked_row(vf, "Seg.:", f'{id_pref}_segs', "poly", hide_input=True)
                if is_arrival:
                    self._add_linked_row(vf, "Dist.:", f'{id_pref}_dist', "poly")
                
                # Profundidade sem link, auto-calculado
                self._add_linked_row(vf, "Prof.:", f'{id_pref}_prof', "text", show_links=False)
                
                # Auto-update logic
                dim_widget = self.fields[f'{id_pref}_d']
                prof_widget = self.fields[f'{id_pref}_prof']
                dim_widget.textChanged.connect(lambda t, w=prof_widget: self._update_depth_from_dim(t, w))
                
                self._add_linked_row(vf, "Dif. N√≠vel:", f'{id_pref}_diff_v', "text")
                tab_l.addWidget(v_grp)
                
            tabs.addTab(tab, f"Lado {side}")
            
        layout.addWidget(tabs)

    def _update_depth_from_dim(self, text, target_widget):
        """Calcula profundidade (maior valor) baseado no texto de dimens√£o (ex: '15x40')"""
        import re
        try:
            # Busca n√∫meros, suportando decimais com ponto ou v√≠rgula
            nums = [float(n.replace(',', '.')) for n in re.findall(r'\d+[.,]?\d*', text)]
            if len(nums) >= 2:
                # Se tiver pelo menos 2 n√∫meros (ex: 15 e 40), pega o maior
                max_val = max(nums)
                # Formata removendo .0 se for inteiro
                txt_val = f"{int(max_val)}" if max_val.is_integer() else f"{max_val}"
                target_widget.setText(txt_val)
        except Exception:
            pass

    def _setup_viga_complex_view(self, layout):
        """Implementa detalhamento rigoroso de Lado A, Lado B e Fundo"""
        tabs = QTabWidget()
        sides_config = [('A', 'Lado A', False), ('B', 'Lado B', False), ('Fundo', 'Fundo', True)]
        
        for side, label, is_bottom in sides_config:
            tab = QWidget()
            tab_l = QVBoxLayout(tab)
            tab_l.setSpacing(15)
            tab_l.setContentsMargins(5, 5, 5, 5)
            
            prefix = f"viga_{side.lower()}"

            if not is_bottom:
                # Container de Segmentos Rica
                segs_container = QWidget()
                segs_layout = QVBoxLayout(segs_container)
                segs_layout.setContentsMargins(0,0,0,0)
                segs_layout.setSpacing(15)
                tab_l.addWidget(segs_container)
                
                # L√≥gica de Carga:
                existing_indices = set([1]) # Sempre garanta pelo menos o 1
                for key in self.item_data.keys():
                    if key.startswith(f"{prefix}_seg_"):
                        try:
                            parts = key.split('_')
                            idx = int(parts[parts.index('seg') + 1])
                            existing_indices.add(idx)
                        except: pass
                
                for i in sorted(list(existing_indices)):
                    self._add_rich_segment_pack(segs_layout, prefix, i)
                    
                # Bot√£o Add
                btn_add = QPushButton(" + Adicionar Segmento Completo")
                btn_add.setFixedHeight(30)
                btn_add.setStyleSheet("background: #004444; color: #00ffcc; border: 1px dashed #00ffcc; font-weight: bold; font-size: 11px;")
                btn_add.setCursor(Qt.PointingHandCursor)
                btn_add.clicked.connect(lambda checked=False, l=segs_layout, p=prefix: self._add_rich_segment_pack(l, p))
                tab_l.addWidget(btn_add)

            else:
                # Layout Din√¢mico para Fundo (Segmentos Fundo)
                segs_container = QWidget()
                segs_layout = QVBoxLayout(segs_container)
                segs_layout.setContentsMargins(0,0,0,0)
                segs_layout.setSpacing(15)
                tab_l.addWidget(segs_container)
                
                # Carga de Segmentos Existentes
                existing_indices = set([1]) # Sempre garanta pelo menos o 1
                for key in self.item_data.keys():
                    if key.startswith(f"{prefix}_seg_"):
                        try:
                            parts = key.split('_')
                            idx = int(parts[parts.index('seg') + 1])
                            existing_indices.add(idx)
                        except: pass
                
                for i in sorted(list(existing_indices)):
                    self._add_fundo_segment_pack(segs_layout, prefix, i)
                
                # Bot√£o Adicionar Segmento Fundo
                btn_add = QPushButton(" + Adicionar Segmento Fundo")
                btn_add.setFixedHeight(30)
                btn_add.setStyleSheet("background: #440044; color: #ff88ff; border: 1px dashed #ff88ff; font-weight: bold; font-size: 11px;")
                btn_add.setCursor(Qt.PointingHandCursor)
                btn_add.clicked.connect(lambda checked=False, l=segs_layout, p=prefix: self._add_fundo_segment_pack(l, p))
                tab_l.addWidget(btn_add)
            
            tabs.addTab(tab, label)
            
        layout.addWidget(tabs)

    def _add_rich_segment_pack(self, layout, prefix, idx_override=None):
        """Cria um Box Completo de Segmento com todos os campos de engenharia"""
        
        # Determinar √≠ndice
        if idx_override:
            idx = idx_override
        else:
            # Contagem baseada nos widgets visuais para sequencia logica
            idx = layout.count() + 1
            
        seg_uid = f"{prefix}_seg_{idx}"
        
        # Grupo Principal do Segmento
        pack = QGroupBox(f"Segmento {idx}")
        # Estilo "Gigante" e vis√≠vel
        pack.setStyleSheet("""
            QGroupBox { 
                font-size: 12px; 
                font-weight: bold; 
                border: 2px solid #555; 
                border-radius: 6px;
                margin-top: 10px; 
                padding-top: 15px; 
                background: #1e1e1e;
            }
            QGroupBox::title {
                color: #00ffcc;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 3px 0 3px;
            }
        """)
        
        # Layout principal do pack
        main_v = QVBoxLayout(pack)
        main_v.setSpacing(10)
        
        # 1. Campos de Geometria (FormLayout)
        form_w = QWidget()
        form = QFormLayout(form_w)
        form.setSpacing(4)
        form.setContentsMargins(2,2,2,2)
        
        # 1. Comprimento Total (Moved to Top)
        self._add_linked_row(form, "Comp. Tot:", f'{seg_uid}_comprimento_total', "poly")
        
        # 2. Vis√£o de Corte (New - Complex Group)
        self._add_linked_row(form, "Corte:", f'{seg_uid}_visao_corte', "group", hide_input=True)
        
        # 3. Campos de V√≠nculo/Localiza√ß√£o
        self._add_linked_row(form, "Loc. Ini:", f'{seg_uid}_ini_name', "text", hide_input=True)
        self._add_linked_row(form, "Loc. Fim:", f'{seg_uid}_end_name', "text", hide_input=True)
        
        # 4. Campos Principais
        self._add_linked_row(form, "Dim.:", f'{seg_uid}_dim', "text")
        self._add_linked_row(form, "N√≠v. Vig:", f'{seg_uid}_nivel_viga', "text")
        self._add_linked_row(form, "N√≠v. Op:", f'{seg_uid}_nivel_oposto', "text")
        
        # Lajes
        self._add_linked_row(form, "L. Sup:", f'{seg_uid}_laje_sup', "text", hide_input=True)
        self._add_linked_row(form, "L. Cen:", f'{seg_uid}_laje_cen', "text", hide_input=True)
        self._add_linked_row(form, "L. Inf:", f'{seg_uid}_laje_inf', "text", hide_input=True)
        
        # Alturas
        self._add_linked_row(form, "H1:", f'{seg_uid}_h1', "text", hide_input=True)
        self._add_linked_row(form, "H2:", f'{seg_uid}_h2', "text", hide_input=True)
        
        # Aberturas
        self._add_pilar_opening_group(form, "Ab. Pil. E:", f'{seg_uid}_abert_pilar_esq')
        self._add_pilar_opening_group(form, "Ab. Pil. D:", f'{seg_uid}_abert_pilar_dir')

        self._add_beam_opening_group(form, "Ab. V. T. E:", f'{seg_uid}_abert_viga_top_esq')
        self._add_beam_opening_group(form, "Ab. V. T. D:", f'{seg_uid}_abert_viga_top_dir')
        self._add_beam_opening_group(form, "Ab. V. F. E:", f'{seg_uid}_abert_viga_fun_esq')
        self._add_beam_opening_group(form, "Ab. V. F. D:", f'{seg_uid}_abert_viga_fun_dir')
        
        main_v.addWidget(form_w)
        
        # 2. Modos de Painel (Radio Groups) - Lado a Lado
        modes_layout = QHBoxLayout()
        h1_opts = ["Sarrafo", "Garfo", "Grade"]
        modes_layout.addWidget(self._create_radio_group("Modo Painel H1", h1_opts, f"{seg_uid}_mode_h1", has_grade_input=True))
        
        h2_opts = ["Sarrafo", "Garfo", "Grade"]
        modes_layout.addWidget(self._create_radio_group("Modo Painel H2", h2_opts, f"{seg_uid}_mode_h2", has_grade_input=True))
        main_v.addLayout(modes_layout)
        
        # 3. Continuidade (Radio)
        cont_opts = ["Obst√°culo", "Viga", "√öltimo Seg."]
        main_v.addWidget(self._create_radio_group("Continuidade", cont_opts, f"{seg_uid}_continuidade"))
        
        # 4. Sarrafos (Checkbox Grid)
        sarrafos_opts = [
            ("Vertical Esq H1", "v_e_h1"), ("Press√£o Esq H1", "p_e_h1"),
            ("Vertical Esq H2", "v_e_h2"), ("Press√£o Esq H2", "p_e_h2"),
            ("Vertical Dir H1", "v_d_h1"), ("Press√£o Dir H1", "p_d_h1"),
            ("Vertical Dir H2", "v_d_h2"), ("Press√£o Dir H2", "p_d_h2")
        ]
        main_v.addWidget(self._create_checkbox_group("Sarrafos Presentes", sarrafos_opts, seg_uid))
        
        # Bot√£o Remover (se n√£o for o segmento 1, ou permitir remover todos?)
        # Geralmente segmento 1 √© obrigat√≥rio, mas vamos permitir flexibilidade
        if idx > 1:
            btn_rem = QPushButton("Remover Este Segmento")
            btn_rem.setStyleSheet("color: #ff5555; background: transparent; border: 1px solid #ff5555; border-radius: 4px; padding: 4px;")
            btn_rem.setCursor(Qt.PointingHandCursor)
            btn_rem.clicked.connect(lambda: self._remove_segment(pack, layout, prefix, idx))
            main_v.addWidget(btn_rem)
            
        layout.addWidget(pack)

    def _add_fundo_segment_pack(self, layout, prefix, idx_override=None):
        """Cria um Box Completo de Segmento de Fundo"""
        
        # Determinar √≠ndice
        if idx_override:
            idx = idx_override
        else:
            idx = layout.count() + 1
            
        seg_uid = f"{prefix}_seg_{idx}"
        
        # Grupo Principal do Segmento
        pack = QGroupBox(f"Segmento Fundo {idx}")
        # Estilo "Gigante" e vis√≠vel (Mesmo estilo do side)
        pack.setStyleSheet("""
            QGroupBox { 
                font-size: 12px; 
                font-weight: bold; 
                border: 2px solid #5544aa; 
                border-radius: 6px;
                margin-top: 10px; 
                padding-top: 15px; 
                background: #1e1e22;
            }
            QGroupBox::title {
                color: #aa88ff;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 3px 0 3px;
            }
        """)
        
        # Layout principal do pack
        main_v = QVBoxLayout(pack)
        main_v.setSpacing(10)
        
        # 1. Campos de Engenharia (FormLayout)
        form_w = QWidget()
        form = QFormLayout(form_w)
        form.setSpacing(4)
        form.setContentsMargins(2,2,2,2)
        
        # Campos Solicitados
        self._add_linked_row(form, "Segs. √Årea:", f'{seg_uid}_area_segs', "poly", hide_input=True)
        self._add_linked_row(form, "Larg. Tot:", f'{seg_uid}_largura', "text")
        self._add_linked_row(form, "Comp. Tot:", f'{seg_uid}_comprimento', "poly")
        self._add_linked_row(form, "Loc. Ini:", f'{seg_uid}_local_ini', "text", hide_input=True)
        self._add_linked_row(form, "Loc. Fim:", f'{seg_uid}_local_fim', "text", hide_input=True)
        
        # Aberturas
        self._add_linked_row(form, "Ab. T. D:", f'{seg_uid}_abert_top_dir', "poly")
        self._add_linked_row(form, "Ab. F. D:", f'{seg_uid}_abert_fun_dir', "poly")
        self._add_linked_row(form, "Ab. T. E:", f'{seg_uid}_abert_top_esq', "poly")
        self._add_linked_row(form, "Ab. F. E:", f'{seg_uid}_abert_fun_esq', "poly")
        self._add_linked_row(form, "Ab. Esp:", f'{seg_uid}_abert_especial', "poly")
        
        # Chanfros
        self._add_linked_row(form, "Chanf. E. T:", f'{seg_uid}_chanfro_esq_top', "poly")
        self._add_linked_row(form, "Chanf. E. F:", f'{seg_uid}_chanfro_esq_fun', "poly")
        self._add_linked_row(form, "Chanf. D. T:", f'{seg_uid}_chanfro_dir_top', "poly")
        self._add_linked_row(form, "Chanf. D. F:", f'{seg_uid}_chanfro_dir_fun', "poly")
        
        main_v.addWidget(form_w)
        
        # 2. Continuidade (Radio)
        cont_opts_fundo = ["Obst√°culo", "Recorte", "√öltimo Seg."]
        main_v.addWidget(self._create_radio_group("Continuidade (Fundo)", cont_opts_fundo, f"{seg_uid}_continuidade"))
        
        # Bot√£o Remover
        if idx > 1:
            btn_rem = QPushButton("Remover Este Segmento")
            btn_rem.setStyleSheet("color: #ff5555; background: transparent; border: 1px solid #ff5555; border-radius: 4px; padding: 4px;")
            btn_rem.setCursor(Qt.PointingHandCursor)
            btn_rem.clicked.connect(lambda: self._remove_segment(pack, layout, prefix, idx))
            main_v.addWidget(btn_rem)
            
        layout.addWidget(pack)


    def _create_radio_group(self, title, options, key_prefix, has_grade_input=False):
        """Cria um grupo de op√ß√µes exclusivas (Sarrafo/Garfo/Grade)"""
        grp = QGroupBox(title)
        grp.setStyleSheet("QGroupBox { font-size: 10px; border: 1px solid #444; padding-top: 5px; }")
        l = QVBoxLayout(grp)
        l.setSpacing(2)
        
        bg = QButtonGroup(grp) # Garante exclusividade l√≥gica
        self.fields[f"{key_prefix}_bg"] = bg # Mant√©m ref para n√£o ser garbage collected
        
        # Valor atual salvo
        current_val = self.item_data.get(key_prefix, options[0])
        
        for opt in options:
            rb = QRadioButton(opt)
            rb.setStyleSheet("QRadioButton { font-size: 10px; color: #ccc; }")
            if opt == current_val: rb.setChecked(True)
            bg.addButton(rb)
            l.addWidget(rb)
            
            # Se for op√ß√£o "Grade" e tiver input ativado
            if has_grade_input and "Grade" in opt:
                grade_input = QLineEdit()
                grade_input.setPlaceholderText("Tam. Grade (cm)")
                grade_input.setFixedHeight(20)
                grade_input.setStyleSheet(self.STYLE_DEFAULT)
                
                # Chave para salvar tamanho da grade
                grade_key = f"{key_prefix}_grade_size"
                self.fields[grade_key] = grade_input
                grade_input.setText(str(self.item_data.get(grade_key, "")))
                
                # Visibilidade condicional
                grade_input.setVisible(rb.isChecked())
                rb.toggled.connect(grade_input.setVisible)
                
                l.addWidget(grade_input)
                
        # Conectar mudan√ßa do grupo para atualizar data (opcional, pois validamos no final)
        # bg.buttonClicked.connect(lambda btn: self.item_data.update({key_prefix: btn.text()}))
        
        return grp

    def _create_checkbox_group(self, title, options, key_prefix):
        """Cria Grid de Checkboxes para Sarrafos"""
        grp = QGroupBox(title)
        grp.setStyleSheet("QGroupBox { font-size: 12px; border: 1px solid #444; padding-top: 5px; }")
        
        container = QWidget()
        grid = QHBoxLayout(container) # Divide em 2 colunas verticais
        col1 = QVBoxLayout(); col2 = QVBoxLayout()
        col1.setSpacing(2); col2.setSpacing(2)
        
        mid = len(options) // 2
        for i, (label, suffix) in enumerate(options):
            cb = QCheckBox(label)
            cb.setStyleSheet("QCheckBox { font-size: 11px; color: #ccc; }")
            full_key = f"{key_prefix}_chk_{suffix}"
            self.fields[full_key] = cb
            
            if self.item_data.get(full_key, False):
                cb.setChecked(True)
                
            if i < mid: col1.addWidget(cb)
            else: col2.addWidget(cb)
            
        grid.addLayout(col1); grid.addLayout(col2)
        
        l = QVBoxLayout(grp)
        l.setContentsMargins(2, 15, 2, 2)
        l.addWidget(container)
        return grp


    def _remove_segment(self, widget, layout, prefix, idx):
        """Remove visualmente e limpa refer√™ncias"""
        widget.hide()
        layout.removeWidget(widget)
        widget.deleteLater()
        
        # Limpar do self.fields para n√£o ser salvo novamente
        keys_to_remove = [k for k in self.fields.keys() if k.startswith(f"{prefix}_seg_{idx}")]
        for k in keys_to_remove:
            del self.fields[k]
        
        # Removendo imediatamente do item_data para garantir consist√™ncia visual x dados
        keys_data_remove = [k for k in self.item_data.keys() if k.startswith(f"{prefix}_seg_{idx}")]
        for k in keys_data_remove:
            del self.item_data[k]


    def _get_initial_value(self, field_id):
        """Busca valor, priorizando links > sides_data > flat_key"""
        
        # 1. Prioridade: Valor do V√≠nculo (Se existir e for Texto/Line validado)
        links = self.item_data.get('links', {})
        if field_id in links:
            slots = links[field_id]
            if isinstance(slots, dict):
                 for s_list in slots.values():
                     if s_list and len(s_list) > 0:
                         txt = str(s_list[0].get('text', ''))
                         if txt.strip(): 
                             # Somente extrair n√∫mero se N√ÉO for campo de nome ou dimens√£o
                             is_dim_or_name = "dim" in field_id or "name" in field_id or field_id.endswith("_n") or field_id.endswith("_d")
                             if not is_dim_or_name:
                                 import re
                                 nums = re.findall(r'\d+[.,]?\d*', txt)
                                 if nums:
                                     return nums[0].replace(',', '.')
                             return txt
            elif isinstance(slots, list) and len(slots) > 0:
                 txt = str(slots[0].get('text', ''))
                 if txt.strip(): 
                     is_dim_or_name = "dim" in field_id or "name" in field_id or field_id.endswith("_n") or field_id.endswith("_d")
                     if not is_dim_or_name:
                         import re
                         nums = re.findall(r'\d+[.,]?\d*', txt)
                         if nums:
                             return nums[0].replace(',', '.')
                     return txt

        # 2. Prioridade: Flat Key
        if field_id in self.item_data:
            return self.item_data[field_id]
        
        # 3. Prioridade: Nested Data (sides_data)
        if field_id.startswith('p_s'):
            try:
                parts = field_id.split('_', 2) 
                if len(parts) >= 3:
                    side = parts[1][1:] 
                    key = parts[2]
                    sides = self.item_data.get('sides_data', {})
                    side_content = sides.get(side, {})
                    return side_content.get(key)
            except Exception: pass
            
        return None

    def _create_action_buttons(self):
        # Layout Vertical para economizar largura no painel
        v = QVBoxLayout()
        v.setContentsMargins(0, 5, 0, 0)
        v.setSpacing(5)

        btn_valid = QPushButton("VALIDAR (TREINAR IA)")
        btn_valid.setObjectName("Success")
        btn_valid.setCursor(Qt.PointingHandCursor)
        btn_valid.setFixedHeight(35) # Altura menor
        btn_valid.setToolTip("Salva e treina o padr√£o atual no banco de dados")
        btn_valid.clicked.connect(self.on_validate)

        btn_invalid = QPushButton("MARCAR FALHA")
        btn_invalid.setObjectName("Danger")
        btn_invalid.setCursor(Qt.PointingHandCursor)
        btn_invalid.setFixedHeight(35) # Altura menor
        btn_invalid.setToolTip("Marca este item para revis√£o manual posterior")
        btn_invalid.clicked.connect(self.on_invalidate)

        v.addWidget(btn_valid)
        v.addWidget(btn_invalid)
        
        return v

    def on_validate(self):
        final_data = self.item_data.copy()
        validated = final_data.setdefault('validated_fields', [])
        
        # Ensure sides_data exists
        if 'sides_data' not in final_data: final_data['sides_data'] = {}
        
        for key, widget in self.fields.items():
            if isinstance(widget, QLineEdit): val = widget.text()
            elif isinstance(widget, QComboBox): val = widget.currentText()
            else: continue
            
            final_data[key] = val
            # Ao validar o card todo, todos os campos preenchidos ganham selo de validado
            if val and key not in validated:
                validated.append(key)
        
        # [NOVO] SELO AZUL (Valida√ß√£o Completa de Contexto)
        # S√≥ este bot√£o concede o status de "Item 100% Validado" para curadoria
        final_data['is_fully_validated'] = True
        
        self.refresh_validation_styles()
            
        self.data_validated.emit(final_data)
        QMessageBox.information(self, "IA Training", "Dados enviados para o banco de padr√µes! (Selo Azul)")

    def on_invalidate(self):
        self.data_invalidated.emit(self.item_data)
        QMessageBox.warning(self, "IA Training", "Item marcado para revis√£o manual.")

    def _on_format_changed(self, text):
        """Reage √† mudan√ßa no ComboBox de formato"""
        self.item_data['format'] = text
        self._refresh_dynamic_content()

    def _refresh_dynamic_content(self):
        """Reconstr√≥i a √°rea din√¢mica baseada no tipo e formato atual"""
        self._clear_dynamic_content()
        
        elem_type = self.item_data.get('type', '').lower()
        if 'pilar' in elem_type:
            # Garante que usamos o layout din√¢mico
            self._setup_pilar_complex_view(self.dynamic_layout)
        elif 'viga' in elem_type:
            self._setup_viga_complex_view(self.dynamic_layout)
        elif 'laje' in elem_type:
            self._setup_laje_complex_view(self.dynamic_layout)
        elif 'marcodxf' in elem_type:
            self._setup_marco_view(self.dynamic_layout)

    def _clear_dynamic_content(self):
        """Remove widgets din√¢micos e limpa refer√™ncias no self.fields"""
        # Identifica campos que pertencem ao container din√¢mico para remover do self.fields
        to_remove = []
        for key, widget in self.fields.items():
            if self._is_descendant(widget, self.dynamic_container):
                to_remove.append(key)
        
        for k in to_remove:
            del self.fields[k]
            
        # Remove widgets do layout
        while self.dynamic_layout.count():
            item = self.dynamic_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                # Se for um layout aninhado, precisamos limpar recursivamente ou deletar o item
                # Layouts em Qt n√£o s√£o widgets, mas items layout.
                # O ideal √© que tudo esteja dentro de widgets.
                # Como usamos .addWidget(tabs), tabs √© um widget.
                pass

    def _is_descendant(self, widget, ancestor):
        """Verifica se widget √© descendente de ancestor (para limpeza segura)"""
        p = widget
        while p:
            if p == ancestor: return True
            p = p.parentWidget()
        return False

    def _clean_laje_dim_input(self, text):
        """Limpa entrada de dimens√£o de laje (ex: 'd=12' -> '12')"""
        import re
        # Se tiver d= ou h=, extrai o n√∫mero
        match = re.search(r'[dhDH]=\s*(\d+[.,]?\d*)', text)
        if match:
             clean_val = match.group(1)
             # Evita loop infinito
             current = self.fields['laje_dim'].text()
             if current != clean_val:
                  self.fields['laje_dim'].blockSignals(True)
                  self.fields['laje_dim'].setText(clean_val)
                  self.fields['laje_dim'].blockSignals(False)
                  # Atualiza dados
                  self._on_field_changed('laje_dim', clean_val)

    def _setup_marco_view(self, layout_container):
        """View em formato de Tabela (Grid) para o Tratamento Pr√©vio do Marco"""
        from PySide6.QtWidgets import QGridLayout, QFrame
        
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)
        
        lbl_head = QLabel("üõ†Ô∏è TRATAMENTO PR√âVIO - PER√çMETRO")
        lbl_head.setStyleSheet("font-size: 13px; font-weight: bold; color: #00d4ff;")
        layout.addWidget(lbl_head)

        vigas = self.item_data.get('vigas_individuais', [])
        
        if not vigas:
            layout.addWidget(QLabel("Nenhuma viga de extremidade detectada."))
        else:
            # Header da "Tabela"
            header_frame = QFrame()
            header_frame.setStyleSheet("background: #222; border-bottom: 1px solid #444;")
            h_lay = QHBoxLayout(header_frame)
            h_lay.setContentsMargins(5, 5, 5, 5)
            
            lbl_ref = QLabel("Refer√™ncia"); lbl_ref.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_tam = QLabel("Tamanho"); lbl_tam.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_lnk = QLabel("A√ß√µes"); lbl_lnk.setStyleSheet("font-weight: bold; color: #aaa;")
            lbl_val = QLabel("Soma (cm)"); lbl_val.setStyleSheet("font-weight: bold; color: #aaa;")
            
            h_lay.addWidget(lbl_ref, 2)
            h_lay.addWidget(lbl_tam, 2)
            h_lay.addWidget(lbl_lnk, 2) 
            h_lay.addWidget(lbl_val, 2)
            layout.addWidget(header_frame)

            # Lista de Itens (Rows)
            for v in vigas:
                v_id = v.get('id')
                field_key = f"ext_viga_{v_id}"
                
                row_container = QFrame()
                row_container.setStyleSheet("border-bottom: 1px solid #222;")
                row_v_lay = QVBoxLayout(row_container)
                row_v_lay.setContentsMargins(0, 0, 0, 0)
                row_v_lay.setSpacing(0)
                
                # Linha de Dados
                data_row = QWidget()
                dr_lay = QHBoxLayout(data_row)
                dr_lay.setContentsMargins(5, 4, 5, 4) # Mais margem
                
                # 1. Refer√™ncia
                lbl_v_id = QLabel(f"Viga_{v_id[:4]}")
                lbl_v_id.setStyleSheet("color: #ddd; font-weight: bold;")
                dr_lay.addWidget(lbl_v_id, 2)
                
                # 2. Tamanho (Original)
                dr_lay.addWidget(QLabel(f"{v.get('original_len', 0):.1f}"), 2)
                
                # 3. Bloco de Bot√µes (Compacto: √çcones Ajustados)
                btns_widget = QWidget()
                btns_lay = QHBoxLayout(btns_widget)
                btns_lay.setContentsMargins(0, 0, 0, 0)
                btns_lay.setSpacing(4)
                
                drawer = QWidget()
                drawer.hide()
                drawer.setStyleSheet("background: #141414; border-left: 3px solid #00d4ff; margin: 2px; border-radius: 2px;")
                
                # Bot√£o ZOOM
                btn_zoom = QPushButton("üîç")
                btn_zoom.setFixedSize(24, 24)
                btn_zoom.setCursor(Qt.PointingHandCursor)
                btn_zoom.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #ffca28; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(100, 100, 100, 255); border: 1px solid #ffca28; }
                """)
                btn_zoom.clicked.connect(lambda checked=False, f=field_key: self.focus_requested.emit(f))
                
                # Bot√£o VINC
                btn_link = QPushButton("üîó")
                btn_link.setFixedSize(24, 24)
                btn_link.setCursor(Qt.PointingHandCursor)
                btn_link.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #00d4ff; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(100, 100, 100, 255); border: 1px solid #00d4ff; }
                """)
                btn_link.clicked.connect(lambda checked=False, f=field_key, d=drawer: self._toggle_link_drawer(f, d))
                
                # Bot√£o EXCL
                btn_del = QPushButton("‚úñ")
                btn_del.setFixedSize(24, 24)
                btn_del.setCursor(Qt.PointingHandCursor)
                btn_del.setStyleSheet("""
                    QPushButton { 
                        background: rgba(60, 60, 60, 180); border: 1px solid #444; border-radius: 3px;
                        color: #ff5252; font-size: 13px; font-weight: bold; padding: 0px;
                    }
                    QPushButton:hover { background: rgba(220, 50, 50, 255); border: 1px solid #ff5252; }
                """)
                btn_del.clicked.connect(lambda checked=False, vid=v_id, cont=row_container: self._remove_marco_row(vid, cont))
                
                btns_lay.addWidget(btn_zoom)
                btns_lay.addWidget(btn_link)
                btns_lay.addWidget(btn_del)
                dr_lay.addWidget(btns_widget, 2)
                
                # 4. Campo Valor
                ext_val = v.get('extension_len', 10.0)
                display_val = "10.0"
                if isinstance(ext_val, (int, float)):
                     display_val = f"{ext_val:.1f}"
                elif isinstance(ext_val, str) and ext_val.replace('.','',1).isdigit():
                     display_val = ext_val
                else: 
                     display_val = "10.0" # Fallback se vier lixo (ex: 'Polyline...')

                val_edit = QLineEdit(display_val)
                val_edit.setFixedWidth(60)
                val_edit.setAlignment(Qt.AlignCenter)
                val_edit.setStyleSheet("""
                    QLineEdit { 
                        background: #181818; border: 1px solid #333; color: #00e676; 
                        font-weight: bold; border-radius: 4px; font-size: 12px; padding: 2px;
                    }
                    QLineEdit:focus { border: 1px solid #00e676; background: #202020; }
                """)
                val_edit.textChanged.connect(lambda t, k=field_key: self._on_field_changed(k, t))
                self.fields[field_key] = val_edit
                
                dr_lay.addWidget(val_edit, 2)
                
                row_v_lay.addWidget(data_row)
                row_v_lay.addWidget(drawer)
                layout.addWidget(row_container)

        # Bot√£o Adicionar Nova Viga
        btn_add = QPushButton("‚ûï ADICIONAR VIGA MANUAL")
        btn_add.setStyleSheet("""
            QPushButton { background: #1a3a5a; color: #00d4ff; border: 1px dashed #00d4ff; padding: 8px; font-weight: bold; margin-top: 10px; border-radius: 4px;}
            QPushButton:hover { background: #2a5a8a; border-style: solid; }
        """)
        btn_add.clicked.connect(self._add_manual_marco_row)
        layout.addWidget(btn_add)

        # Uni√µes do Marco (Separado)
        group_uniao = QGroupBox("FECHAMENTO DO MARCO (UNI√ïES PONTAS)")
        group_uniao.setStyleSheet("QGroupBox { font-size: 11px; font-weight: bold; color: #ffb300; border: 1px solid #333; margin-top: 20px; padding-top: 15px; }")
        uniao_layout = QFormLayout(group_uniao)
        self._add_linked_row(uniao_layout, "Uni√µes Marco:", "unioes_marco", pick_type='poly', hide_input=True)
        layout.addWidget(group_uniao)
        
        layout.addStretch()
        layout_container.addWidget(container)

    def _remove_marco_row(self, v_id, container):
        """Remove uma viga da lista de extremidades e limpa seus v√≠nculos"""
        # Exclus√£o direta conforme solicitado
        vigas = self.item_data.get('vigas_individuais', [])
        self.item_data['vigas_individuais'] = [v for v in vigas if v.get('id') != v_id]
        
        # Limpar v√≠nculos do campo
        field_key = f"ext_viga_{v_id}"
        if 'links' in self.item_data and field_key in self.item_data['links']:
            del self.item_data['links'][field_key]
        
        if field_key in self.fields:
            del self.fields[field_key]
        
        # Remover widget
        container.deleteLater()
        
        # Sincronizar mudan√ßa externamente
        self.data_changed.emit(self.item_data)
        self.refresh_validation_styles()

    def _add_manual_marco_row(self):
        """Adiciona manualmente uma nova viga √† lista de tratamento pr√©vio"""
        new_id = str(uuid.uuid4())[:8]
        new_viga = {
            'id': new_id,
            'type': 'line',
            'points': [],
            'text': f'Viga_{new_id[:4]}',
            'original_len': 0.0,
            'extension_len': 10.0,
            'final_len': 10.0
        }
        
        if 'vigas_individuais' not in self.item_data:
            self.item_data['vigas_individuais'] = []
            
        self.item_data['vigas_individuais'].append(new_viga)
        
        # Iniciar links vazios para ela (Main = Viga Total, Default = Segmento Ajuste)
        if 'links' not in self.item_data: self.item_data['links'] = {}
        self.item_data['links'][f"ext_viga_{new_id}"] = {'main': [], 'default': []}
        
        # Feedback visual removido para dinamismo
    def _on_slot_na_toggled(self, field_id, slot_id, is_na):
        """Gerencia o N/A de um slot espec√≠fico (Classe de V√≠nculo)"""
        na_slots_map = self.item_data.setdefault('na_link_classes', {})
        na_list = na_slots_map.setdefault(field_id, [])
        
        if is_na:
            if slot_id not in na_list: na_list.append(slot_id)
            # Limpar links deste slot
            if 'links' in self.item_data and field_id in self.item_data['links']:
                field_links = self.item_data['links'][field_id]
                if isinstance(field_links, dict) and slot_id in field_links:
                    print(f"[DEBUG HIERARCHY] Slot '{slot_id}' marked N/A. Clearing {len(field_links[slot_id])} links.")
                    field_links[slot_id] = []
            # Limpar valida√ß√£o se marcar N/A
            valid_map = self.item_data.get('validated_link_classes', {})
            if field_id in valid_map and slot_id in valid_map[field_id]:
                valid_map[field_id].remove(slot_id)
            
            # Emitir Treino para N/A da Classe
            self.training_requested.emit(field_id, {
                'status': 'na',
                'comment': f"Usu√°rio marcou classe {slot_id} como N/A",
                'slot': slot_id
            })
        else:
            if slot_id in na_list: na_list.remove(slot_id)
            print(f"[DEBUG HIERARCHY] Slot '{slot_id}' unmarked N/A.")
            
        print(f"[DetailCard] Slot NA toggled: {field_id} -> {slot_id} = {is_na}")
        self.data_changed.emit(self.item_data)
        self.refresh_validation_styles()

    def _on_slot_validated(self, field_id, slot_id):
        """Valida todos os links dentro de um slot espec√≠fico (CASCATA DIRETA: Classe -> Links)"""
        # 1. Marcar a classe como validada explicitamente
        valid_map = self.item_data.setdefault('validated_link_classes', {})
        v_list = valid_map.setdefault(field_id, [])
        if slot_id not in v_list: v_list.append(slot_id)
        
        # 2. Validar todos os links internos
        if 'links' in self.item_data and field_id in self.item_data['links']:
            field_links = self.item_data['links'][field_id]
            if isinstance(field_links, dict) and slot_id in field_links:
                print(f"[DEBUG HIERARCHY] Slot '{slot_id}' validated. Cascading to {len(field_links[slot_id])} links.")
                for link in field_links[slot_id]:
                    link['validated'] = True
                
        print(f"[DetailCard] Slot validated (Direct Hierarchy): {field_id} -> {slot_id}")
        self.data_changed.emit(self.item_data)
        self.refresh_validation_styles()

    def _refresh_dynamic_content(self):
        """Atualiza o conte√∫do din√¢mico (abas/campos) baseado no tipo e formato do item"""
        if not hasattr(self, 'dynamic_layout') or self.dynamic_layout is None:
            return
            
        # Limpar conte√∫do anterior do layout din√¢mico
        while self.dynamic_layout.count():
            item = self.dynamic_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
            elif item.layout():
                self._clear_layout_recursive(item.layout())
        
        itype = self.item_data.get('type', '').lower()
        if 'pilar' in itype: 
            self._setup_pilar_complex_view(self.dynamic_layout)
        elif 'viga' in itype: 
            self._setup_viga_complex_view(self.dynamic_layout)
        elif 'laje' in itype: 
            self._setup_laje_complex_view(self.dynamic_layout)
            
        # Garante que os estilos de valida√ß√£o se apliquem aos novos widgets criados
        self.refresh_validation_styles()

    def _clear_layout_recursive(self, layout):
        if not layout: return
        while layout.count():
            item = layout.takeAt(0)
            w = item.widget()
            if w: w.deleteLater()
            elif item.layout(): self._clear_layout_recursive(item.layout())
