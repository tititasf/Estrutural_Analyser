
# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

import sys
import os
import shutil
import logging
import time
from pathlib import Path

# --- CERTIFI PATCH FOR NUITKA/PYINSTALLER ---
if getattr(sys, 'frozen', False):
    import types
    cacert_path = os.path.join(os.path.dirname(__file__), "cacert.pem")
    if os.path.exists(cacert_path):
        certifi_mock = types.ModuleType("certifi")
        certifi_mock.where = lambda: cacert_path
        sys.modules["certifi"] = certifi_mock
        os.environ["REQUESTS_CA_BUNDLE"] = cacert_path

import requests
from tufup.client import Client
import winshell
from win32com.client import Dispatch

# --- GUI IMPORTS ---
try:
    from PySide6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QLabel, 
                                   QProgressBar, QMessageBox, QFrame, QMainWindow, QHBoxLayout,
                                   QPushButton, QCheckBox, QTextEdit, QStackedWidget)
    from PySide6.QtCore import Qt, QThread, Signal, QTimer
    from PySide6.QtGui import QIcon, QFont, QPalette, QColor, QPixmap
except ImportError:
    # Fallback if PySide6 missing (should not happen in bundled exe)
    print("CRITICAL: PySide6 not found. Running in headless mode.")
    sys.exit(1)

# Import config
try:
    from src import config
except ImportError:
    try:
        import config # Fallback for flat bundle
    except ImportError:
        sys.path.append(str(Path(__file__).parent.parent))
        try:
             from src import config
        except ImportError:
             import config

# Logging setup
logging.basicConfig(
    filename='updater.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# --- GLOBAL PROGRESS SIGNAL ---
class ProgressBridge(os.PathLike):
    """Bridge between Requests patch and GUI"""
    _callback = None
    
    @classmethod
    def set_callback(cls, cb):
        cls._callback = cb
    
    @classmethod
    def report(cls, current, total):
        if cls._callback:
            try:
                cls._callback(current, total)
            except:
                pass

# --- REQUESTS PATCH ---
_orig_request = requests.Session.request
def patched_request(self, method, url, *args, **kwargs):
    resp = _orig_request(self, method, url, *args, **kwargs)
    
    if resp.status_code == 400 and "not_found" in resp.text:
        resp.status_code = 404
    
    if resp.status_code == 404 and url.endswith(".tar.gz") and method.upper() == "GET":
        part1_url = f"{url}.part1"
        logging.debug(f"Checking for chunks: {part1_url}")
        
        with requests.Session() as s:
            p1_resp = s.head(part1_url, timeout=10)
            if p1_resp.status_code != 200:
                return resp 

        logging.info("Chunked download start...")
        temp_dir = Path(os.getenv('TEMP', '.')) / "AgenteCAD_Update"
        temp_dir.mkdir(parents=True, exist_ok=True)
        reassembled_file = temp_dir / "update_reassembled.tar.gz"
        
        # Sanity check: Try to find expected length in local metadata
        expected_len = None
        try:
            metadata_file = Path(os.path.expanduser("~/AppData/Local/AgenteCAD/metadata/targets.json"))
            if metadata_file.exists():
                import json
                with open(metadata_file, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                    filename = url.split("/")[-1]
                    target_meta = meta.get("signed", {}).get("targets", {}).get(filename)
                    if target_meta:
                        expected_len = target_meta.get("length")
                        logging.debug(f"Found expected length in metadata: {expected_len}")
        except Exception as e:
            logging.debug(f"Could not read metadata for length check: {e}")

        total_downloaded = 0
        part_num = 1
        
        try:
            with open(reassembled_file, "wb") as outfile:
                while True:
                    # GHOST PART PROTECTION: If we already reached the expected size, stop!
                    if expected_len is not None and total_downloaded >= expected_len:
                        logging.info(f"Reached expected size ({total_downloaded}), stopping reassembly.")
                        break

                    part_url = f"{url}.part{part_num}"
                    logging.info(f"Fetching {part_url}")
                    
                    success = False
                    for attempt in range(1, 6):
                        try:
                            with requests.Session() as s_part:
                                s_part.headers.update({"Connection": "close"})
                                p_resp = s_part.get(part_url, stream=True, timeout=30)
                                if p_resp.status_code != 200:
                                    break 
                                
                                for chunk in p_resp.iter_content(chunk_size=256*1024):
                                    if chunk:
                                        # GHOST PART PROTECTION: Don't write past expected size
                                        current_chunk = chunk
                                        if expected_len is not None:
                                            remaining = expected_len - total_downloaded
                                            if remaining <= 0:
                                                break
                                            if len(chunk) > remaining:
                                                current_chunk = chunk[:remaining]
                                        
                                        outfile.write(current_chunk)
                                        total_downloaded += len(current_chunk)
                                        # REPORT PROGRESS
                                        ProgressBridge.report(total_downloaded, expected_len or 0) 
                                
                                success = True
                                break 
                        except Exception:
                            time.sleep(1 * attempt)
                    
                    if not success:
                        break # End of parts or error
                    
                    part_num += 1
            
            if total_downloaded > 0:
                with open(reassembled_file, "rb") as final_f:
                    final_content = final_f.read()
                mock_resp = requests.Response()
                mock_resp.status_code = 200
                mock_resp._content = final_content
                mock_resp._content_consumed = True # Critical: Stop requests from reading .raw
                mock_resp.url = url
                return mock_resp
        except Exception:
            logging.exception("Reassembly failed")
            
    return resp
requests.Session.request = patched_request

# --- WORKER THREAD ---
class UpdateWorker(QThread):
    progress_sig = Signal(int, int) # current, total
    status_sig = Signal(str)
    finished_sig = Signal(bool, str) # success, message
    success_sig = Signal(dict) # Metadata for success screen

    def run(self):
        try:
            # Bridging
            ProgressBridge.set_callback(lambda c, t: self.progress_sig.emit(c, t))

            self.status_sig.emit("Inicializando...")
            install_base = Path(os.path.expanduser("~/AppData/Local/AgenteCAD"))
            install_base.mkdir(parents=True, exist_ok=True)
            target_dir = install_base / "app"
            metadata_dir = install_base / "metadata"
            target_dir.mkdir(parents=True, exist_ok=True)
            metadata_dir.mkdir(parents=True, exist_ok=True)

            # --- SETUP TRUST ---
            bundled_root = None
            if getattr(sys, 'frozen', False):
                bundled_root = Path(os.path.dirname(__file__)) / "root.json"
                if not bundled_root.exists():
                     bundled_root = Path(sys.executable).parent / "root.json"
            else:
                bundled_root = Path("repository/metadata/root.json")
            
            target_root = metadata_dir / "root.json"
            if not target_root.exists() and bundled_root and bundled_root.exists():
                shutil.copy(bundled_root, target_root)

            # --- FORCE INIT LOGIC ---
            reported_version = config.APP_VERSION
            if not (target_dir / "main.exe").exists():
                self.status_sig.emit("Preparando primeira instalação...")
                reported_version = "0.0.0"

            client = Client(
                app_name=config.APP_NAME,
                current_version=reported_version,
                metadata_dir=str(metadata_dir),
                metadata_base_url=config.UPDATE_METADATA_URL,
                target_dir=str(target_dir),
                target_base_url=config.UPDATE_TARGETS_URL,
                app_install_dir=str(target_dir)
            )

            # --- LAUNCHER SELF-COPY ---
            if getattr(sys, 'frozen', False):
                launcher_path = install_base / "AgenteCAD_Launcher.exe"
                current_exe = Path(sys.executable)
                if current_exe != launcher_path:
                    try:
                        shutil.copy2(current_exe, launcher_path)
                    except:
                        pass # Ignore if locked

            # --- SILENT INSTALL FUNCTION ---
            def silent_install(src_dir, dst_dir, **kwargs):
                import shutil
                import time
                from pathlib import Path
                
                self.status_sig.emit("Finalizing installation (Moving files)...")
                logging.info(f"Silent Install: {src_dir} -> {dst_dir}")
                
                # Wait a bit to ensure locks are released
                time.sleep(2)
                
                src = Path(src_dir)
                dst = Path(dst_dir)
                
                # Copy with overwrite
                count = 0
                for item in src.iterdir():
                    try:
                        if item.is_file():
                            shutil.copy2(item, dst / item.name)
                        elif item.is_dir():
                            if (dst / item.name).exists():
                                 shutil.rmtree(dst / item.name)
                            shutil.copytree(item, dst / item.name)
                        count += 1
                    except Exception as e:
                        logging.error(f"Failed to copy {item.name}: {e}")
                
                logging.info(f"Installation finished. {count} items moved.")
            
            # --- CHECK FOR UPDATES ---
            self.status_sig.emit("Checking for updates...")
            update = client.check_for_updates()
            
            if update:
                self.status_sig.emit(f"Downloading version {update.version}...")
                # Download with silent install hook
                client.download_and_apply_update(
                    skip_confirmation=True,
                    install=silent_install # Override default Robocopy behavior
                )
                self.status_sig.emit("Installation complete!")
            else:
                self.status_sig.emit("System up to date.")

            # --- SHORTCUTS ---
            try:
                self.create_shortcuts(install_base / "AgenteCAD_Launcher.exe", target_dir)
            except:
                logging.exception("Shortcut error")

            # --- FINISHED DATA ---
            main_exe = target_dir / "main.exe"
            if main_exe.exists():
                meta = {
                    "version": update.version if update else config.APP_VERSION,
                    "install_path": str(target_dir),
                    "shortcut_name": f"{config.APP_NAME}.lnk",
                    "exe_path": str(main_exe)
                }
                self.success_sig.emit(meta)
            else:
                self.finished_sig.emit(False, f"Erro: main.exe não encontrado em {target_dir}")

        except Exception as e:
            logging.exception("Update Worker Error")
            self.finished_sig.emit(False, str(e))

    def create_shortcuts(self, launcher, target_dir):
        try:
             desktop = Path(winshell.desktop())
             shortcut_path = desktop / f"{config.APP_NAME}.lnk"
             if getattr(sys, 'frozen', False) and launcher.exists():
                shell = Dispatch('WScript.Shell')
                s = shell.CreateShortCut(str(shortcut_path))
                s.Targetpath = str(launcher)
                s.WorkingDirectory = str(target_dir) # Launch in app dir
                s.IconLocation = str(target_dir / "main.exe")
                s.save()
        except:
            pass

import subprocess

# --- MODERN GUI ---
# --- PREMIUM GUI (Redesign) ---
class UpdaterGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Estrutural Analyzer")
        self.setFixedSize(800, 620)
        
        # Frameless Window with Dark Background
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        # Central Widget & Styling
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        central_widget.setStyleSheet("""
            QWidget {
                background-color: #0d0d0d;
                color: #ffffff;
                border: 1px solid #222;
                border-radius: 15px;
                font-family: 'Segoe UI', 'Outfit', sans-serif;
            }
            QLabel#Title {
                font-size: 28px;
                font-weight: bold;
                color: #ffffff;
                margin-bottom: 5px;
                border: none;
            }
            QLabel#Subtitle {
                font-size: 11px;
                font-weight: 700;
                color: #555555;
                letter-spacing: 3px;
                margin-bottom: 20px;
                border: none;
            }
            QProgressBar {
                background-color: #151515;
                border: 1px solid #222;
                border-radius: 6px;
                height: 12px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: qlineargradient(spread:pad, x1:0, y1:0, x2:1, y2:0, stop:0 #0077b6, stop:1 #00b4d8); 
                border-radius: 5px;
            }
            QLabel#Status {
                color: #999999;
                font-size: 13px;
                font-weight: 400;
                border: none;
            }
            QLabel#Footer {
                color: #333333;
                font-size: 9px;
                border: none;
            }
        """)

        # Layout
        self.main_layout = QVBoxLayout(central_widget)
        self.main_layout.setAlignment(Qt.AlignCenter)
        self.main_layout.setSpacing(10)
        self.main_layout.setContentsMargins(50, 40, 50, 40)

        # 1. Logo (Centered)
        self.logo_label = QLabel()
        self.logo_label.setObjectName("LogoLabel")
        self.logo_label.setStyleSheet("border: none; background: transparent;")
        self.logo_label.setAlignment(Qt.AlignCenter)
        
        logo_path = Path("assets/logo.jpg")
        if getattr(sys, 'frozen', False):
             base_path = Path(sys._MEIPASS)
             potential = base_path / "assets" / "logo.jpg"
             if potential.exists():
                 logo_path = potential
        
        if logo_path.exists():
            pixmap = QPixmap(str(logo_path))
            pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.logo_label.setPixmap(pixmap)
        
        self.main_layout.addWidget(self.logo_label)
        self.main_layout.addSpacing(5)

        # 2. Title and Subtitle
        self.title_label = QLabel("Installing Estrutural Analyzer...")
        self.title_label.setObjectName("Title")
        self.title_label.setAlignment(Qt.AlignCenter)
        self.main_layout.addWidget(self.title_label)

        self.subtitle_label = QLabel("PRECISION MESH SYNTHESIS ENGINE")
        self.subtitle_label.setObjectName("Subtitle")
        self.subtitle_label.setAlignment(Qt.AlignCenter)
        self.main_layout.addWidget(self.subtitle_label)

        # --- CONTENT STACK ---
        self.stack = QStackedWidget()
        self.stack.setStyleSheet("background: transparent; border: none;")
        self.main_layout.addWidget(self.stack)

        # Page 0: Progress
        self.progress_page = QWidget()
        prog_vbox = QVBoxLayout(self.progress_page)
        prog_vbox.addStretch()
        
        self.status_label = QLabel("Initializing environment...")
        self.status_label.setObjectName("Status")
        prog_vbox.addWidget(self.status_label)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(False) 
        prog_vbox.addWidget(self.progress_bar)
        prog_vbox.addStretch()
        
        self.stack.addWidget(self.progress_page)

        # 5. Footer (Fake HW Info)
        footer_layout = QHBoxLayout()
        accel_label = QLabel("HARDWARE ACCELERATION\nNVIDIA CUDA™ Enabled")
        accel_label.setStyleSheet("color: #00b4d8; font-weight: bold; font-size: 8px; border: none; background: transparent;")
        footer_layout.addWidget(accel_label)
        
        footer_layout.addStretch()
        
        license_label = QLabel("LICENSE TYPE\nEnterprise Site License")
        license_label.setStyleSheet("color: #444444; font-weight: bold; font-size: 8px; border: none; background: transparent;")
        footer_layout.addWidget(license_label)

        self.main_layout.addLayout(footer_layout)

        # Worker
        self.worker = UpdateWorker()
        self.worker.progress_sig.connect(self.update_progress)
        self.worker.status_sig.connect(self.update_status)
        self.worker.finished_sig.connect(self.on_finished)
        self.worker.success_sig.connect(self.show_success_screen)
        
        # Start
        QTimer.singleShot(1500, self.worker.start)

    def show_success_screen(self, meta):
        # Page 1: Success
        success_page = QWidget()
        success_vbox = QVBoxLayout(success_page)
        success_vbox.setSpacing(15)
        
        self.title_label.setText("Deployment Successful")
        self.subtitle_label.setText("ESTRUTURAL ANALYZER IS READY")
        
        # Info
        info_label = QLabel(f"<b>Version:</b> {meta['version']}<br>"
                            f"<b>Location:</b> {meta['install_path']}<br>"
                            f"<b>Shortcut:</b> Desktop / {meta['shortcut_name']}")
        info_label.setStyleSheet("color: #aaa; font-size: 11px; border: none;")
        success_vbox.addWidget(info_label)
        
        # Changelog
        log_box = QTextEdit()
        log_box.setReadOnly(True)
        log_box.setText("CHANGELOG v" + meta['version'] + "\n" +
                        "• Premium Dark Design Architecture applied.\n" +
                        "• Implemented Silent Pythonic Deployer.\n" +
                        "• Fixed Ghost-Part reassembly vulnerability.\n" +
                        "• Optimized Hardware Acceleration bridges.")
        log_box.setStyleSheet("""
            QTextEdit {
                background-color: #111;
                border: 1px solid #222;
                border-radius: 8px;
                color: #888;
                font-size: 10px;
                padding: 10px;
            }
        """)
        log_box.setFixedHeight(140)
        success_vbox.addWidget(log_box)
        
        # Checkbox & Button Layout
        bottom_row = QHBoxLayout()
        
        self.launch_cb = QCheckBox("Launch Estrutural Analyzer now")
        self.launch_cb.setChecked(True)
        self.launch_cb.setCursor(Qt.PointingHandCursor)
        self.launch_cb.setStyleSheet("""
            QCheckBox {
                color: #00b4d8; 
                font-weight: bold; 
                border: none; 
                font-size: 13px;
                background: transparent;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        bottom_row.addWidget(self.launch_cb)
        
        bottom_row.addStretch()
        
        finish_btn = QPushButton("FINISH & DEPLOY")
        finish_btn.setCursor(Qt.PointingHandCursor)
        finish_btn.setStyleSheet("""
            QPushButton {
                background-color: #00b4d8;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 12px 35px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #0096b4;
            }
        """)
        finish_btn.clicked.connect(lambda: self.finalize_deployment(meta))
        bottom_row.addWidget(finish_btn)
        
        success_vbox.addLayout(bottom_row)
        
        # Add page and switch
        self.stack.addWidget(success_page)
        self.stack.setCurrentIndex(1)

    def finalize_deployment(self, meta):
        if self.launch_cb.isChecked():
            logging.info("User requested launch on exit.")
            subprocess.Popen([meta['exe_path']], cwd=meta['install_path'])
        
        self.close()
        QApplication.quit()

    def update_progress(self, current, total):
        logging.debug(f"GUI Progress: {current} / {total}")
        if total > 0:
            self.progress_bar.setRange(0, 100)
            pct = int((current / total) * 100)
            self.progress_bar.setValue(pct)
            
            mb_curr = current / (1024 * 1024)
            mb_total = total / (1024 * 1024)
            self.status_label.setText(f"System update in progress... {mb_curr:.1f} MB / {mb_total:.1f} MB")
        else:
             # Indeterminate mode
             if self.progress_bar.maximum() != 0:
                 self.progress_bar.setRange(0, 0) 
             
             mb_curr = current / (1024 * 1024)
             self.status_label.setText(f"Streaming resources... {mb_curr:.1f} MB received")

    def update_status(self, msg):
        logging.info(f"Status Update: {msg}")
        # Map to professional English
        mapping = {
            "Inicializando...": "Initializing core modules...",
            "Preparando primeira instalação...": "Allocating local environment...",
            "Checking for updates...": "Checking global update server...",
            "Iniciando AgenteCAD...": "Launching Estrutural Analyzer...",
            "Finalizing installation (Moving files)...": "Deploying assets to target directory..."
        }
        display_msg = mapping.get(msg, msg)
        self.status_label.setText(display_msg)

    def on_finished(self, success, msg):
        if success:
             logging.info("Exiting GUI - Launching successful")
             self.close()
             QApplication.quit()
        else:
            logging.error(f"Terminating with error: {msg}")
            self.status_label.setText("Critical Deployment Failure")
            self.status_label.setStyleSheet("color: #ff5555; font-weight: bold; border: none;")
            QMessageBox.critical(self, "Deployment Error", f"The installation could not be completed:\n\n{msg}\n\nPlease check updater.log for details.")
            self.close()
            QApplication.quit()

    # Enable Dragging
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton:
            self.move(event.globalPosition().toPoint() - self.drag_position)
            event.accept()

def run_gui():
    app = QApplication(sys.argv)
    
    # App Icon
    app_icon_path = Path("assets/icon.ico")
    if getattr(sys, 'frozen', False):
         base_path = Path(sys._MEIPASS)
         potential = base_path / "assets" / "icon.ico"
         if potential.exists():
             app_icon_path = potential
 
    if app_icon_path.exists():
        app.setWindowIcon(QIcon(str(app_icon_path)))

    window = UpdaterGUI()
    window.show()
    app.exec()

if __name__ == "__main__":
    try:
        logging.info("=== STARTING UPDATER ===")
        run_gui()
    except Exception as e:
        logging.exception("Startup crash")
        try:
            with open("updater_crash.txt", "w") as f:
                f.write(str(e))
        except:
            pass
        sys.exit(1)
