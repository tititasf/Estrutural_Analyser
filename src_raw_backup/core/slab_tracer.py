
# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str("script.google.com"): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str("macros/s/"): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str("AKfycbz"): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str("credit"): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str("saldo"): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str("consumo"): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("api_key"): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str("user_id"): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str("calcular_creditos"): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str("confirmar_consumo"): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str("consultar_saldo"): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str("debitar_creditos"): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str("CreditManager"): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str("obter_hwid"): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str("generate_signature"): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str("encrypt_string"): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str("decrypt_string"): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str("integrity_check"): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str("security_utils"): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str("https://"): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str("google.com"): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str("apps.script"): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str("script.google.com")): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("macros/s/")): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("AKfycbz")): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("credit")): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("saldo")): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consumo")): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("api_key")): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("user_id")): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("calcular_creditos")): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("confirmar_consumo")): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("consultar_saldo")): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("debitar_creditos")): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("CreditManager")): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("obter_hwid")): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("generate_signature")): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("encrypt_string")): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("decrypt_string")): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("integrity_check")): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("security_utils")): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("https://")): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("google.com")): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str("apps.script")): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str("script.google.com"))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("macros/s/"))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("AKfycbz"))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("credit"))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("saldo"))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consumo"))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("api_key"))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("user_id"))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos"))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo"))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo"))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos"))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("CreditManager"))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("obter_hwid"))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("generate_signature"))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("encrypt_string"))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("decrypt_string"))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("integrity_check"))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("security_utils"))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("https://"))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("google.com"))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str("apps.script"))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)


# Helper de ofuscação (adicionado automaticamente)
def _get_obf_str(key):
    """Retorna string ofuscada"""
    _obf_map = {
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("script.google.com")))): base64.b64decode("=02bj5SZsd2bvdmL0BXayN2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("macros/s/")))): base64.b64decode("vM3Lz9mcjFWb"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("AKfycbz")))): base64.b64decode("==geiNWemtUQ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("credit")))): base64.b64decode("0lGZlJ3Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("saldo")))): base64.b64decode("=8GZsF2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consumo")))): base64.b64decode("==wbtV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("api_key")))): base64.b64decode("==Qelt2XpBXY"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("user_id")))): base64.b64decode("==AZp9lclNXd"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("calcular_creditos")))): base64.b64decode("=M3b0lGZlJ3YfJXYsV3YsF2Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("confirmar_consumo")))): base64.b64decode("=8Wb1NnbvN2XyFWbylmZu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("consultar_saldo")))): base64.b64decode("vRGbhN3XyFGdsV3cu92Y"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("debitar_creditos")))): base64.b64decode("==wcvRXakVmcj9lchRXaiVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("CreditManager")))): base64.b64decode("==gcldWYuFWT0lGZlJ3Q"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("obter_hwid")))): base64.b64decode("==AZpdHafJXZ0J2b"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("generate_signature")))): base64.b64decode("lJXd0Fmbnl2cfVGdhJXZuV2Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("encrypt_string")))): base64.b64decode("=cmbpJHdz9Fdwlncj5WZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("decrypt_string")))): base64.b64decode("=cmbpJHdz9FdwlncjVGZ"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("integrity_check")))): base64.b64decode("rNWZoN2X5RXaydWZ05Wa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("security_utils")))): base64.b64decode("=MHbpRXdflHdpJXdjV2c"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("https://")))): base64.b64decode("=8yL6MHc0RHa"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("google.com")))): base64.b64decode("==QbvNmLlx2Zv92Z"[::-1].encode()).decode(),
        _get_obf_str(_get_obf_str(_get_obf_str(_get_obf_str("apps.script")))): base64.b64decode("=QHcpJ3Yz5ycwBXY"[::-1].encode()).decode(),
    }
    return _obf_map.get(key, key)

from shapely.geometry import Point, LineString, Polygon, MultiLineString
from shapely.ops import polygonize, unary_union
from typing import List, Tuple, Optional, Dict
import math

class SlabTracer:
    """
    Algoritmo 'Boundary Tracer' para Lajes.
    Usa 'Path Finding' (Polygonize) para encontrar polígonos fechados formados por vigas/paredes.
    """
    def __init__(self, spatial_index):
        self.spatial_index = spatial_index
        self.global_boundary = None
        
    def _init_global_boundary(self):
        """
        Calcula o 'Envelope' global do desenho para validar o que é 'Exterior'.
        Prioridade: 
        1. Layers explicitos ('MARCO', 'CONTORNO', 'LIMITE').
        2. Se não achar, Convex Hull de toda a estrutura (Vigas/Paredes).
        """
        marco_geoms = []
        structure_geoms = []
        
        # Iterar todos os itens do indice
        # O spatial_index expõe 'items' (Dict[int, Any])
        all_items = list(self.spatial_index.items.values()) if hasattr(self.spatial_index, 'items') else []
        
        invalid_layers = ['COTA', 'DIM', 'TEXT', 'EIXO', 'HATCH', 'MP_', 'OBS', 'TITULO']
        
        for item in all_items:
            geom = None
            layer = ""
            
            if isinstance(item, dict):
                layer = item.get('layer', '').upper()
                if 'points' in item: geom = LineString(item['points'])
                elif 'start' in item: geom = LineString([item['start'], item['end']])
            elif isinstance(item, list) and len(item) > 1:
                geom = LineString(item) # Tupla antiga/lista
                
            if not geom: continue
            
            # Checar se é Marco
            if any(k in layer for k in ['MARCO', 'CONTORNO', 'LIMITE', 'FRAME']):
                marco_geoms.append(geom)
            
            # Checar se é Estrutura (para fallback)
            is_invalid = any(k in layer for k in invalid_layers)
            if not is_invalid:
                structure_geoms.append(geom)
                
        if marco_geoms:
            # Temos um Marco explicito!
            print(f"[INFO] Detectado Marco Global com {len(marco_geoms)} segmentos.")
            try:
                self.global_boundary = unary_union(marco_geoms)
            except:
                self.global_boundary = unary_union(marco_geoms).convex_hull
        elif structure_geoms:
            # Fallback: Convex Hull de tudo
            print(f"[INFO] Marco não detectado. Usando Convex Hull da estrutura ({len(structure_geoms)} segmentos).")
            try:
                # Unary union de muitas linhas pode ser lento. 
                # Otimizacao: Convex Hull dos PONTOS extremidades?
                # Sim, extrair todos os pontos e fazer convex hull é muito mais rapido.
                all_points = []
                for g in structure_geoms:
                    all_points.extend(g.coords)
                
                if all_points:
                    from shapely.geometry import MultiPoint
                    self.global_boundary = MultiPoint(all_points).convex_hull
            except Exception as e:
                print(f"[ERROR] Falha ao calcular Convex Hull: {e}")
                self.global_boundary = None
        
        if self.global_boundary:
             # Otimização: Converter para apenas Exterior Ring se for Poligono (ignorar buracos internos do Hull)
             if isinstance(self.global_boundary, Polygon):
                 self.global_boundary = self.global_boundary.exterior
             elif isinstance(self.global_boundary, MultiLineString):
                 self.global_boundary = self.global_boundary

    def trace_boundary(self, start_point: Tuple[float, float], search_radius: float = 1000.0, valid_layers: List[str] = None) -> Optional[Polygon]:
        """
        Encontra o polígono fechado que contém o start_point.
        valid_layers: Lista de layers permitidos/preferenciais.
        """
        # 1. Coletar linhas candidatas no raio ao redor do ponto
        cx, cy = start_point
        bounds = (cx - search_radius, cy - search_radius, cx + search_radius, cy + search_radius)
        
        candidates = self.spatial_index.query_bbox(bounds)
        lines = []
        
        for item in candidates:
            # Item: geometria original ou dict que a envelopa?
            # O SpatialIndex guarda o objeto original passado no insert.
            # No DXFLoader modificado, lines/polylines são dicts com 'layer'.
            
            geom = None
            layer = None
            
            if isinstance(item, dict):
                # Se for dict vindo do DXFLoader novo
                layer = item.get('layer')
                if 'points' in item: # Polyline
                    pts = item['points']
                    if len(pts) > 1: geom = LineString(pts)
                elif 'start' in item: # Line
                    geom = LineString([item['start'], item['end']])
            
            # Retrocompatibilidade com tupla crua (caso algo mais insira assim)
            elif isinstance(item, tuple) and len(item) == 2: 
                geom = LineString(item)
            elif isinstance(item, list) and len(item) > 1:
                geom = LineString(item)
                
            if geom:
                # Filtragem por Layer (Inteligência)
                if valid_layers:
                    # Se tiver filtro e a linha tiver layer, testamos.
                    # Se linha não tiver layer (tupla antiga), aceitamos ou rejeitamos? Aceitamos por segurança.
                    # Mas se tiver layer e não estiver na lista, rejeita.
                    if layer and layer not in valid_layers:
                        continue
                
                lines.append(geom)
        
        if not lines:
            return None

        # 2. Polygonize
        # Pode ser pesado se muitas linhas. Unary_union ajuda a limpar?
        # Polygonize requer linhas que se tocam perfeitamente ou cruzam.
        # DXF real pode ter gaps. (MVP: Assumir conexões decentes ou tolerância zero).
        
        try:
            # TENTATIVA 1: Noding Rápido (assumindo conexões decentes)
            # unary_union corrige interseções não-nodadas (linhas cruzando sem vertice comum)
            # É fundamental para DXF onde desenhista pode ter passado linha direto.
            noded_lines = unary_union(lines) 
            
            # polygonize retorna gerador de poligonos
            polygons = list(polygonize(noded_lines))
            
            target_pt = Point(cx, cy)
            
            # Encontrar qual polígono contém o ponto
            # Otimização: Ordenar por área (preferir menor polígono fechado que contém o ponto - "sala")
            # Mas polygonize geralmente retorna poligonos atômicos (faces).
            for poly in polygons:
                if poly.contains(target_pt):
                    return poly
            
            # Se não achou com noding simples, pode ser que o ponto esteja EXATAMENTE na borda?
            # Ou que linhas tenham gap micrométrico.
            
            # TENTATIVA 2: Snap / Buffer (Lento, usar só se falhar 1)
            # Buffer pequeno pode fechar gaps
            # Mas cuidado para não fechar passagens reais.
            # Implementação futura se necessário.
            
        except Exception as e:
            # Falha na geometria
            print(f"[DEBUG] Trace Error: {e}")
            return None
                    
        except Exception as e:
            # Falha na geometria
            return None
            
        return None


    def detect_extensions(self, main_poly: Polygon, search_radius: float = 50.0) -> List[Dict]:
        """
        Detecta e GERA 'acréscimos' (strips de 10 unidades) em bordas externas.
        Estratégia: Generative Edge Extrusion (V4).
        1. Para cada aresta da laje:
        2. Testar se aponta para o 'vazio' (Ray Cast).
        3. Se for vazio, extrudar aresta em 10 unidades e criar polígono.
        """
        if not main_poly or not self.spatial_index:
            return []

        generated_extensions = []
        
        coords = list(main_poly.exterior.coords)
        if len(coords) < 2: return []
        
        # Remove duplicate last point for indexing ease (LinearRing logic)
        if coords[0] == coords[-1]:
            coords = coords[:-1]
        
        num_pts = len(coords)
        if num_pts < 3: return []

        # Parameters
        BLOCK_DIST_THRESHOLD = 1000.0 # 10m
        EXTENSION_WIDTH = 10.0
        
        # 1. Classification Phase
        # ---------------------
        edge_status = [] # True=Free, False=Blocked
        
        for i in range(num_pts):
            p1 = coords[i]
            p2 = coords[(i+1)%num_pts] # Wrap around
            
            # Geometry Check
            edge = LineString([p1, p2])
            if edge.length < 1.0: 
                edge_status.append(False) # Too short, ignore/block
                continue
                
            # --- Ray Cast Logic (Reuse V4) ---
            dx = p2[0] - p1[0]
            dy = p2[1] - p1[1]
            length = (dx*dx + dy*dy)**0.5
            nx, ny = -dy/length, dx/length
            
            # Ensure Normal is Outward
            mid = edge.interpolate(0.5, normalized=True)
            check_pt = (mid.x + nx*0.1, mid.y + ny*0.1)
            if main_poly.contains(Point(check_pt)):
                nx, ny = -nx, -ny
            
            # Fan Scan
            angles = [0, -10, 10]
            is_blocked = False
            
            for ang in angles:
                rad = math.radians(ang)
                rnx = nx * math.cos(rad) - ny * math.sin(rad)
                rny = nx * math.sin(rad) + ny * math.cos(rad)
                
                r_start = (mid.x + rnx*1.0, mid.y + rny*1.0)
                r_end = (r_start[0] + rnx*5000.0, r_start[1] + rny*5000.0)
                ray_geom = LineString([r_start, r_end])
                
                hits = self.spatial_index.query_bbox(ray_geom.bounds)
                
                for h in hits:
                    h_geom = None
                    if isinstance(h, dict):
                        if 'points' in h: h_geom = LineString(h['points'])
                        elif 'start' in h: h_geom = LineString([h['start'], h['end']])
                    elif isinstance(h, list) and len(h) > 1: h_geom = LineString(h)
                    
                    if not h_geom: continue
                    if not ray_geom.intersects(h_geom): continue
                    
                    if Point(r_start).distance(h_geom) < BLOCK_DIST_THRESHOLD:
                        is_blocked = True
                        break
                if is_blocked: break
            
            edge_status.append(not is_blocked)
            
        # 2. Chaining Phase
        # -----------------
        # Find continuous sequences of True
        chains = []
        if not edge_status: return []
        
        # Rotate logic to handle wrap-around easily
        # Ensure we don't start in the middle of a True chain
        start_idx = 0
        if all(edge_status):
            # Special Case: All Free (Island)
            chains.append(list(range(num_pts)) + [0]) # Full Loop
        else:
            # Shift start_idx to a False (Blocked) to ensure Chain starts cleanly
            if edge_status[0]:
                for k in range(num_pts):
                    if not edge_status[k]:
                        start_idx = (k + 1) % num_pts
                        break
            
            current_chain = []
            for k in range(num_pts):
                idx = (start_idx + k) % num_pts
                if edge_status[idx]:
                    if not current_chain:
                        current_chain.append(idx)
                    current_chain.append((idx + 1) % num_pts)
                else:
                    if current_chain:
                        chains.append(current_chain)
                        current_chain = []
            
            # Append last chain if exists
            if current_chain:
                chains.append(current_chain)

        # 3. Generation Phase (Offset)
        # ----------------------------
        for chain_indices in chains:
            # Extract geometry points
            pts = [coords[i] for i in chain_indices]
            if len(pts) < 2: continue
            
            line = LineString(pts)
            
            # Determining Side for Offset
            # Shapely's offset_curve:
            # Positive distance = Left side
            # Negative distance = Right side
            # If Polygon is CCW, Outwards is RIGHT (-distance)
            # We need to verify basic winding or just try.
            # Usually LinearRing is CCW. So we try -EXTENSION_WIDTH.
            
            try:
                # Try Negative Offset (Right/Outwards for CCW)
                offset_dist = -EXTENSION_WIDTH
                offset_line = line.offset_curve(offset_dist, join_style=2) # 2=Mitre
                
                # Validation: Check if offset is actually outside
                # Take midpoint of offset line
                test_pt = offset_line.interpolate(0.5, normalized=True)
                if main_poly.contains(test_pt) or main_poly.distance(test_pt) < 1.0:
                    # Oops, it went inside. Flip sign.
                    # This handles CW polygons too.
                    offset_dist = EXTENSION_WIDTH
                    offset_line = line.offset_curve(offset_dist, join_style=2)
                
                # Construct Polygon
                # Pts -> ... -> OffsetPts(Reversed) -> Pts[0]
                
                # Careful with OffsetCurve output, it might be MultiLineString if complex, 
                # but for simple chains it should be LineString.
                if hasattr(offset_line, 'geoms'): # MultiLineString
                     # Fallback to simple segment processing? 
                     # Or pick longest? Usually happens if self-intersecting.
                     # Simplified approach: skip complex stuff or take largest
                     continue
                
                off_coords = list(offset_line.coords)
                
                # Ring Construction:
                # Original Line (A->B->C) + Offset Line Reversed (C'->B'->A') + Close
                if offset_dist > 0:
                   # If Positive (Left), offset runs A->B direction? No, offset direction usually matches index.
                   # Let's trust coords order and reverse one of them to form loop.
                   pass
                
                # Standard Loop: Pts + Reversed(Offset)
                # Note: offset_curve usually returns points usually in same direction as input
                final_loop = pts + off_coords[::-1] + [pts[0]]
                
                ext_poly = Polygon(final_loop)
                
                # Fix self-intersections if any (buffer 0)
                if not ext_poly.is_valid:
                    ext_poly = ext_poly.buffer(0)

                generated_extensions.append({
                    'type': 'poly',
                    'points': list(ext_poly.exterior.coords),
                    'role': 'Acrescimo_borda',
                    'width_est': EXTENSION_WIDTH,
                    'side': 'Composite' # Generic side
                })
                
            except Exception as e:
                print(f"[ERROR] Failed to generate offset for chain: {e}")
                continue

        return generated_extensions


    def detect_slabs_from_texts(self, texts: List[Dict], search_radius: float = 2000.0, valid_layers: List[str] = None) -> List[Dict]:
        """
        Varre textos buscando padrões de laje (Lx, Laje X) e tenta traçar limites.
        """
        slabs = []
        import re
        # Padrão: Começa com L seguido de numero, ou LAJE...
        # Ex: "L1", "L-2", "LAJE 03"
        slab_pattern = re.compile(r'^(L|LAJE)\s*[-_]?\s*\d+[a-zA-Z]*$', re.IGNORECASE)
        
        # DEBUG
        sample_texts = [t.get('text') for t in texts[:5]]
        print(f"[DEBUG] SlabTracer checking {len(texts)} texts. Patterns found?")
        
        for t in texts:
            txt = t.get('text', '').strip()
            if slab_pattern.match(txt):
                pos = t.get('pos')
                if not pos: continue
                
                # Tentar traçar contorno
                poly = self.trace_boundary(pos, search_radius, valid_layers=valid_layers)
                
                found_poly = bool(poly)
                points = []
                area = 0.0
                
                extensions = []
                
                if poly:
                    points = list(poly.exterior.coords)
                    area = poly.area
                    
                    # --- NOVA INTELIGÊNCIA: Detectar Acréscimos ---
                    try:
                        extensions = self.detect_extensions(poly)
                    except Exception as e:
                        print(f"Erro detectando extensões Laje {txt}: {e}")
                    # -----------------------------------------------
                    
                else:
                    # Fallback: Quadrado de 50x50 em volta do texto
                    cx, cy = pos
                    points = [
                        (cx-25, cy-25), (cx+25, cy-25),
                        (cx+25, cy+25), (cx-25, cy+25),
                        (cx-25, cy-25)
                    ]
                
                slabs.append({
                    'id': f"temp_{len(slabs)}", # Temp ID
                    'name': txt.upper(), # L1
                    'pos': pos,
                    'points': points,
                    'area': area,
                    'neighbors': [],
                    'is_detected': found_poly,
                    'is_validated': False, # Novo slab vindo do trace
                    'type': 'Laje',
                    'extensions': extensions # Passar adiante
                })
        
        return slabs

